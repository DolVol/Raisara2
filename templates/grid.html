<!DOCTYPE html>
<html>
<head>
    <title>{{ dome.name }} - Tree Grid</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f0f0f0;
            overflow-x: auto; /* Allow horizontal scrolling */
        }
        .container {
            max-width: none; /* Remove max-width constraint for large grids */
            margin: 0 auto;
            min-width: 320px; /* Minimum width for mobile */
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .dome-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .dome-image {
            width: 80px;
            height: 80px;
            background-image: url('/static/images/dome.jpg');
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 3px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            position: relative;
        }
        .dome-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .dome-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-image: url('/static/images/gunja.jpg');
            background-size: cover;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.2;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        .dome-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .dome-title {
            font-size: 28px;
            color: #2e7d32;
            margin: 0;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .grid-controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        .grid-controls label {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .grid-controls input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        
        /* Grid container with horizontal scroll */
        .grid-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: visible;
            padding: 10px 0;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            scroll-behavior: smooth;
        }
        
        .tree-grid {
            display: grid;
            gap: var(--grid-gap, 8px);
            padding: 20px;
            margin: 0 auto;
            min-width: fit-content;
        }
        
        /* Dynamic cell sizing based on grid size */
        .grid-cell {
            aspect-ratio: 1;
            border: 2px dashed #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--cell-size, 100px);
            height: var(--cell-size, 100px);
            position: relative;
            transition: all 0.3s ease;
            background: #fafafa;
            cursor: pointer;
        }
        .grid-cell:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
            transform: scale(1.05);
        }
        .grid-cell.occupied {
            border: 2px solid #4CAF50;
            background: #e8f5e8;
        }
        .grid-cell.drag-over {
            border: 2px solid #ff9800 !important;
            background: #fff3e0 !important;
            transform: scale(1.05);
        }
        .grid-cell.swap-target {
            border: 2px solid #9c27b0 !important;
            background: #f3e5f5 !important;
            transform: scale(1.05);
        }
        .tree-item {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            box-sizing: border-box;
            position: relative;
            border-radius: 6px;
            cursor: grab;
        }
        .tree-item:active {
            cursor: grabbing;
        }
        .tree-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        .tree-image {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            background-image: url('/static/images/gunja.jpg');
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 2px solid #4CAF50;
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: none;
            position: relative;
        }
        .tree-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .tree-placeholder {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            border-radius: 50%;
            background-image: url('/static/images/gunja.jpg');
            background-size: cover;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: calc(var(--cell-size, 100px) * 0.12);
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.1;
            pointer-events: none;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        .tree-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .tree-name {
            font-size: calc(var(--cell-size, 100px) * 0.1);
            font-weight: bold;
            color: #2e7d32;
            text-align: center;
            word-wrap: break-word;
            max-width: 100%;
            line-height: 1.2;
            pointer-events: none;
        }
        .tree-actions {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            flex-direction: column;
            gap: 1px;
        }
        .tree-item:hover .tree-actions {
            display: flex;
        }
        .action-btn {
            width: calc(var(--cell-size, 100px) * 0.2);
            height: calc(var(--cell-size, 100px) * 0.2);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: calc(var(--cell-size, 100px) * 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        .edit-btn {
            background: #2196F3;
            color: white;
        }
        .delete-btn {
            background: #f44336;
            color: white;
        }
        .add-tree-btn {
            background: none;
            border: 2px dashed #4CAF50;
            color: #4CAF50;
            font-size: calc(var(--cell-size, 100px) * 0.2);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: 100%;
            height: 100%;
        }
        .add-tree-btn:hover {
            background: #4CAF50;
            color: white;
        }
        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            margin-top: 20px;
        }
        .stats h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }
        .coordinate-label {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: calc(var(--cell-size, 100px) * 0.08);
            color: #666;
            background: rgba(255,255,255,0.8);
            padding: 1px 3px;
            border-radius: 2px;
            pointer-events: none;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .drag-instructions {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #1976d2;
        }
        .swap-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #9c27b0;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Grid size indicator */
        .grid-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        /* Scroll hint for large grids */
        .scroll-hint {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 12px;
            display: none;
            text-align: center;
        }

        .scroll-hint.show {
            display: block;
        }

        /* Navigation controls */
        .navigation-controls {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        /* Dynamic responsive breakpoints */
        @media (max-width: 1400px) {
            :root {
                --cell-size: 90px;
                --grid-gap: 6px;
            }
        }

        @media (max-width: 1200px) {
            :root {
                --cell-size: 80px;
                --grid-gap: 5px;
            }
        }

        @media (max-width: 1000px) {
            :root {
                --cell-size: 70px;
                --grid-gap: 4px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --cell-size: 60px;
                --grid-gap: 4px;
            }
            
            .dome-title {
                font-size: 24px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .grid-controls {
                flex-direction: column;
                gap: 10px;
            }
        }

        @media (max-width: 600px) {
            :root {
                --cell-size: 50px;
                --grid-gap: 3px;
            }
            
            .dome-title {
                font-size: 20px;
            }
            
            .controls button {
                padding: 8px 16px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --cell-size: 45px;
                --grid-gap: 2px;
            }
            
            body {
                padding: 10px;
            }
            
            .dome-title {
                font-size: 18px;
            }
        }

        /* Large grid optimizations */
        @media (min-width: 1600px) {
            :root {
                --cell-size: 110px;
                --grid-gap: 10px;
            }
        }

        /* Ultra-wide screen support */
        @media (min-width: 2000px) {
            :root {
                --cell-size: 130px;
                --grid-gap: 12px;
            }
        }

        /* Prevent text selection during drag */
        .tree-item * {
            pointer-events: none;
        }
        
        .tree-item .tree-actions {
            pointer-events: auto;
        }
        
        .tree-item .tree-actions button {
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Swap Indicator -->
        <div id="swapIndicator" class="swap-indicator">
            🔄 Swapping trees...
        </div>

        <!-- Header -->
        <div class="header">
            <div class="dome-info">
                <div class="dome-image"></div>
                <h1 class="dome-title">{{ dome.name }}</h1>
            </div>
            <p>Internal Grid: {{ rows }}×{{ cols }} | Total Trees: <span id="treeCount">{{ trees|length }}</span></p>
        </div>
        
        <!-- Grid Info -->
        <div class="grid-info">
            <strong>Current Grid:</strong> {{ rows }}×{{ cols }} 
            ({{ rows * cols }} total cells)
        </div>
        
        <!-- Scroll Hint -->
        <div class="scroll-hint" id="scrollHint">
            💡 <strong>Tip:</strong> Use horizontal scroll or navigation buttons to view large grids. Use keyboard arrows for quick navigation.
        </div>
        
        <!-- Navigation Controls -->
        <div class="navigation-controls" id="navigationControls" style="display: none;">
            <button class="nav-btn" onclick="scrollToPosition('start')">⏮️ Start</button>
            <button class="nav-btn" onclick="scrollToPosition('left')">⬅️ Left</button>
            <button class="nav-btn" onclick="centerGrid()">🎯 Center</button>
            <button class="nav-btn" onclick="scrollToPosition('right')">➡️ Right</button>
            <button class="nav-btn" onclick="scrollToPosition('end')">⏭️ End</button>
            <button class="nav-btn" onclick="fitToScreen()">📱 Fit Screen</button>
        </div>
        
        <!-- Drag Instructions -->
        <div class="drag-instructions">
            💡 <strong>Tip:</strong> Drag trees to empty spaces to move them, or drop on another tree to swap positions. Click on a tree to view details.
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <button class="btn-secondary" onclick="goBack()">← Back to Main</button>
            <button class="btn-info" onclick="openDomeInfo()">ℹ️ Dome Info</button>
            <button class="btn-primary" onclick="addRandomTree()">🌱 Add Random Tree</button>
            <button class="btn-secondary" onclick="refreshGrid()">🔄 Refresh Grid</button>
            <button class="btn-warning" onclick="clearAllTrees()">🗑️ Clear All Trees</button>
        </div>
        
        <!-- Grid Size Controls -->
        <div class="grid-controls">
            <label>Grid Size:</label>
            <label>Rows: <input type="number" id="gridRows" min="1" max="100" value="{{ rows }}"></label>
            <label>Cols: <input type="number" id="gridCols" min="1" max="100" value="{{ cols }}"></label>
            <button class="btn-primary" onclick="updateGridSize()">Update Size</button>
            <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Maximum: 100×100 grid</p>
        </div>
        
        <!-- Tree Grid Container -->
        <div class="grid-container" id="gridContainer">
            <div class="tree-grid" id="treeGrid">
                <div class="loading">Loading grid...</div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <h3>Grid Statistics</h3>
            <p>Total Trees: <span id="totalTrees">{{ trees|length }}</span></p>
            <p>Grid Size: <span id="currentGridSize">{{ rows }}×{{ cols }}</span></p>
            <p>Available Positions: <span id="availablePositions">{{ (rows * cols) - trees|length }}</span></p>
            <p>Occupancy Rate: <span id="occupancyRate">{{ "%.1f"|format((trees|length / (rows * cols) * 100) if (rows * cols) > 0 else 0) }}%</span></p>
        </div>
    </div>

    <script>
        const domeId = {{ dome.id }};
        let currentRows = {{ rows }};
        let currentCols = {{ cols }};
        let trees = {{ trees|tojson }};
        let draggedTree = null;

        // Initialize grid on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Grid page loaded for dome:', domeId);
            updateGridDisplay();
            addKeyboardNavigation();
            renderGrid();
        });

        // Update grid display and show navigation for large grids
        function updateGridDisplay() {
            const totalCells = currentRows * currentCols;
            const scrollHint = document.getElementById('scrollHint');
            const navigationControls = document.getElementById('navigationControls');
            
            // Show navigation for grids larger than 15x15
            if (totalCells > 225 || currentCols > 15) {
                scrollHint.classList.add('show');
                navigationControls.style.display = 'flex';
            } else {
                scrollHint.classList.remove('show');
                navigationControls.style.display = 'none';
            }
            
            // Auto-adjust cell size based on grid size
            adjustCellSize();
            
            // Start from left position instead of center
            setTimeout(scrollToStart, 100);
        }

        // Scroll to start (left) position
        function scrollToStart() {
            const container = document.getElementById('gridContainer');
            if (container) {
                container.scrollLeft = 0;
                container.scrollTop = 0;
            }
        }

        // Adjust cell size based on grid dimensions
        function adjustCellSize() {
            let cellSize = 100; // Default size
            
            if (currentCols > 80) {
                cellSize = 30;
            } else if (currentCols > 60) {
                cellSize = 35;
            } else if (currentCols > 50) {
                cellSize = 40;
            } else if (currentCols > 40) {
                cellSize = 50;
            } else if (currentCols > 30) {
                cellSize = 60;
            } else if (currentCols > 20) {
                cellSize = 70;
            } else if (currentCols > 15) {
                cellSize = 80;
            } else if (currentCols > 10) {
                cellSize = 90;
            }
            
            document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
        }

        // Center the grid in the viewport
        function centerGrid() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('treeGrid');
            
            if (container && grid) {
                const containerWidth = container.clientWidth;
                const gridWidth = grid.scrollWidth;
                const containerHeight = container.clientHeight;
                const gridHeight = grid.scrollHeight;
                
                const scrollLeft = Math.max(0, (gridWidth - containerWidth) / 2);
                const scrollTop = Math.max(0, (gridHeight - containerHeight) / 2);
                
                container.scrollTo({
                    left: scrollLeft,
                    top: scrollTop,
                    behavior: 'smooth'
                });
            }
        }

        // Fit grid to screen by adjusting cell size
        function fitToScreen() {
            const container = document.getElementById('gridContainer');
            const availableWidth = window.innerWidth - 100; // Account for padding
            const availableHeight = window.innerHeight - 300; // Account for header and controls
            
            const cellSizeByWidth = Math.max(25, Math.floor(availableWidth / currentCols) - 10);
            const cellSizeByHeight = Math.max(25, Math.floor(availableHeight / currentRows) - 10);
            const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight);
            
            document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
            
            setTimeout(centerGrid, 100);
        }

        // Scroll to specific positions
        function scrollToPosition(position) {
            const container = document.getElementById('gridContainer');
            if (!container) return;
            
            const scrollAmount = 200;
            const maxScroll = container.scrollWidth - container.clientWidth;
            
            switch(position) {
                case 'start':
                    container.scrollTo({ left: 0, behavior: 'smooth' });
                    break;
                case 'left':
                    container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    break;
                case 'right':
                    container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    break;
                case 'end':
                    container.scrollTo({ left: maxScroll, behavior: 'smooth' });
                    break;
            }
        }

        // Add keyboard navigation for large grids
        function addKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const container = document.getElementById('gridContainer');
                if (!container) return;
                
                const scrollAmount = 100;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        container.scrollBy({ top: -scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        container.scrollBy({ top: scrollAmount, behavior: 'smooth' });
                        break;
                    case 'Home':
                        e.preventDefault();
                        scrollToPosition('start');
                        break;
                    case 'End':
                        e.preventDefault();
                        scrollToPosition('end');
                        break;
                    case ' ': // Spacebar
                        e.preventDefault();
                        centerGrid();
                        break;
                }
            });
        }

        // Load trees from server
        async function loadTreesFromServer() {
            try {
                console.log('Loading trees from server...');
                
                const response = await fetch(`/api/trees/${domeId}`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Trees loaded successfully:', data.trees?.length || 0, 'trees');
                    
                    trees = data.trees || [];
                    renderGrid();
                } else {
                    console.error('Failed to load trees from server, status:', response.status);
                    renderGrid();
                }
            } catch (error) {
                console.error('Error loading trees:', error);
                renderGrid();
            }
        }

        function renderGrid() {
            console.log('Rendering grid with', trees.length, 'trees');
            
            const grid = document.getElementById('treeGrid');
            grid.style.gridTemplateColumns = `repeat(${currentCols}, 1fr)`;
            grid.innerHTML = '';

            // Create grid cells
            for (let row = 0; row < currentRows; row++) {
                for (let col = 0; col < currentCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Add coordinate label
                    const coordLabel = document.createElement('div');
                    coordLabel.className = 'coordinate-label';
                    coordLabel.textContent = `${row},${col}`;
                    cell.appendChild(coordLabel);
                    
                    // Check if there's a tree at this position
                    const tree = trees.find(t => t.row === row && t.col === col);
                    
                    if (tree) {
                        cell.classList.add('occupied');
                        cell.innerHTML += createTreeElement(tree);
                    } else {
                        const addBtn = document.createElement('button');
                        addBtn.className = 'add-tree-btn';
                        addBtn.textContent = '+';
                        addBtn.onclick = () => addTreeAtPosition(row, col);
                        cell.appendChild(addBtn);
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Add drag and drop event listeners to all cells after rendering
            addDragDropListeners();
            updateStats();
        }

        // Add drag and drop event listeners to grid cells
        function addDragDropListeners() {
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                // Add drop event listeners
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('dragleave', handleDragLeave);
                cell.addEventListener('drop', handleDrop);
            });
            
            // Add drag event listeners to tree items
            const treeItems = document.querySelectorAll('.tree-item');
            treeItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        // Drag and drop event handlers
        function handleDragStart(event) {
            draggedTree = {
                id: parseInt(event.target.dataset.treeId),
                row: parseInt(event.target.dataset.treeRow),
                col: parseInt(event.target.dataset.treeCol)
            };
            
            console.log('Drag started:', draggedTree);
            
            // Add visual feedback
            event.target.classList.add('dragging');
            
            // Set drag effect
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.outerHTML);
        }

        function handleDragEnd(event) {
            console.log('Drag ended');
            
            // Reset visual feedback
            event.target.classList.remove('dragging');
            
            // Clear drag data
            draggedTree = null;
            
            // Remove all drag-over classes
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('drag-over', 'swap-target');
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            if (!draggedTree) return;
            
            const cell = event.target.closest('.grid-cell');
            if (!cell) return;
            
            // Remove previous drag-over classes
            document.querySelectorAll('.grid-cell').forEach(c => {
                c.classList.remove('drag-over', 'swap-target');
            });
            
            // Check if cell has a tree (for swapping)
            const hasTree = cell.querySelector('.tree-item');
            if (hasTree) {
                cell.classList.add('swap-target');
            } else {
                cell.classList.add('drag-over');
            }
        }

        function handleDragLeave(event) {
            const cell = event.target.closest('.grid-cell');
            if (cell) {
                cell.classList.remove('drag-over', 'swap-target');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            
            const cell = event.target.closest('.grid-cell');
            if (!cell || !draggedTree) return;
            
            // Remove visual feedback
            cell.classList.remove('drag-over', 'swap-target');
            
            // Get target position
            const targetRow = parseInt(cell.dataset.row);
            const targetCol = parseInt(cell.dataset.col);
            
            console.log(`Dropping tree ${draggedTree.id} at position (${targetRow}, ${targetCol})`);
            
            // Don't move if dropping on same position
            if (draggedTree.row === targetRow && draggedTree.col === targetCol) {
                console.log('Dropped on same position, no action needed');
                return;
            }
            
            // Move the tree
            moveTreeToPosition(draggedTree.id, targetRow, targetCol);
        }

        // Move tree to new position
        async function moveTreeToPosition(treeId, newRow, newCol) {
            try {
                console.log(`Moving tree ${treeId} to position (${newRow}, ${newCol})`);
                
                // Show swap indicator if there's a tree at target position
                const targetTree = trees.find(t => t.row === newRow && t.col === newCol);
                if (targetTree) {
                    showSwapIndicator();
                }
                
                const response = await fetch(`/move_tree/${treeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        row: newRow,
                        col: newCol
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Tree moved successfully');
                    // Reload trees from server to get updated positions
                    await loadTreesFromServer();
                } else {
                    console.error('Failed to move tree:', result.error);
                    alert(`Failed to move tree: ${result.error}`);
                }
                
            } catch (error) {
                console.error('Error moving tree:', error);
                alert('Error moving tree. Please try again.');
            } finally {
                hideSwapIndicator();
            }
        }

        // Show/hide swap indicator
        function showSwapIndicator() {
            const indicator = document.getElementById('swapIndicator');
            if (indicator) {
                indicator.style.display = 'block';
            }
        }

        function hideSwapIndicator() {
            const indicator = document.getElementById('swapIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // Create tree element HTML
        function createTreeElement(tree) {
            console.log('Creating tree element for:', tree.name, 'with image:', tree.image_url);
            
            // Use custom image if available, otherwise use default
            let imageHtml;
            if (tree.image_url) {
                imageHtml = `<div class="tree-image" style="background-image: url('${tree.image_url}?t=${Date.now()}');"></div>`;
            } else {
                imageHtml = `<div class="tree-placeholder">🌱</div>`;
            }
            
            return `
                <div class="tree-item" 
                     draggable="true" 
                     data-tree-id="${tree.id}"
                     data-tree-row="${tree.row}"
                     data-tree-col="${tree.col}"
                     onclick="openTree(${tree.id})">
                    ${imageHtml}
                    <div class="tree-name">${tree.name}</div>
                    <div class="tree-actions">
                        <button class="action-btn edit-btn" onclick="event.stopPropagation(); editTree(${tree.id})" title="Edit">✏️</button>
                        <button class="action-btn delete-btn" onclick="event.stopPropagation(); deleteTree(${tree.id})" title="Delete">🗑️</button>
                    </div>
                </div>
            `;
        }

        // Tree management functions
        function openTree(treeId) {
            window.location.href = `/tree_info/${treeId}`;
        }

        async function editTree(treeId) {
            const tree = trees.find(t => t.id === treeId);
            if (!tree) return;
            
            const newName = prompt('Enter new tree name:', tree.name);
            if (!newName || newName === tree.name) return;
            
            try {
                const response = await fetch(`/update_tree/${treeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: newName
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Tree updated successfully');
                    await loadTreesFromServer();
                } else {
                    alert('Failed to update tree');
                }
            } catch (error) {
                console.error('Error updating tree:', error);
                alert('Error updating tree');
            }
        }

        async function deleteTree(treeId) {
            if (!confirm('Are you sure you want to delete this tree?')) return;
            
            try {
                const response = await fetch(`/delete_tree/${treeId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Tree deleted successfully');
                    await loadTreesFromServer();
                } else {
                    alert('Failed to delete tree');
                }
            } catch (error) {
                console.error('Error deleting tree:', error);
                alert('Error deleting tree');
            }
        }

        async function addTreeAtPosition(row, col) {
            // Check if position is occupied
            const existingTree = trees.find(tree => tree.row === row && tree.col === col);
            if (existingTree) {
                return; // Position occupied
            }
            
            const treeName = prompt('Enter tree name:', 'New Tree');
            if (!treeName) return;
            
            try {
                const response = await fetch('/add_tree', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: treeName,
                        row: row,
                        col: col,
                        dome_id: domeId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('Tree added successfully');
                    await loadTreesFromServer();
                } else {
                    alert(`Failed to add tree: ${result.error}`);
                }
            } catch (error) {
                console.error('Error adding tree:', error);
                alert('Error adding tree');
            }
        }

        // Utility functions
        function updateStats() {
            const totalTrees = trees.length;
            const totalCells = currentRows * currentCols;
            const availablePositions = totalCells - totalTrees;
            const occupancyRate = totalCells > 0 ? (totalTrees / totalCells * 100).toFixed(1) : 0;
            
            document.getElementById('totalTrees').textContent = totalTrees;
            document.getElementById('treeCount').textContent = totalTrees;
            document.getElementById('currentGridSize').textContent = `${currentRows}×${currentCols}`;
            document.getElementById('availablePositions').textContent = availablePositions;
            document.getElementById('occupancyRate').textContent = occupancyRate + '%';
        }

        function refreshGrid() {
            console.log('Refreshing grid...');
            loadTreesFromServer();
        }

        function goBack() {
            window.location.href = '/';
        }

        function openDomeInfo() {
            window.location.href = `/dome_info/${domeId}`;
        }

        async function addRandomTree() {
            // Find available positions
            const availablePositions = [];
            for (let row = 0; row < currentRows; row++) {
                for (let col = 0; col < currentCols; col++) {
                    const existingTree = trees.find(t => t.row === row && t.col === col);
                    if (!existingTree) {
                        availablePositions.push({ row, col });
                    }
                }
            }
            
            if (availablePositions.length === 0) {
                alert('No available positions for new trees!');
                return;
            }
            
            // Pick random position
            const randomPos = availablePositions[Math.floor(Math.random() * availablePositions.length)];
            
            // Generate random tree name
            const treeNames = ['Cannabis', 'Green Leaf', 'Bud Master', 'Herb King', 'Plant Pro', 'Grow Star'];
            const randomName = treeNames[Math.floor(Math.random() * treeNames.length)] + ' ' + Math.floor(Math.random() * 1000);
            
            await addTreeAtPosition(randomPos.row, randomPos.col);
        }

        async function clearAllTrees() {
            if (!confirm('Are you sure you want to delete ALL trees? This cannot be undone!')) return;
            
            try {
                for (const tree of trees) {
                    await fetch(`/delete_tree/${tree.id}`, { method: 'DELETE' });
                }
                
                console.log('All trees cleared');
                await loadTreesFromServer();
            } catch (error) {
                console.error('Error clearing trees:', error);
                alert('Error clearing trees');
            }
        }

        async function updateGridSize() {
            const newRows = parseInt(document.getElementById('gridRows').value);
            const newCols = parseInt(document.getElementById('gridCols').value);
            
            if (newRows < 1 || newCols < 1 || newRows > 100 || newCols > 100) {
                alert('Grid size must be between 1x1 and 100x100');
                return;
            }
            
            try {
                const response = await fetch(`/update_dome_grid/${domeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rows: newRows,
                        cols: newCols
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRows = newRows;
                    currentCols = newCols;
                    updateGridDisplay();
                    renderGrid();
                    console.log('Grid size updated successfully');
                } else {
                    alert(`Failed to update grid size: ${result.error}`);
                }
            } catch (error) {
                console.error('Error updating grid size:', error);
                alert('Error updating grid size');
            }
        }

        // Initialize the page
        console.log('Grid JavaScript loaded successfully');
    </script>
</body>
</html>