<!DOCTYPE html>
<html>
<head>
    <title>{{ dome.name }} - Tree Grid</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f0f0f0;
            overflow-x: auto;
        }
        .container {
            max-width: none;
            margin: 0 auto;
            min-width: 320px;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .dome-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .dome-image {
            width: 80px;
            height: 80px;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 3px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
            background-color: #2e8b57;
            background-repeat: no-repeat;
        }
        .dome-image:hover {
            transform: scale(1.05);
        }
        .dome-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .dome-image-container {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid #4CAF50;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    position: relative;
    cursor: pointer;
    transition: transform 0.3s ease;
    overflow: hidden;
}

.dome-image-container:hover {
    transform: scale(1.05);
}

.dome-image-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    display: block;
}

.dome-image-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    z-index: 1;
}

/* ‚úÖ NEW: Tree image display for base64 data */
.tree-image-container {
    width: calc(var(--cell-size, 100px) * 0.6);
    height: calc(var(--cell-size, 100px) * 0.6);
    border-radius: 50%;
    border: 2px solid #4CAF50;
    margin-bottom: 5px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
    pointer-events: none;
}

.tree-image-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    display: block;
}

.tree-image-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    z-index: 1;
}
        .dome-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.2;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .dome-placeholder:hover {
            transform: scale(1.05);
        }
        .dome-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .dome-title {
            font-size: 28px;
            color: #2e7d32;
            margin: 0;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .grid-controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        .grid-controls label {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .grid-controls input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        
        .grid-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: visible;
            padding: 10px 0;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            scroll-behavior: smooth;
        }
        
        .tree-grid {
            display: grid;
            gap: var(--grid-gap, 8px);
            padding: 20px;
            margin: 0 auto;
            min-width: fit-content;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            border: 2px dashed #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--cell-size, 100px);
            height: var(--cell-size, 100px);
            position: relative;
            transition: all 0.3s ease;
            background: #fafafa;
            cursor: pointer;
        }
        .grid-cell:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
            transform: scale(1.05);
        }
        .grid-cell.occupied {
            border: 2px solid #4CAF50;
            background: #e8f5e8;
        }
        .grid-cell.drag-over {
            border: 2px solid #ff9800 !important;
            background: #fff3e0 !important;
            transform: scale(1.05);
        }
        .grid-cell.swap-target {
            border: 2px solid #9c27b0 !important;
            background: #f3e5f5 !important;
            transform: scale(1.05);
        }
        .tree-item {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            box-sizing: border-box;
            position: relative;
            border-radius: 6px;
            cursor: grab;
            pointer-events: auto;
        }
        .tree-item:active {
            cursor: grabbing;
        }
        .tree-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        .tree-image {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 2px solid #4CAF50;
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: none;
            position: relative;
            background-color: #2e8b57;
            background-repeat: no-repeat;
        }
        .tree-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .tree-placeholder {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: calc(var(--cell-size, 100px) * 0.12);
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.1;
            pointer-events: none;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        .tree-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .tree-name {
            font-size: calc(var(--cell-size, 100px) * 0.1);
            font-weight: bold;
            color: #2e7d32;
            text-align: center;
            word-wrap: break-word;
            max-width: 100%;
            line-height: 1.2;
            pointer-events: none;
        }
        .tree-actions {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            flex-direction: column;
            gap: 1px;
            pointer-events: auto;
        }
        .tree-item:hover .tree-actions {
            display: flex;
        }
        .action-btn {
            width: calc(var(--cell-size, 100px) * 0.2);
            height: calc(var(--cell-size, 100px) * 0.2);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: calc(var(--cell-size, 100px) * 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        .edit-btn {
            background: #2196F3;
            color: white;
        }
        .delete-btn {
            background: #f44336;
            color: white;
        }
        .add-tree-btn {
            background: none;
            border: 2px dashed #4CAF50;
            color: #4CAF50;
            font-size: calc(var(--cell-size, 100px) * 0.2);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: 100%;
            height: 100%;
        }
        .add-tree-btn:hover {
            background: #4CAF50;
            color: white;
        }
        .add-tree-btn:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
            border-color: #ccc;
        }
        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            margin-top: 20px;
        }
        .stats h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }
        .coordinate-label {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: calc(var(--cell-size, 100px) * 0.08);
            color: #666;
            background: rgba(255,255,255,0.8);
            padding: 1px 3px;
            border-radius: 2px;
            pointer-events: none;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .drag-instructions {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #1976d2;
        }
        .swap-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #9c27b0;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .grid-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .scroll-hint {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 12px;
            display: none;
            text-align: center;
        }

        .scroll-hint.show {
            display: block;
        }

        .navigation-controls {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            display: none;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .status-success {
            background: #28a745;
        }

        .status-error {
            background: #dc3545;
        }

        .status-info {
            background: #17a2b8;
        }

        /* Debug panel */
        .debug-panel {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 12px;
        }

        .debug-panel h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .debug-panel pre {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 5px 0;
            max-height: 200px;
        }

        .debug-toggle {
            background: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin: 2px;
        }

        .debug-toggle:hover {
            background: #5a6268;
        }

        /* Responsive design */
        @media (max-width: 1400px) {
            :root {
                --cell-size: 90px;
                --grid-gap: 6px;
            }
        }

        @media (max-width: 1200px) {
            :root {
                --cell-size: 80px;
                --grid-gap: 5px;
            }
        }

        @media (max-width: 1000px) {
            :root {
                --cell-size: 70px;
                --grid-gap: 4px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --cell-size: 60px;
                --grid-gap: 4px;
            }
            
            .dome-title {
                font-size: 24px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .grid-controls {
                flex-direction: column;
                gap: 10px;
            }
        }

        @media (max-width: 600px) {
            :root {
                --cell-size: 50px;
                --grid-gap: 3px;
            }
            
            .dome-title {
                font-size: 20px;
            }
            
            .controls button {
                padding: 8px 16px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --cell-size: 45px;
                --grid-gap: 2px;
            }
            
            body {
                padding: 10px;
            }
            
            .dome-title {
                font-size: 18px;
            }
        }

        @media (min-width: 1600px) {
            :root {
                --cell-size: 110px;
                --grid-gap: 10px;
            }
        }

        @media (min-width: 2000px) {
            :root {
                --cell-size: 130px;
                --grid-gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Status Indicator -->
        <div id="statusIndicator" class="status-indicator"></div>

        <!-- Swap Indicator -->
        <div id="swapIndicator" class="swap-indicator">
            üîÑ Swapping trees...
        </div>

        <!-- Debug Panel -->
        <div class="debug-panel" id="debugPanel" style="display: none;">
            <h4>üêõ Debug Information <button class="debug-toggle" onclick="toggleDebug()">Hide</button></h4>
            <div><strong>Dome ID:</strong> {{ dome.id }}</div>
            <div><strong>Grid Size:</strong> {{ rows }}√ó{{ cols }}</div>
            <div><strong>Trees from Backend:</strong> {{ trees|length }}</div>
            <div><strong>Frontend Trees Count:</strong> <span id="frontendTreesCount">Loading...</span></div>
            <div><strong>Empty Positions:</strong> <span id="emptyPositionsCount">Loading...</span></div>
            <div><strong>Trees Data:</strong></div>
            <pre id="treesData">{{ trees_data|tojson|safe }}</pre>
            <button class="debug-toggle" onclick="refreshDebugInfo()">üîÑ Refresh Debug</button>
            <button class="debug-toggle" onclick="forceRefreshTrees()">üîÑ Force Refresh Trees</button>
            <button class="debug-toggle" onclick="testNavigation()">üß™ Test Navigation</button>
        </div>

        <!-- Header -->
        <div class="header">
            <div class="dome-info">
                {% if dome.image_url and dome.image_url.startswith('data:image/') %}
    <div class="dome-image-container" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}">
        <img src="{{ dome.image_url }}" alt="Dome Image" class="dome-image-img">
    </div>
{% elif dome.image_url and not dome.image_url.startswith('data:image/') %}
    <div class="dome-image" style="background-image: url('{{ dome.image_url }}?t={{ timestamp }}');" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}"></div>
{% else %}
    <div class="dome-placeholder" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}">
        üè†
    </div>
{% endif %}
                <h1 class="dome-title">{{ dome.name }}</h1>
            </div>
            <p>Internal Grid: {{ rows }}√ó{{ cols }} | Total Trees: <span id="treeCount">{{ trees|length }}</span></p>
        </div>
        
        <!-- Grid Info -->
        <div class="grid-info">
            <strong>Current Grid:</strong> {{ rows }}√ó{{ cols }} 
            ({{ rows * cols }} total cells) | 
            <strong>Backend Trees:</strong> {{ trees|length }} | 
            <strong>Frontend Trees:</strong> <span id="frontendTreesDisplay">Loading...</span>
            <button class="debug-toggle" onclick="showDebug()" style="margin-left: 10px;">üêõ Debug</button>
        </div>
        
        <!-- Scroll Hint -->
        <div class="scroll-hint" id="scrollHint">
            üí° <strong>Tip:</strong> Use horizontal scroll or navigation buttons to view large grids. Use keyboard arrows for quick navigation.
        </div>
        
        <!-- Navigation Controls -->
        <div class="navigation-controls" id="navigationControls" style="display: none;">
            <button class="nav-btn" onclick="scrollToPosition('start')">‚èÆÔ∏è Start</button>
            <button class="nav-btn" onclick="scrollToPosition('left')">‚¨ÖÔ∏è Left</button>
            <button class="nav-btn" onclick="centerGrid()">üéØ Center</button>
            <button class="nav-btn" onclick="scrollToPosition('right')">‚û°Ô∏è Right</button>
            <button class="nav-btn" onclick="scrollToPosition('end')">‚è≠Ô∏è End</button>
            <button class="nav-btn" onclick="fitToScreen()">üì± Fit Screen</button>
        </div>
        
        <!-- Drag Instructions -->
        <div class="drag-instructions">
            üí° <strong>Tip:</strong> Drag trees to empty spaces to move them, or drop on another tree to swap positions. Click on a tree to view details.
        </div>
        
        <!-- Controls -->
        <div class="controls">
    <button class="btn-secondary" onclick="goBack()">‚Üê Back to Dome Info</button>
    <button class="btn-info" onclick="openDomeInfo()">‚ÑπÔ∏è Dome Info</button>
    <button class="btn-warning" onclick="goToMainIndex()">üöú Back to Farm Domes</button>
            <button class="btn-primary" onclick="addRandomTree()">üå± Add Random Tree</button>
            <button class="btn-secondary" onclick="refreshGrid()">üîÑ Refresh Grid</button>
            <button class="btn-danger" onclick="forceRefreshTrees()">üîÑ Force Refresh Trees</button>
            <button class="btn-warning" onclick="clearAllTrees()">üóëÔ∏è Clear All Trees</button>
        </div>
        
        <!-- Grid Size Controls -->
        <div class="grid-controls">
            <label>Grid Size:</label>
            <label>Rows: <input type="number" id="gridRows" min="1" max="100" value="{{ rows }}"></label>
            <label>Cols: <input type="number" id="gridCols" min="1" max="100" value="{{ cols }}"></label>
            <button class="btn-primary" onclick="updateGridSize()">Update Size</button>
            <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Maximum: 100√ó100 grid</p>
        </div>
        
        <!-- Tree Grid Container -->
        <div class="grid-container" id="gridContainer">
            <div class="tree-grid" id="treeGrid">
                <div class="loading">Loading grid...</div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <h3>Grid Statistics</h3>
            <p>Total Trees: <span id="totalTrees">{{ trees|length }}</span></p>
            <p>Grid Size: <span id="currentGridSize">{{ rows }}√ó{{ cols }}</span></p>
            <p>Available Positions: <span id="availablePositions">{{ (rows * cols) - trees|length }}</span></p>
            <p>Occupancy Rate: <span id="occupancyRate">{{ "%.1f"|format((trees|length / (rows * cols) * 100) if (rows * cols) > 0 else 0) }}%</span></p>
        </div>
    </div>

    <script>
        // ‚úÖ FIXED: Global variables with proper initialization
        const domeId = {{ dome.id }};
        let currentRows = {{ rows }};
        let currentCols = {{ cols }};
        let trees = {{ trees_data|tojson|safe }}
        let draggedTree = null;
        let isAddingTree = false;
        let autoRefreshInterval = null;

        // ‚úÖ FIXED: Navigation functions - removed goToFarmView
function goBack() {
    console.log('Going back to dome_info');
    window.location.href = `/dome_info/${domeId}`;
}

        function openDomeInfo() {
            window.location.href = `/dome_info/${domeId}`;
        }

        function openTreeInfo(treeId) {
            window.location.href = `/tree_info/${treeId}`;
        }

function goToMainIndex() {
    console.log('Going back to farm dome view');
    window.location.href = `/farm/{{ dome.farm_id }}/domes`;
}

        function goToFarms() {
            console.log('Going to farms management');
            window.location.href = '/farms';
        }

        // ‚úÖ FIXED: Status indicator functions
        function showStatus(message, type = 'info', duration = 3000) {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.className = `status-indicator status-${type}`;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, duration);
        }

        // ‚úÖ FIXED: Debug functions
        function showDebug() {
            document.getElementById('debugPanel').style.display = 'block';
            refreshDebugInfo();
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

function refreshDebugInfo() {


// ‚úÖ FIXED: DOMContentLoaded should be at the top level, not inside a function
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== GRID PAGE LOADED ===');
    console.log('Dome ID:', domeId);
    console.log('Grid Size:', currentRows, 'x', currentCols);
    console.log('Initial trees from backend:', trees);
    console.log('Trees count:', trees.length);
    console.log('========================');
    
    // ‚úÖ Check dome image on load
    const domeImage = document.querySelector('.dome-image-img');
    if (domeImage) {
        domeImage.onerror = function() {
            console.error('‚ùå Failed to load dome image');
            // Replace with placeholder
            const placeholder = document.createElement('div');
            placeholder.className = 'dome-placeholder';
            placeholder.textContent = 'üè†';
            placeholder.onclick = openDomeInfo;
            placeholder.title = 'Click to edit dome - {{ dome.name }}';
            
            const container = this.closest('.dome-image-container');
            if (container && container.parentNode) {
                container.parentNode.replaceChild(placeholder, container);
            }
        };
        
        domeImage.onload = function() {
            console.log('‚úÖ Dome image loaded successfully');
        };
    }
    
    // Initial debug info update
    refreshDebugInfo();
});
    
    // Update trees data display
    document.getElementById('treesData').textContent = JSON.stringify(trees, null, 2);
    
    console.log('=== DEBUG INFO ===');
    console.log('Dome ID:', domeId);
    console.log('Grid Size:', currentRows, 'x', currentCols);
    console.log('Trees Array:', trees);
    console.log('Trees Count:', trees.length);
    console.log('Empty Positions:', getEmptyPositions().length);
    console.log('==================');


// ‚úÖ FIXED: Function should be outside the DOMContentLoaded event
function testNavigation() {
    console.log('Testing navigation functions...');
    console.log('Dome ID:', domeId);
    console.log('Available navigation:');
    console.log('- goBack() -> /dome_info/' + domeId);
    console.log('- goToMainIndex() -> /');
    showStatus('Navigation test completed - check console', 'info');
}

        // ‚úÖ ENHANCED: Force refresh trees from server
        function forceRefreshTrees() {
            showStatus('Force refreshing trees from server...', 'info');
            
            fetch(`/api/dome/${domeId}/trees`)
            .then(response => {
                console.log('API Response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('API Response data:', data);
                if (data.success) {
                    trees = data.trees || [];
                    showStatus(`Trees refreshed! Found ${trees.length} trees`, 'success');
                    renderGrid();
                    refreshDebugInfo();
                } else {
                    showStatus('Failed to refresh trees: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(error => {
                console.error('Error refreshing trees:', error);
                showStatus('Network error refreshing trees', 'error');
                
                // ‚úÖ FALLBACK: Try alternative API endpoint
                fetch(`/grid/${domeId}/data`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        trees = data.trees || [];
                        showStatus(`Trees refreshed via fallback! Found ${trees.length} trees`, 'success');
                        renderGrid();
                        refreshDebugInfo();
                    } else {
                        throw new Error(data.error || 'Fallback API failed');
                    }
                })
                .catch(fallbackError => {
                    console.error('Fallback API also failed:', fallbackError);
                    showStatus('All refresh attempts failed', 'error');
                });
            });
        }

        // ‚úÖ IMPROVED: Check if position is truly empty
function isPositionEmpty(row, col) {
            const found = trees.find(t => t.internal_row === row && t.internal_col === col);
            console.log(`Checking position ${row},${col}: ${found ? 'OCCUPIED' : 'EMPTY'}`);
            return !found;
        }

        // ‚úÖ ENHANCED: Get empty positions with validation
        function getEmptyPositions() {
            const empty = [];
            for (let row = 0; row < currentRows; row++) {
                for (let col = 0; col < currentCols; col++) {
                    if (isPositionEmpty(row, col)) {
                        empty.push({ row, col });
                    }
                }
            }
            console.log(`Found ${empty.length} empty positions out of ${currentRows * currentCols} total`);
            return empty;
        }

        // Initialize grid on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== GRID PAGE LOADED ===');
            console.log('Dome ID:', domeId);
            console.log('Grid Size:', currentRows, 'x', currentCols);
            console.log('Initial trees from backend:', trees);
            console.log('Trees count:', trees.length);
            console.log('========================');
            
            // ‚úÖ ENHANCED: Validate trees data
            if (!Array.isArray(trees)) {
                console.error('Trees is not an array:', trees);
                trees = [];
                showStatus('Warning: Trees data is invalid, using empty array', 'error');
            }
            
            // ‚úÖ ENHANCED: Check for data mismatch
            const expectedTrees = {{ trees|length }};
            if (trees.length !== expectedTrees) {
                console.warn(`Data mismatch! Backend: ${expectedTrees}, Frontend: ${trees.length}`);
                showStatus(`Data sync issue detected. Backend: ${expectedTrees}, Frontend: ${trees.length}`, 'error');
                
                // Force refresh trees data
                setTimeout(forceRefreshTrees, 1000);
            }
            
            // ‚úÖ ENHANCED: Validate tree data structure
            trees.forEach((tree, index) => {
                if (!tree.hasOwnProperty('internal_row') || !tree.hasOwnProperty('internal_col')) {
                    console.error(`Tree ${index} missing position data:`, tree);
                    showStatus(`Tree data structure error detected`, 'error');
                }
                if (tree.internal_row < 0 || tree.internal_row >= currentRows || 
                    tree.internal_col < 0 || tree.internal_col >= currentCols) {
                    console.error(`Tree ${index} has invalid position:`, tree);
                    showStatus(`Tree position out of bounds detected`, 'error');
                }
            });
            
            updateGridDisplay();
            addKeyboardNavigation();
            renderGrid();
            refreshDebugInfo();
            
            // ‚úÖ ENHANCED: Auto-refresh every 30 seconds to keep data in sync
            autoRefreshInterval = setInterval(() => {
                if (!isAddingTree) {
                    console.log('Auto-refreshing trees data...');
                    forceRefreshTrees();
                }
            }, 30000);
        });

        // Update grid display and show navigation for large grids
        function updateGridDisplay() {
            const totalCells = currentRows * currentCols;
            const scrollHint = document.getElementById('scrollHint');
            const navigationControls = document.getElementById('navigationControls');
            
            // Show navigation for grids larger than 15x15
            if (totalCells > 225 || currentCols > 15) {
                scrollHint.classList.add('show');
                navigationControls.style.display = 'flex';
            } else {
                scrollHint.classList.remove('show');
                navigationControls.style.display = 'none';
            }
            
            // Auto-adjust cell size based on grid size
            adjustCellSize();
            
            // Start from left position instead of center
            setTimeout(scrollToStart, 100);
        }

        // Scroll to start (left) position
        function scrollToStart() {
            const container = document.getElementById('gridContainer');
            if (container) {
                container.scrollLeft = 0;
                container.scrollTop = 0;
            }
        }

        // Adjust cell size based on grid dimensions
        function adjustCellSize() {
            let cellSize = 100; // Default size
            
            if (currentCols > 80) {
                cellSize = 30;
            } else if (currentCols > 60) {
                cellSize = 35;
            } else if (currentCols > 50) {
                cellSize = 40;
            } else if (currentCols > 40) {
                cellSize = 50;
            } else if (currentCols > 30) {
                cellSize = 60;
            } else if (currentCols > 20) {
                cellSize = 70;
            } else if (currentCols > 15) {
                cellSize = 80;
            } else if (currentCols > 10) {
                cellSize = 90;
            }
            
            document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
        }

        // Center the grid in the viewport
        function centerGrid() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('treeGrid');
            
            if (container && grid) {
                const containerWidth = container.clientWidth;
                const gridWidth = grid.scrollWidth;
                const containerHeight = container.clientHeight;
                const gridHeight = grid.scrollHeight;
                
                const scrollLeft = Math.max(0, (gridWidth - containerWidth) / 2);
                const scrollTop = Math.max(0, (gridHeight - containerHeight) / 2);
                
                container.scrollTo({
                    left: scrollLeft,
                    top: scrollTop,
                    behavior: 'smooth'
                });
            }
        }

        // Fit grid to screen by adjusting cell size
        function fitToScreen() {
            const container = document.getElementById('gridContainer');
            const availableWidth = window.innerWidth - 100;
            const availableHeight = window.innerHeight - 300;
            
            const cellSizeByWidth = Math.max(25, Math.floor(availableWidth / currentCols) - 10);
            const cellSizeByHeight = Math.max(25, Math.floor(availableHeight / currentRows) - 10);
            const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight);
            
            document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
            
            setTimeout(centerGrid, 100);
        }

        // Scroll to specific positions
        function scrollToPosition(position) {
            const container = document.getElementById('gridContainer');
            if (!container) return;
            
            const scrollAmount = 200;
            const maxScroll = container.scrollWidth - container.clientWidth;
            
            switch(position) {
                case 'start':
                    container.scrollTo({ left: 0, behavior: 'smooth' });
                    break;
                case 'left':
                    container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    break;
                case 'right':
                    container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    break;
                case 'end':
                    container.scrollTo({ left: maxScroll, behavior: 'smooth' });
                    break;
            }
        }

        // Add keyboard navigation for large grids
        function addKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const container = document.getElementById('gridContainer');
                if (!container) return;
                
                const scrollAmount = 100;
                const largeScrollAmount = 300;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        container.scrollBy({ top: -scrollAmount, behavior: 'smooth' });
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        container.scrollBy({ top: scrollAmount, behavior: 'smooth' });
                        break;
                    case 'Home':
                        e.preventDefault();
                        scrollToPosition('start');
                        break;
                    case 'End':
                        e.preventDefault();
                        scrollToPosition('end');
                        break;
                    case ' ':
                        e.preventDefault();
                        centerGrid();
                        break;
                    case 'PageUp':
                        e.preventDefault();
                        container.scrollBy({ top: -largeScrollAmount, behavior: 'smooth' });
                        break;
                    case 'PageDown':
                        e.preventDefault();
                        container.scrollBy({ top: largeScrollAmount, behavior: 'smooth' });
                        break;
                    case 'Escape':
                        e.preventDefault();
                        goBack();
                        break;
                    case 'F5':
                        e.preventDefault();
                        forceRefreshTrees();
                        break;
                }
            });
        }

        // ‚úÖ ENHANCED: Render the tree grid with better error handling
function renderGrid() {
            const grid = document.getElementById('treeGrid');
            if (!grid) {
                console.error('Grid element not found!');
                return;
            }
            
            console.log('Rendering grid with', trees.length, 'trees');
            
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${currentCols}, 1fr)`;
            
            let renderedTrees = 0;
            let renderedCells = 0;
            
            for (let row = 0; row < currentRows; row++) {
                for (let col = 0; col < currentCols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    renderedCells++;
                    
                    // Add coordinate label
                    const coordLabel = document.createElement('div');
                    coordLabel.className = 'coordinate-label';
                    coordLabel.textContent = `${row},${col}`;
                    cell.appendChild(coordLabel);
                    
                    // ‚úÖ IMPROVED: Check if there's a tree at this position with better logging
                    const tree = trees.find(t => t.internal_row === row && t.internal_col === col);
                    
                    if (tree) {
                        console.log(`Found tree at ${row},${col}:`, tree);
                        cell.classList.add('occupied');
                        const treeElement = createTreeElement(tree);
                        cell.appendChild(treeElement);
                        renderedTrees++;
                    } else {
                        // ‚úÖ IMPROVED: Add empty cell click handler with validation
                        const addBtn = document.createElement('button');
                        addBtn.className = 'add-tree-btn';
                        addBtn.innerHTML = '+';
                        addBtn.title = `Add tree at position ${row},${col}`;
                        addBtn.onclick = () => addTreeAtPosition(row, col);
                        cell.appendChild(addBtn);
                    }
                    
                    // Add drag and drop handlers
                    cell.addEventListener('dragover', allowDrop);
                    cell.addEventListener('drop', (e) => dropTree(e, row, col));
                    
                    grid.appendChild(cell);
                }
            }
            
            console.log(`Grid rendered: ${renderedCells} cells, ${renderedTrees} trees`);
            
            // ‚úÖ ENHANCED: Validate rendering
            if (renderedTrees !== trees.length) {
                console.error(`Rendering mismatch! Expected ${trees.length} trees, rendered ${renderedTrees}`);
                showStatus(`Rendering error: Expected ${trees.length} trees, rendered ${renderedTrees}`, 'error');
            }
            
            updateStats();
            refreshDebugInfo();
        }

        // Create tree element
function createTreeElement(tree) {
    const treeItem = document.createElement('div');
    treeItem.className = 'tree-item';
    treeItem.draggable = true;
    treeItem.dataset.treeId = tree.id;
    treeItem.addEventListener('dragstart', dragStart);
    treeItem.addEventListener('dragend', dragEnd);
    
    // ‚úÖ CHANGED: Replace onclick with addEventListener and add drag detection
    let isDragging = false;
    let dragStartTime = 0;
    
    treeItem.addEventListener('mousedown', () => {
        isDragging = false;
        dragStartTime = Date.now();
    });
    
    treeItem.addEventListener('dragstart', () => {
        isDragging = true;
    });
    
    treeItem.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // ‚úÖ Only navigate if not dragging and sufficient time has passed
        const timeSinceDragStart = Date.now() - dragStartTime;
        if (!isDragging && timeSinceDragStart < 200) {
            console.log('Opening tree info for tree:', tree.id);
            openTreeInfo(tree.id);
        }
    });
    
    // Tree image or placeholder
if (tree.image_url && tree.image_url.includes('data:image/')) {
    // ‚úÖ FIXED: Base64 image using img tag
    const treeImageContainer = document.createElement('div');
    treeImageContainer.className = 'tree-image-container';
    
const treeImage = document.createElement('img');
treeImage.src = tree.image_url;
treeImage.alt = 'Tree Image';
treeImage.className = 'tree-image-img';
treeImage.style.pointerEvents = 'none';

// ‚úÖ ADD THIS LINE:
handleImageError(treeImage, 'üå±');

treeImageContainer.appendChild(treeImage);
    
    treeImageContainer.appendChild(treeImage);
    treeItem.appendChild(treeImageContainer);
} else if (tree.image_url) {
    // ‚úÖ FALLBACK: Old file URL using background-image
    const treeImage = document.createElement('div');
    treeImage.className = 'tree-image';
    treeImage.style.backgroundImage = `url('${tree.image_url}?t=${Date.now()}')`;
    treeImage.style.pointerEvents = 'none';
    treeItem.appendChild(treeImage);
} else {
    // ‚úÖ NO IMAGE: Placeholder
    const treePlaceholder = document.createElement('div');
    treePlaceholder.className = 'tree-placeholder';
    treePlaceholder.textContent = 'üå±';
    treePlaceholder.style.pointerEvents = 'none';
    treeItem.appendChild(treePlaceholder);
}
    
    // Tree name
    const treeName = document.createElement('div');
    treeName.className = 'tree-name';
    treeName.textContent = tree.name || `Tree ${tree.id}`;
    treeName.style.pointerEvents = 'none'; // ‚úÖ ADDED: Prevent name from interfering with drag
    treeItem.appendChild(treeName);
    
    // Tree actions
    const actions = document.createElement('div');
    actions.className = 'tree-actions';
    actions.style.pointerEvents = 'auto'; // ‚úÖ ADDED: Ensure actions are clickable
    
    const editBtn = document.createElement('button');
    editBtn.className = 'action-btn edit-btn';
    editBtn.innerHTML = '‚úèÔ∏è';
    editBtn.title = 'Edit tree';
    editBtn.onclick = (e) => {
        e.preventDefault(); // ‚úÖ ADDED: Prevent default behavior
        e.stopPropagation();
        console.log('Editing tree:', tree.id);
        editTree(tree.id);
    };
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'action-btn delete-btn';
    deleteBtn.innerHTML = 'üóëÔ∏è';
    deleteBtn.title = 'Delete tree';
    deleteBtn.onclick = (e) => {
        e.preventDefault(); // ‚úÖ ADDED: Prevent default behavior
        e.stopPropagation();
        console.log('Deleting tree:', tree.id);
        deleteTree(tree.id);
    };
    
    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);
    treeItem.appendChild(actions);
    
    return treeItem;
}
function handleImageError(imgElement, fallbackContent = 'üå±') {
    imgElement.onerror = function() {
        console.warn('Failed to load image:', this.src);
        
        // Replace with placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'tree-placeholder';
        placeholder.textContent = fallbackContent;
        placeholder.style.pointerEvents = 'none';
        
        // Replace the image container with placeholder
        const container = this.closest('.tree-image-container');
        if (container && container.parentNode) {
            container.parentNode.replaceChild(placeholder, container);
        }
    };
    
    imgElement.onload = function() {
        console.log('‚úÖ Tree image loaded successfully');
    };
}
        // Drag and drop functions
function dragStart(e) {
    console.log('Drag started for tree:', e.target.dataset.treeId);
    draggedTree = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', e.target.dataset.treeId);
    
    // ‚úÖ ADDED: Prevent text selection during drag
    e.dataTransfer.setDragImage(e.target, 50, 50);
}
function dragEnd(e) {
    console.log('Drag ended');
    e.target.classList.remove('dragging');
    
    // ‚úÖ FIXED: Clear all drag effects from all cells
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('drag-over', 'swap-target');
    });
    
    // ‚úÖ FIXED: Reset dragged tree after a small delay to allow drop event
    setTimeout(() => {
        draggedTree = null;
    }, 100);
}

function allowDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // ‚úÖ FIXED: Only add drag-over effect if we're actually dragging a tree
    if (draggedTree) {
        e.currentTarget.classList.add('drag-over');
        
        // ‚úÖ ADDED: Show swap indicator if dropping on occupied cell
        const row = parseInt(e.currentTarget.dataset.row);
        const col = parseInt(e.currentTarget.dataset.col);
        const targetTree = trees.find(t => t.internal_row === row && t.internal_col === col);
        
        if (targetTree && targetTree.id != draggedTree.dataset.treeId) {
            e.currentTarget.classList.add('swap-target');
        }
    }
}

function dropTree(e, row, col) {
    e.preventDefault();
    e.stopPropagation();
    
    // ‚úÖ FIXED: Remove all drag effects
    e.currentTarget.classList.remove('drag-over', 'swap-target');
    
    if (!draggedTree) {
        console.log('No dragged tree found');
        return;
    }
    
    const treeId = parseInt(draggedTree.dataset.treeId);
    const draggedTreeData = trees.find(t => t.id === treeId);
    
    if (!draggedTreeData) {
        console.error('Dragged tree data not found');
        showStatus('Error: Tree data not found', 'error');
        return;
    }
    
    // ‚úÖ FIXED: Check if dropping on same position
    if (draggedTreeData.internal_row === row && draggedTreeData.internal_col === col) {
        console.log('Dropping on same position, ignoring');
        return;
    }
    
    console.log(`Dropping tree ${treeId} at position ${row},${col}`);
    moveTree(treeId, row, col);
}

        // ‚úÖ FIXED: Tree management functions with better validation
function addTreeAtPosition(row, col) {
    // ‚úÖ IMPROVED: Double-check position is empty
    if (!isPositionEmpty(row, col)) {
        showStatus(`Position ${row},${col} is already occupied!`, 'error');
        console.error(`Attempted to add tree at occupied position ${row},${col}`);
        return;
    }

    // ‚úÖ IMPROVED: Prevent multiple simultaneous requests
    if (isAddingTree) {
        showStatus('Please wait, adding tree...', 'info');
        return;
    }

    const name = prompt(`Enter name for tree at position ${row},${col}:`);
    if (!name || name.trim() === '') {
        showStatus('Tree name is required', 'error');
        return;
    }

    isAddingTree = true;
    showStatus('Adding tree...', 'info');
    
    console.log(`Adding tree "${name.trim()}" at position ${row},${col}`);
    
    fetch('/add_tree', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            dome_id: domeId,
            name: name.trim(),
            internal_row: row,
            internal_col: col
        })
    })
    .then(response => {
        console.log('Add tree response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Add tree response data:', data);
        if (data.success) {
            // ‚úÖ IMPROVED: Update local trees array immediately
            trees.push(data.tree);
            showStatus('Tree added successfully!', 'success');
            
            // ‚úÖ FORCE REFRESH: Get fresh data from backend
            setTimeout(() => {
                forceRefreshTrees();
            }, 500);
            
        } else {
            showStatus('Error: ' + (data.error || 'Failed to add tree'), 'error');
            console.error('Server error:', data);
        }
    })
    .catch(error => {
        console.error('Network error:', error);
        showStatus('Network error: Failed to add tree', 'error');
    })
    .finally(() => {
        isAddingTree = false;
    });
}

        function addRandomTree() {
            // ‚úÖ IMPROVED: Find empty positions with better validation
            const emptyPositions = getEmptyPositions();
            
            if (emptyPositions.length === 0) {
                showStatus('Grid is full! No empty positions available.', 'error');
                return;
            }
            
            const randomPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            const randomNames = ['Cannabis A', 'Cannabis B', 'Cannabis C', 'Hybrid X', 'Sativa Y', 'Indica Z'];
            const randomName = randomNames[Math.floor(Math.random() * randomNames.length)];
            
            // Use the same validation as addTreeAtPosition
            if (!isPositionEmpty(randomPos.row, randomPos.col)) {
                showStatus('Selected random position is occupied, trying again...', 'info');
                setTimeout(addRandomTree, 500); // Retry after 500ms
                return;
            }
            
            isAddingTree = true;
            showStatus(`Adding ${randomName} at ${randomPos.row},${randomPos.col}...`, 'info');
            
            console.log(`Adding random tree "${randomName}" at position ${randomPos.row},${randomPos.col}`);
            
            fetch('/add_tree', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    dome_id: domeId,
                    name: randomName,
                    internal_row: randomPos.row,
                    internal_col: randomPos.col
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    trees.push(data.tree);
                    showStatus(`${randomName} added successfully!`, 'success');
                    renderGrid();
                    refreshDebugInfo();
                } else {
                    showStatus('Error: ' + (data.error || 'Failed to add tree'), 'error');
                    console.error('Server error:', data);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Failed to add random tree', 'error');
            })
            .finally(() => {
                isAddingTree = false;
            });
        }

function moveTree(treeId, newRow, newCol) {
    showStatus('Moving tree...', 'info');
    
    console.log(`Moving tree ${treeId} to position ${newRow},${newCol}`);
    
    // ‚úÖ ADDED: Check if target position is occupied for swapping
    const targetTree = trees.find(t => t.internal_row === newRow && t.internal_col === newCol);
    const movingTree = trees.find(t => t.id == treeId);
    
    if (targetTree && movingTree) {
        console.log(`Swapping tree ${treeId} with tree ${targetTree.id}`);
        showStatus(`Swapping ${movingTree.name} with ${targetTree.name}...`, 'info');
    }
    
    fetch(`/move_tree/${treeId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            internal_row: newRow,
            internal_col: newCol
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Move tree response:', data);
        if (data.success) {
            if (data.swapped) {
                showSwapIndicator();
                showStatus('Trees swapped successfully!', 'success');
                console.log('Trees swapped:', data);
            } else {
                showStatus('Tree moved successfully!', 'success');
            }
            
            // ‚úÖ IMPROVED: Update local trees array immediately
            const tree = trees.find(t => t.id == treeId);
            if (tree) {
                tree.internal_row = newRow;
                tree.internal_col = newCol;
            }
            
            // ‚úÖ IMPROVED: Handle swapped tree data
            if (data.swapped && data.swapped_tree) {
                const swappedTree = trees.find(t => t.id == data.swapped_tree.id);
                if (swappedTree) {
                    swappedTree.internal_row = data.swapped_tree.internal_row;
                    swappedTree.internal_col = data.swapped_tree.internal_col;
                }
            }
            
            // ‚úÖ FORCE REFRESH: Re-render grid immediately
            renderGrid();
            refreshDebugInfo();
            
        } else {
            showStatus('Error: ' + (data.error || 'Failed to move tree'), 'error');
            console.error('Move tree error:', data);
        }
    })
    .catch(error => {
        console.error('Network error moving tree:', error);
        showStatus('Network error: Failed to move tree', 'error');
    });
}
function debugTreeData() {
    console.log('=== TREE DEBUG ===');
    console.log('Frontend trees:', trees);
    console.log('Frontend count:', trees.length);
    
    // ‚úÖ ALTERNATIVE: Get backend count from DOM instead of template
    const backendCount = document.getElementById('frontendTreesDisplay')?.textContent || 'Unknown';
    console.log('Backend count from DOM:', backendCount);
    
    // Force refresh from API
    fetch(`/api/dome/${domeId}/trees`)
    .then(response => response.json())
    .then(data => {
        console.log('API response:', data);
        if (data.success) {
            console.log('API trees count:', data.trees.length);
            console.log('API trees data:', data.trees);
        } else {
            console.error('API error:', data.error);
        }
    })
    .catch(error => {
        console.error('Network error:', error);
    });
}

// Make it available globally
window.debugTreeData = debugTreeData;
        function deleteTree(treeId) {
            if (!confirm('Are you sure you want to delete this tree?')) return;
            
            showStatus('Deleting tree...', 'info');
            
            console.log(`Deleting tree ${treeId}`);
            
            fetch(`/delete_tree/${treeId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                console.log('Delete tree response:', data);
                if (data.success) {
                    // ‚úÖ IMPROVED: Update local trees array
                    trees = trees.filter(t => t.id != treeId);
                    showStatus('Tree deleted successfully!', 'success');
                    renderGrid();
                    refreshDebugInfo();
                } else {
                    showStatus('Error: ' + (data.error || 'Failed to delete tree'), 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Failed to delete tree', 'error');
            });
        }

        function editTree(treeId) {
            const tree = trees.find(t => t.id == treeId);
            if (!tree) {
                showStatus('Tree not found', 'error');
                return;
            }
            
            const newName = prompt('Enter new name for tree:', tree.name);
            if (!newName || newName === tree.name || newName.trim() === '') return;
            
            showStatus('Updating tree name...', 'info');
            
            console.log(`Updating tree ${treeId} name to "${newName.trim()}"`);
            
            fetch(`/update_tree/${treeId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName.trim() })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Update tree response:', data);
                if (data.success) {
                    // ‚úÖ IMPROVED: Update local trees array
                    tree.name = newName.trim();
                    showStatus('Tree name updated successfully!', 'success');
                    renderGrid();
                    refreshDebugInfo();
                } else {
                    showStatus('Error: ' + (data.error || 'Failed to update tree'), 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Failed to update tree', 'error');
            });
        }

        function clearAllTrees() {
            if (!confirm('Are you sure you want to delete ALL trees? This cannot be undone!')) return;
            
            showStatus('Clearing all trees...', 'info');
            
            console.log(`Clearing all trees for dome ${domeId}`);
            
            fetch(`/clear_trees/${domeId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                console.log('Clear trees response:', data);
                if (data.success) {
                    // ‚úÖ IMPROVED: Clear local trees array
                    trees = [];
                    showStatus('All trees cleared successfully!', 'success');
                    renderGrid();
                    refreshDebugInfo();
                } else {
                    showStatus('Error: ' + (data.error || 'Failed to clear trees'), 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Failed to clear trees', 'error');
            });
        }

        function refreshGrid() {
            showStatus('Refreshing grid...', 'info');
            location.reload();
        }

function updateGridSize() {
    const newRows = parseInt(document.getElementById('gridRows').value);
    const newCols = parseInt(document.getElementById('gridCols').value);
    
    if (newRows < 1 || newRows > 100 || newCols < 1 || newCols > 100) {
        showStatus('Grid size must be between 1 and 100', 'error');
        return;
    }
    
    showStatus('Updating dome grid size...', 'info');
    
    console.log(`Updating dome ${domeId} grid size to ${newRows}x${newCols}`);
    
    // ‚úÖ FIXED: Use the correct parameter names and route
    fetch(`/update_dome_grid/${domeId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            rows: newRows,        // ‚úÖ Changed from internal_rows
            cols: newCols         // ‚úÖ Changed from internal_cols
        })
    })
    .then(response => {
        console.log('Update dome grid response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Update dome grid response:', data);
        if (data.success) {
            currentRows = newRows;
            currentCols = newCols;
            showStatus(`Dome grid updated to ${newRows}x${newCols}!`, 'success');
            updateGridDisplay();
            renderGrid();
            refreshDebugInfo();
        } else {
            showStatus('Error: ' + (data.error || 'Failed to update dome grid size'), 'error');
        }
    })
    .catch(error => {
        console.error('Error updating dome grid:', error);
        showStatus('Network error: Failed to update dome grid size', 'error');
    });
}

        function showSwapIndicator() {
            const indicator = document.getElementById('swapIndicator');
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }

        function updateStats() {
            const totalTrees = trees.length;
            const totalCells = currentRows * currentCols;
            const availablePositions = totalCells - totalTrees;
            const occupancyRate = totalCells > 0 ? (totalTrees / totalCells * 100).toFixed(1) : 0;
            
            document.getElementById('treeCount').textContent = totalTrees;
            document.getElementById('totalTrees').textContent = totalTrees;
            document.getElementById('currentGridSize').textContent = `${currentRows}√ó${currentCols}`;
            document.getElementById('availablePositions').textContent = availablePositions;
            document.getElementById('occupancyRate').textContent = occupancyRate + '%';
            
            // Update debug display
            if (document.getElementById('frontendTreesDisplay')) {
                document.getElementById('frontendTreesDisplay').textContent = totalTrees;
            }
        }

        // ‚úÖ ENHANCED: Cleanup function
        function cleanup() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // ‚úÖ ENHANCED: Handle page unload
        window.addEventListener('beforeunload', function(event) {
            cleanup();
            if (isAddingTree) {
                event.preventDefault();
                event.returnValue = 'A tree is being added. Are you sure you want to leave?';
                return event.returnValue;
            }
        });

        // ‚úÖ Make debug functions available globally for console access
        window.debugGrid = refreshDebugInfo;
        window.forceRefreshTrees = forceRefreshTrees;
        window.getEmptyPositions = getEmptyPositions;
        window.trees = trees;
        window.domeId = domeId;
        window.cleanup = cleanup;
    </script>
</body>
</html>