<!DOCTYPE html>
<html>
<head>
    <title>{{ dome.name }} - Tree Grid</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f0f0f0;
            overflow-x: auto;
        }
        .container {
            max-width: none;
            margin: 0 auto;
            min-width: 320px;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .dome-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .dome-image {
            width: 80px;
            height: 80px;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 3px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
            background-color: #2e8b57;
            background-repeat: no-repeat;
        }
        .dome-image:hover {
            transform: scale(1.05);
        }
        .dome-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .dome-image-container {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
            overflow: hidden;
        }

        .dome-image-container:hover {
            transform: scale(1.05);
        }

        .dome-image-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            display: block;
        }

        .dome-image-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            z-index: 1;
        }
.tree-grid .grid-cell.selecting {
    background: rgba(255, 152, 0, 0.5) !important;
    border: 3px solid #ff9800 !important;
    transform: scale(1.02) !important;
    box-shadow: 0 0 10px rgba(255, 152, 0, 0.6) !important;
    z-index: 5 !important;
    position: relative !important;
}
.tree-grid .grid-cell.selected {
    background: rgba(255, 152, 0, 0.7) !important;
    border: 3px solid #ff6600 !important;
    transform: scale(1.05) !important;
    box-shadow: 0 0 15px rgba(255, 152, 0, 0.8) !important;
    z-index: 6 !important;
    position: relative !important;
}
.tree-grid .grid-cell.selecting::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ff9800;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    pointer-events: none;
    z-index: 10;
}
.tree-grid.selection-mode-active {
    border: 3px dashed #ff9800 !important;
    background: rgba(255, 152, 0, 0.05) !important;
}

.tree-grid.selection-mode-active .grid-cell {
    transition: all 0.2s ease !important;
}

.tree-grid.selection-mode-active .grid-cell:hover {
    background: rgba(255, 152, 0, 0.2) !important;
    border-color: #ff9800 !important;
}
        /* ✅ NEW: Tree image display for base64 data */
        .tree-image-container {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            border-radius: 50%;
            border: 2px solid #4CAF50;
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
            pointer-events: none;
        }

        .tree-image-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            display: block;
        }

        .tree-image-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            z-index: 1;
        }
        .click-to-paste-mode {
    cursor: crosshair !important;
}

.click-to-paste-mode .grid-cell:hover {
    background: rgba(40, 167, 69, 0.2) !important;
    border: 2px dashed #28a745 !important;
}

.paste-preview-overlay {
    position: absolute;
    border: 3px dashed #28a745;
    background: rgba(40, 167, 69, 0.1);
    pointer-events: none;
    z-index: 100;
    border-radius: 6px;
}

.paste-invalid {
    border-color: #dc3545 !important;
    background: rgba(220, 53, 69, 0.1) !important;
}
        .dome-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.2;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .dome-placeholder:hover {
            transform: scale(1.05);
        }
        .dome-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .dome-title {
            font-size: 28px;
            color: #2e7d32;
            margin: 0;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .grid-controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        .grid-controls label {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .grid-controls input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        
        .grid-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: visible;
            padding: 10px 0;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            scroll-behavior: smooth;
        }
        
        .tree-grid {
            display: grid;
            gap: var(--grid-gap, 8px);
            padding: 20px;
            margin: 0 auto;
            min-width: fit-content;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            border: 2px dashed #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--cell-size, 100px);
            height: var(--cell-size, 100px);
            position: relative;
            transition: all 0.3s ease;
            background: #fafafa;
            cursor: pointer;
        }
        .grid-cell:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
            transform: scale(1.05);
        }
        .grid-cell.occupied {
            border: 2px solid #4CAF50;
            background: #e8f5e8;
        }
        .grid-cell.drag-over {
            border: 2px solid #ff9800 !important;
            background: #fff3e0 !important;
            transform: scale(1.05);
        }
        .grid-cell.swap-target {
            border: 2px solid #9c27b0 !important;
            background: #f3e5f5 !important;
            transform: scale(1.05);
        }
        .tree-item {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            box-sizing: border-box;
            position: relative;
            border-radius: 6px;
            cursor: grab;
            pointer-events: auto;
        }
        /* ✅ ADD THIS CSS FOR DRAG AREAS */
.drag-area-overlay {
    border: 3px solid;
    border-radius: 8px;
    pointer-events: none;
    z-index: 5;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.drag-area-overlay:hover {
    opacity: 1;
}

.drag-area-label {
    position: absolute;
    top: -25px;
    left: 0;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    white-space: nowrap;
    z-index: 6;
}

#dragAreasList {
    margin-top: 20px;
    border-top: 2px solid #007bff;
}

#dragAreasList h3 {
    color: #007bff;
    margin-bottom: 15px;
}
        .tree-item:active {
            cursor: grabbing;
        }
        .tree-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        .tree-image {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 2px solid #4CAF50;
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: none;
            position: relative;
            background-color: #2e8b57;
            background-repeat: no-repeat;
        }
        .tree-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .tree-placeholder {
            width: calc(var(--cell-size, 100px) * 0.6);
            height: calc(var(--cell-size, 100px) * 0.6);
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: calc(var(--cell-size, 100px) * 0.12);
            margin-bottom: 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            text-align: center;
            line-height: 1.1;
            pointer-events: none;
            position: relative;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        .tree-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }
        .tree-name {
            font-size: calc(var(--cell-size, 100px) * 0.1);
            font-weight: bold;
            color: #2e7d32;
            text-align: center;
            word-wrap: break-word;
            max-width: 100%;
            line-height: 1.2;
            pointer-events: none;
        }
        .click-to-paste-mode {
    border: 3px dashed #17a2b8 !important;
    background: rgba(23, 162, 184, 0.05) !important;
}

.click-to-paste-mode .grid-cell:not(.occupied):hover {
    background: rgba(23, 162, 184, 0.2) !important;
    border: 2px solid #17a2b8 !important;
    transform: scale(1.02);
    transition: all 0.2s ease;
    cursor: crosshair !important;
}

.click-to-paste-mode .grid-cell.occupied:hover {
    background: rgba(220, 53, 69, 0.2) !important;
    border: 2px solid #dc3545 !important;
    cursor: not-allowed !important;
}

.click-to-paste-mode .grid-cell:hover::after {
    content: "📋 Paste Here";
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #17a2b8;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
}

.click-to-paste-mode .grid-cell.occupied:hover::after {
    content: "❌ Occupied";
    background: #dc3545;
}
        .tree-actions {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            flex-direction: column;
            gap: 1px;
            pointer-events: auto;
        }
        .tree-item:hover .tree-actions {
            display: flex;
        }
        .action-btn {
            width: calc(var(--cell-size, 100px) * 0.2);
            height: calc(var(--cell-size, 100px) * 0.2);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: calc(var(--cell-size, 100px) * 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        .edit-btn {
            background: #2196F3;
            color: white;
        }
        .delete-btn {
            background: #f44336;
            color: white;
        }
        .add-tree-btn {
            background: none;
            border: 2px dashed #4CAF50;
            color: #4CAF50;
            font-size: calc(var(--cell-size, 100px) * 0.2);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: 100%;
            height: 100%;
        }
        .add-tree-btn:hover {
            background: #4CAF50;
            color: white;
        }
        .add-tree-btn:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
            border-color: #ccc;
        }
        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            margin-top: 20px;
        }
        .stats h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }
        .coordinate-label {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: calc(var(--cell-size, 100px) * 0.08);
            color: #666;
            background: rgba(255,255,255,0.8);
            padding: 1px 3px;
            border-radius: 2px;
            pointer-events: none;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .drag-instructions {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #1976d2;
        }
        .swap-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #9c27b0;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .grid-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .scroll-hint {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 12px;
            display: none;
            text-align: center;
        }

        .scroll-hint.show {
            display: block;
        }

        .navigation-controls {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 8px 16px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            display: none;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .status-success {
            background: #28a745;
        }

        .status-error {
            background: #dc3545;
        }

        .status-info {
            background: #17a2b8;
        }

        /* Debug panel */
        .debug-panel {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 12px;
        }

        .debug-panel h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .debug-panel pre {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 5px 0;
            max-height: 200px;
        }
/* ✅ NEW: Selection Box Mode Styles */
.selection-mode-controls {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    text-align: center;
    border: 2px solid #ff9800;
}

.selection-mode-active {
    background: #fff3e0 !important;
    border-color: #ff9800 !important;
}

.selection-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-top: 10px;
}

.selection-controls input, .selection-controls select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.grid-cell.selecting {
    background: rgba(255, 152, 0, 0.5) !important;
    border: 3px solid #ff9800 !important;
    transform: scale(1.02) !important;
    box-shadow: 0 0 10px rgba(255, 152, 0, 0.6) !important;
    z-index: 5 !important;
    position: relative !important;
}

.grid-cell.selected {
    background: rgba(255, 152, 0, 0.7) !important;
    border: 3px solid #ff6600 !important;
    transform: scale(1.05) !important;
    box-shadow: 0 0 15px rgba(255, 152, 0, 0.8) !important;
    z-index: 6 !important;
    position: relative !important;
}

.grid-cell.selecting::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ff9800;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    pointer-events: none;
    z-index: 10;
}

.selection-mode-active .tree-grid {
    border: 3px dashed #ff9800;
    background: rgba(255, 152, 0, 0.05);
}

.selection-mode-active .grid-cell {
    transition: all 0.2s ease;
}

.selection-mode-active .grid-cell:hover {
    background: rgba(255, 152, 0, 0.2) !important;
    border-color: #ff9800 !important;
}

.selection-box {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 3px solid;
    border-radius: 8px;
    pointer-events: none;
    z-index: 10;
    opacity: 0.7;
}

.selection-box-label {
    position: absolute;
    top: -25px;
    left: 0;
    background: inherit;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    white-space: nowrap;
}

.area-list {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-top: 20px;
}

.area-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 8px;
}

.area-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    margin-right: 10px;
}

.area-info {
    flex: 1;
    text-align: left;
}

.area-actions {
    display: flex;
    gap: 5px;
}

.area-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
}

.area-btn.edit {
    background: #2196F3;
    color: white;
}

.area-btn.delete {
    background: #f44336;
    color: white;
}

.area-btn.toggle {
    background: #4CAF50;
    color: white;
}

.area-btn.copy {
    background: #9c27b0;
    color: white;
}

.area-btn.paste {
    background: #ff5722;
    color: white;
}

.clipboard-indicator {
    position: fixed;
    top: 70px;
    right: 20px;
    background: #9c27b0;
    color: white;
    padding: 10px 15px;
    border-radius: 6px;
    font-size: 12px;
    display: none;
    z-index: 1002;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.paste-controls {
    background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
    border: 2px solid #9c27b0;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 4px 12px rgba(156, 39, 176, 0.2);
    display: none;
    animation: slideIn 0.3s ease;
}
@keyframes slideIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}
.paste-controls h4 {
    margin: 0 0 15px 0;
    color: #9c27b0;
    font-size: 18px;
    display: flex;
    align-items: center;
    gap: 10px;
}
.paste-controls.show {
    display: block !important;
}
.paste-preview {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 15px 0;
    font-size: 14px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.paste-preview strong {
    color: #9c27b0;
}
.paste-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 15px;
}
.paste-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    min-width: 120px;
}
.clipboard-status {
    position: fixed;
    top: 120px;
    right: 20px;
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: bold;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    cursor: pointer;
    transition: all 0.3s ease;
}
.clipboard-status:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
}
@keyframes bounceIn {
    0% { transform: scale(0.3); opacity: 0; }
    50% { transform: scale(1.05); }
    70% { transform: scale(0.9); }
    100% { transform: scale(1); opacity: 1; }
}
.clipboard-status.show {
    display: block !important;
    animation: bounceIn 0.5s ease;
}
.paste-buttons button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
#treeGrid.selection-mode-active .grid-cell.selecting {
    background: rgba(255, 152, 0, 0.8) !important;
    border: 4px solid #ff9800 !important;
    transform: scale(1.03) !important;
    box-shadow: 0 0 20px rgba(255, 152, 0, 1) !important;
    z-index: 15 !important;
    position: relative !important;
}

#treeGrid.selection-mode-active .grid-cell.selected {
    background: rgba(255, 152, 0, 0.8) !important;
    border: 4px solid #ff6600 !important;
    transform: scale(1.05) !important;
    box-shadow: 0 0 20px rgba(255, 152, 0, 1) !important;
    z-index: 16 !important;
    position: relative !important;
}
/* ✅ ADD THIS: Drag Selection CSS */
.drag-mode {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.drag-selection-box {
    position: absolute;
    border: 2px dashed #007bff;
    background: rgba(0, 123, 255, 0.1);
    pointer-events: none;
    z-index: 1000;
    display: none;
}

.tree-item.selected {
    transform: scale(1.05);
    transition: transform 0.2s ease;
}

.selection-highlight {
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border: 3px solid #007bff;
    border-radius: 8px;
    pointer-events: none;
    z-index: 10;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.grid-container {
    position: relative;
}
#treeGrid.selection-mode-active .grid-cell.selecting::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-size: 28px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    pointer-events: none;
    z-index: 20;
}
#treeGrid.selection-mode-active .grid-cell.selecting::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border: 3px dashed #ffffff;
    border-radius: 8px;
    pointer-events: none;
    z-index: 18;
    animation: selectionPulse 1s infinite;
}
.paste-btn-cross-dome {
    background: linear-gradient(45deg, #28a745, #20c997) !important;
    animation: pulse-cross-dome 2s infinite;
}

@keyframes pulse-cross-dome {
    0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
    100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
}

.clipboard-source-indicator {
    position: absolute;
    top: -8px;
    right: -8px;
    background: #ffc107;
    color: #000;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
@keyframes selectionPulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}
#treeGrid.selection-mode-active {
    border: 4px dashed #ff9800 !important;
    background: rgba(255, 152, 0, 0.1) !important;
}
#treeGrid.selection-mode-active .tree-item {
    pointer-events: none !important;
}
.area-actions {
    pointer-events: auto;
    z-index: 10;
}

.area-actions button {
    pointer-events: auto;
    position: relative;
    z-index: 11;
}

.area-item {
    position: relative;
}

/* Prevent dome click handlers from interfering */
.area-item * {
    pointer-events: auto;
}
#treeGrid.selection-mode-active .grid-cell {
    cursor: crosshair !important;
    pointer-events: auto !important;
}

#treeGrid.selection-mode-active .add-tree-btn {
    display: none !important;
}

/* ✅ NEW: Selection overlay for occupied cells */
.selection-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10;
    cursor: crosshair;
    background: transparent;
}
#treeGrid.selection-mode-active .grid-cell {
    transition: all 0.2s ease !important;
    cursor: crosshair !important;
}
.grid-cell.selecting {
    background-color: rgba(255, 152, 0, 0.8) !important;
    border: 4px solid #ff9800 !important;
    box-shadow: 0 0 20px rgba(255, 152, 0, 1) !important;
    z-index: 15 !important;
    position: relative !important;
    transform: scale(1.03) !important;
    transition: all 0.2s ease !important;
}

.grid-cell.selection-start {
    border-color: #4CAF50 !important;
    box-shadow: 0 0 25px rgba(76, 175, 80, 1) !important;
}

.grid-cell.selection-end {
    border-color: #f44336 !important;
    box-shadow: 0 0 25px rgba(244, 67, 54, 1) !important;
}

.selection-box {
    position: absolute;
    border: 3px solid;
    border-radius: 8px;
    pointer-events: none;
    z-index: 10;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.selection-box-label {
    position: absolute;
    top: -25px;
    left: 0;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    white-space: nowrap;
    z-index: 11;
}

.area-list {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #f8f9fa;
}

.area-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    margin-bottom: 10px;
    background: white;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.area-color {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    margin-right: 10px;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.area-actions {
    display: flex;
    gap: 5px;
}

.area-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
}

.area-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.area-btn.toggle { background: #28a745; color: white; }
.area-btn.copy { background: #6f42c1; color: white; }
.area-btn.fill { background: #28a745; color: white; }
.area-btn.edit { background: #007bff; color: white; }
.area-btn.delete { background: #dc3545; color: white; }
#treeGrid.selection-mode-active .grid-cell:hover {
    background: rgba(255, 152, 0, 0.3) !important;
    border-color: #ff9800 !important;
    transform: scale(1.02) !important;
}
        .debug-toggle {
            background: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin: 2px;
        }

        .debug-toggle:hover {
            background: #5a6268;
        }

        /* Responsive design */
        @media (max-width: 1400px) {
            :root {
                --cell-size: 90px;
                --grid-gap: 6px;
            }
        }

        @media (max-width: 1200px) {
            :root {
                --cell-size: 80px;
                --grid-gap: 5px;
            }
        }

        @media (max-width: 1000px) {
            :root {
                --cell-size: 70px;
                --grid-gap: 4px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --cell-size: 60px;
                --grid-gap: 4px;
            }
            
            .dome-title {
                font-size: 24px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .grid-controls {
                flex-direction: column;
                gap: 10px;
            }
        }

        @media (max-width: 600px) {
            :root {
                --cell-size: 50px;
                --grid-gap: 3px;
            }
            
            .dome-title {
                font-size: 20px;
            }
            
            .controls button {
                padding: 8px 16px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --cell-size: 45px;
                --grid-gap: 2px;
            }
            
            body {
                padding: 10px;
            }
            
            .dome-title {
                font-size: 18px;
            }
        }

        @media (min-width: 1600px) {
            :root {
                --cell-size: 110px;
                --grid-gap: 10px;
            }
        }

        @media (min-width: 2000px) {
            :root {
                --cell-size: 130px;
                --grid-gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Status Indicator -->
        <div id="statusIndicator" class="status-indicator"></div>

        <!-- Swap Indicator -->
        <div id="swapIndicator" class="swap-indicator">
            🔄 Swapping trees...
        </div>
<div id="clipboardIndicator" style="
    position: fixed;
    top: 120px;
    right: 20px;
    background: #28a745;
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1000;
    display: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
">
    📋 Area copied - Click to paste
</div>
        <!-- Debug Panel -->
        <div class="debug-panel" id="debugPanel" style="display: none;">
            <h4>🐛 Debug Information <button class="debug-toggle" onclick="toggleDebug()">Hide</button></h4>
            <div><strong>Dome ID:</strong> {{ dome.id }}</div>
            <div><strong>Grid Size:</strong> {{ rows }}×{{ cols }}</div>
            <div><strong>Trees from Backend:</strong> {{ trees|length }}</div>
            <div><strong>Frontend Trees Count:</strong> <span id="frontendTreesCount">Loading...</span></div>
            <div><strong>Empty Positions:</strong> <span id="emptyPositionsCount">Loading...</span></div>
            <div><strong>Trees Data:</strong></div>
            <pre id="treesData">{{ trees_data|tojson|safe }}</pre>
            <button class="debug-toggle" onclick="refreshDebugInfo()">🔄 Refresh Debug</button>
            <button class="debug-toggle" onclick="forceRefreshTrees()">🔄 Force Refresh Trees</button>
            <button class="debug-toggle" onclick="testNavigation()">🧪 Test Navigation</button>
        </div>

        <!-- Header -->
        <div class="header">
            <div class="dome-info">
                {% if dome.image_url and dome.image_url.startswith('data:image/') %}
                    <div class="dome-image-container" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}">
                        <img src="{{ dome.image_url }}" alt="Dome Image" class="dome-image-img">
                    </div>
                {% elif dome.image_url and not dome.image_url.startswith('data:image/') %}
                    <div class="dome-image" style="background-image: url('{{ dome.image_url }}?t={{ timestamp }}');" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}"></div>
                {% else %}
                    <div class="dome-placeholder" onclick="openDomeInfo()" title="Click to edit dome - {{ dome.name }}">
                        🏠
                    </div>
                {% endif %}
                <h1 class="dome-title">{{ dome.name }}</h1>
            </div>
            <p>Internal Grid: {{ rows }}×{{ cols }} | Total Trees: <span id="treeCount">{{ trees|length }}</span></p>
        </div>
        
        <!-- Grid Info -->
        <div class="grid-info">
            <strong>Current Grid:</strong> {{ rows }}×{{ cols }} 
            ({{ rows * cols }} total cells) | 
            <strong>Backend Trees:</strong> {{ trees|length }} | 
            <strong>Frontend Trees:</strong> <span id="frontendTreesDisplay">Loading...</span>
            <button class="debug-toggle" onclick="showDebug()" style="margin-left: 10px;">🐛 Debug</button>
        </div>
        
        <!-- Scroll Hint -->
        <div class="scroll-hint" id="scrollHint">
            💡 <strong>Tip:</strong> Use horizontal scroll or navigation buttons to view large grids. Use keyboard arrows for quick navigation.
        </div>
        
        <!-- Navigation Controls -->
        <div class="navigation-controls" id="navigationControls" style="display: none;">
            <button class="nav-btn" onclick="scrollToPosition('start')">⏮️ Start</button>
            <button class="nav-btn" onclick="scrollToPosition('left')">⬅️ Left</button>
            <button class="nav-btn" onclick="centerGrid()">🎯 Center</button>
            <button class="nav-btn" onclick="scrollToPosition('right')">➡️ Right</button>
            <button class="nav-btn" onclick="scrollToPosition('end')">⏭️ End</button>
            <button class="nav-btn" onclick="fitToScreen()">📱 Fit Screen</button>
            
        </div>
        
        <!-- Drag Instructions -->
        <div class="drag-instructions">
            💡 <strong>Tip:</strong> Drag trees to empty spaces to move them, or drop on another tree to swap positions. Click on a tree to view details.
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <button class="btn-secondary" onclick="goBack()">← Back to Dome Info</button>
            
            <button class="btn-info" onclick="openDomeInfo()">ℹ️ Dome Info</button>
            <button id="pasteAreaBtn" class="btn-success" style="display: none;">
    📋 Paste Area
</button>

            <button class="btn-warning" onclick="goToMainIndex()">🚜 Back to Farm Domes</button class="btn-primary" onclick="addRandomTree()">🌱 Add Random Tree</button>
            <button class="btn-secondary" onclick="refreshGrid()">🔄 Refresh Grid</button>
            <button class="btn-danger" onclick="forceRefreshTrees()">🔄 Force Refresh Trees</button>
            <button class="btn-info" onclick="testSelection()">🧪 Test Selection</button>
            <button class="btn-warning" onclick="clearAllTrees()">🗑️ Clear All Trees</button>
            <button class="btn-danger" onclick="clearClipboardStorage()">🗑️ Clear Clipboard</button>
        </div>
        <div class="tree-search-container" style="margin: 10px 0;">
    <div class="search-input-wrapper" style="position: relative; display: inline-block; width: 300px;">
        <input 
            type="text" 
            id="treeSearchInput" 
            placeholder="🔍 Search trees by name..." 
            style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
            autocomplete="off"
        >
        <div id="searchResults" class="search-results" style="
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        "></div>
    </div>
    <button 
        id="clearSearchBtn" 
        onclick="clearTreeSearch()" 
        style="margin-left: 10px; padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;"
        title="Clear search and highlights"
    >
        Clear
    </button>
    <span id="searchStats" style="margin-left: 10px; color: #666; font-size: 12px;"></span>
</div>
        <!-- Grid Size Controls -->
        <div class="grid-controls">
            <label>Grid Size:</label>
            <label>Rows: <input type="number" id="gridRows" min="1" max="100" value="{{ rows }}"></label>
            <label>Cols: <input type="number" id="gridCols" min="1" max="100" value="{{ cols }}"></label>
            <button class="btn-primary" onclick="updateGridSize()">Update Size</button>
            <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Maximum: 100×100 grid</p>
        </div>
        
        <!-- Tree Grid Container -->
        <div class="grid-container" id="gridContainer">
            <div class="tree-grid" id="treeGrid">
                <div class="loading">Loading grid...</div>
            </div>
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <h3>Grid Statistics</h3>
            <p>Total Trees: <span id="totalTrees">{{ trees|length }}</span></p>
            <p>Grid Size: <span id="currentGridSize">{{ rows }}×{{ cols }}</span></p>
            <p>Available Positions: <span id="availablePositions">{{ (rows * cols) - trees|length }}</span></p>
            <p>Occupancy Rate: <span id="occupancyRate">{{ "%.1f"|format((trees|length / (rows * cols) * 100) if (rows * cols) > 0 else 0) }}%</span></p>
        </div>
    </div>

    
    <!-- ✅ NEW: Paste Controls -->
<div class="paste-controls" id="pasteControls" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h4 style="margin: 0;">📋 Paste Area</h4>
        <button onclick="hidePasteControls()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #666;" title="Close">
            ✕
        </button>
    </div>
    <div class="paste-preview" id="pastePreview">
        <div id="pastePreviewContent">No area in clipboard</div>
    </div>
    <div class="paste-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 15px;">
        <button class="btn-success" onclick="executeSmartPaste()" title="Find best position and paste">
            📋 Smart Paste
        </button>
        <button class="btn-info" id="clickToPasteBtn" onclick="enableClickToPaste()" title="Click on grid to choose position">
            🎯 Click to Paste
        </button>
        <button class="btn-warning" onclick="showManualPasteDialog()" title="Enter specific coordinates">
            📍 Manual Position
        </button>
        <button class="btn-secondary" onclick="cancelPaste()" title="Cancel paste operation">
            ❌ Cancel
        </button>
    </div>
    <div id="clickToPasteInstructions" style="display: none; margin-top: 15px; padding: 12px; background: #e3f2fd; border-radius: 6px; text-align: center; font-size: 13px; color: #1976d2;">
        🎯 <strong>Click Mode Active:</strong> Click on any empty grid cell to paste the area there
    </div>
</div>
<div class="clipboard-status" id="clipboardStatus" onclick="showPasteControls()">
    📋 Area ready to paste - Click here
</div>
<!-- ✅ NEW: Clipboard Indicator -->
<div class="clipboard-indicator" id="clipboardIndicator">
    📋 Area copied to clipboard
</div>

<!-- ✅ NEW: Areas List -->
<div class="area-list" id="areasList" style="display: none;">
    <h3>📍 Created Areas</h3>
    <div id="areasContainer">
        <p>No areas created yet</p>
    </div>
</div>
<script>
// ✅ NEW: Color validation function
function ensureValidHexColor(color) {
    if (!color || typeof color !== 'string') return '#007bff';
    color = color.trim();
    if (!color.startsWith('#')) color = '#' + color;
    const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    if (hexRegex.test(color)) {
        if (color.length === 4) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
        }
        return color;
    }
    return '#007bff';
}
window.ensureValidHexColor = ensureValidHexColor;

// ✅ NEW: Build mother-cutting pairs for relationship metadata
function buildMotherCuttingPairs(enhancedTreesData) {
    console.log('🔗 Building mother-cutting pairs for relationship metadata...');
    
    const motherTrees = enhancedTreesData.filter(t => t.plant_type === 'mother');
    const cuttingTrees = enhancedTreesData.filter(t => t.plant_type === 'cutting');
    
    console.log(`🔍 Found ${motherTrees.length} mothers and ${cuttingTrees.length} cuttings`);
    
    const pairs = [];
    
    // Build pairs for each cutting tree
    cuttingTrees.forEach(cutting => {
        if (cutting.mother_plant_id) {
            const motherTree = motherTrees.find(m => m.id === cutting.mother_plant_id);
            
            const pair = {
                cutting_original_id: cutting.id,
                cutting_name: cutting.name,
                cutting_plant_type: cutting.plant_type,
                cutting_notes: cutting.cutting_notes || '',
                mother_original_id: cutting.mother_plant_id,
                mother_name: motherTree ? motherTree.name : `Mother Tree ${cutting.mother_plant_id}`,
                mother_plant_type: motherTree ? motherTree.plant_type : 'mother',
                relationship_preserved: !!motherTree, // True if mother is also being copied
                mother_in_copy: !!motherTree,
                cutting_position: {
                    row: cutting.internal_row,
                    col: cutting.internal_col,
                    relative_row: cutting.relativeRow || cutting.relative_row || 0,
                    relative_col: cutting.relativeCol || cutting.relative_col || 0
                },
                mother_position: motherTree ? {
                    row: motherTree.internal_row,
                    col: motherTree.internal_col,
                    relative_row: motherTree.relativeRow || motherTree.relative_row || 0,
                    relative_col: motherTree.relativeCol || motherTree.relative_col || 0
                } : null
            };
            
            pairs.push(pair);
            
            if (motherTree) {
                console.log(`🔗 Complete relationship: cutting "${cutting.name}" -> mother "${motherTree.name}"`);
            } else {
                console.log(`🔗 Partial relationship: cutting "${cutting.name}" -> mother ID ${cutting.mother_plant_id} (not in copy)`);
            }
        }
    });
    
    console.log(`✅ Built ${pairs.length} mother-cutting pairs`);
    return pairs;
}

// Make function available globally
window.buildMotherCuttingPairs = buildMotherCuttingPairs;

// Drag Selection Box Implementation


// Initialize drag selector when DOM is loaded


document.addEventListener('DOMContentLoaded', function() {
    const gridContainer = document.querySelector('.grid-container');
    if (gridContainer) {
        dragSelector = new DragSelector(gridContainer);
        
        // Add drag mode toggle button
        addDragModeToggle();
    }
});

function addDragModeToggle() {
    // Add drag mode toggle button to the page
    const toggleButton = document.createElement('button');
    toggleButton.innerHTML = '🎯 Drag Select';
    toggleButton.className = 'btn btn-outline-primary';
    toggleButton.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1000;
    `;
    toggleButton.onclick = function() {
        if (dragSelector.isDragMode) {
            dragSelector.disableDragMode();
            this.innerHTML = '🎯 Drag Select';
            this.className = 'btn btn-outline-primary';
        } else {
            dragSelector.enableDragMode();
            this.innerHTML = '❌ Exit Drag';
            this.className = 'btn btn-danger';
        }
    };
    
    document.body.appendChild(toggleButton);
}

// Utility function for notifications
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} alert-dismissible fade show`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10001;
        min-width: 300px;
    `;
    notification.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}
</script>
    <script>
        // ✅ FIXED: Global variables with proper initialization
        const domeId = {{ dome.id }};
        const farmId = {{ dome.farm_id }};
        let currentRows = {{ rows }};
        let currentCols = {{ cols }};
        let trees = {{ trees_data|tojson|safe }};
        let draggedTree = null;
        let isAddingTree = false;
        let autoRefreshInterval = null;
        let selectionMode = false;

        // ✅ FIXED: Load clipboard with dome isolation to prevent cross-contamination
        window.addEventListener('DOMContentLoaded', function() {
            try {
                // Check if we're intentionally loading from a different dome (cross-dome paste)
                const urlParams = new URLSearchParams(window.location.search);
                const allowCrossDomePaste = urlParams.get('paste') === 'true';
                
                // Load drag area clipboard (priority) - only if cross-dome paste is intended
                const globalDragClipboard = localStorage.getItem('globalDragClipboard');
                const globalTreeClipboard = localStorage.getItem('globalTreeClipboard');
                
                // Check if clipboard is from current dome to avoid unwanted loading
                let shouldLoadClipboard = false;
                
                if (globalDragClipboard) {
                    const dragData = JSON.parse(globalDragClipboard);
                    // Only load if it's from a different dome OR if explicitly allowing cross-dome paste
                    if (allowCrossDomePaste || dragData.source_dome_id !== domeId) {
                        shouldLoadClipboard = true;
                        window.dragClipboard = dragData;
                        window.clipboardArea = dragData;
                        console.log('📋 Loaded drag area clipboard from localStorage:', dragData.name);
                        
                        // Show paste button for drag area
                        const pasteBtn = document.getElementById('pasteAreaBtn');
                        if (pasteBtn) {
                            pasteBtn.style.display = 'block';
                            const treeCount = dragData.tree_count || dragData.trees?.length || 0;
                            pasteBtn.textContent = `📋 Paste ${dragData.name || 'Area'} (${treeCount} trees)`;
                            pasteBtn.classList.add('paste-btn-cross-dome');
                        }
                    }
                } else if (globalTreeClipboard && (allowCrossDomePaste || JSON.parse(globalTreeClipboard).source_dome_id !== domeId)) {
                    const treeData = JSON.parse(globalTreeClipboard);
                    window.copiedTreeData = treeData;
                    console.log('📋 Loaded single tree clipboard from localStorage:', treeData.tree?.name);
                    
                    // Show paste button for single tree
                    const pasteBtn = document.getElementById('pasteAreaBtn');
                    if (pasteBtn) {
                        pasteBtn.style.display = 'block';
                        const treeName = treeData.tree?.name || 'Tree';
                        const relationshipCount = treeData.relationships?.total_cuttings || 0;
                        pasteBtn.textContent = `📋 Paste "${treeName}"${relationshipCount > 0 ? ` (+${relationshipCount})` : ''}`;
                    }
                }
                
                // If no cross-dome clipboard loaded, check for dome-specific clipboard
                if (!shouldLoadClipboard) {
                    const domeSpecificClipboard = localStorage.getItem(`domeClipboard_${domeId}`);
                    if (domeSpecificClipboard) {
                        const clipboardData = JSON.parse(domeSpecificClipboard);
                        window.clipboardArea = clipboardData;
                        console.log('📋 Loaded dome-specific clipboard:', clipboardData.name);
                    }
                }
                
            } catch (e) {
                console.warn('⚠️ Could not load clipboard:', e);
            }
        });
let isSelecting = false;
let selectionStart = null;
let selectionEnd = null;
let selectedCells = [];
let areas = [];
let areaIdCounter = 1;
let dragAreas = [];
let dragAreaIdCounter = 1;
let dragClipboard = null;
let dragSelector = null;
let lineAreas = [];
let lineAreaIdCounter = 1;
// ✅ NEW: Clipboard Variables
let clipboardArea = null;
let pasteMode = false;
let clickToPasteMode = false;
let pastePreviewOverlay = null;

let pasteOffset = { row: 0, col: 0 };
        // ✅ NEW: Copy tree to clipboard with relationship data
        async function copyTreeToClipboard(tree) {
            try {
                console.log('📋 Copying tree to clipboard:', tree);
                
                // Get all cutting trees if this is a mother tree
                let cuttingTrees = [];
                if (tree.plant_type === 'mother') {
                    cuttingTrees = trees.filter(t => t.mother_plant_id === tree.id);
                    console.log(`🌳 Found ${cuttingTrees.length} cutting trees for mother "${tree.name}"`);
                }
                
                // Get mother tree if this is a cutting
                let motherTree = null;
                if (tree.plant_type === 'cutting' && tree.mother_plant_id) {
                    motherTree = trees.find(t => t.id === tree.mother_plant_id);
                    console.log(`✂️ Found mother tree for cutting "${tree.name}":`, motherTree?.name);
                }
                
                // Create comprehensive tree data for clipboard
                const treeClipboardData = {
                    id: 'copied_tree_' + Date.now(),
                    type: 'single_tree',
                    source_dome_id: domeId,
                    copied_at: new Date().toISOString(),
                    tree: {
                        ...tree,
                        original_id: tree.id,
                        original_dome_id: domeId
                    },
                    relationships: {
                        is_mother: tree.plant_type === 'mother',
                        is_cutting: tree.plant_type === 'cutting',
                        cutting_trees: cuttingTrees.map(cutting => ({
                            ...cutting,
                            original_id: cutting.id,
                            original_dome_id: domeId
                        })),
                        mother_tree: motherTree ? {
                            ...motherTree,
                            original_id: motherTree.id,
                            original_dome_id: domeId
                        } : null,
                        total_cuttings: cuttingTrees.length
                    },
                    paste_options: {
                        transfer_cuttings: tree.plant_type === 'mother' && cuttingTrees.length > 0,
                        needs_mother: tree.plant_type === 'cutting' && motherTree !== null
                    }
                };
                
                // Store in global clipboard for cross-grid pasting
                window.copiedTreeData = treeClipboardData;
                
                // ✅ FIXED: Store single tree with dome isolation
                const singleTreeClipboard = {
                    type: 'single_tree',
                    name: `Copied Tree: ${tree.name}`,
                    width: 1,
                    height: 1,
                    tree_count: 1 + cuttingTrees.length,
                    trees: [tree, ...cuttingTrees],
                    trees_data: [tree, ...cuttingTrees],
                    source_dome_id: domeId, // ✅ ADD: Track source dome
                    copied_at: new Date().toISOString(),
                    summary: {
                        total_trees: 1 + cuttingTrees.length,
                        trees_in_original_area: 1,
                        related_trees_outside_area: cuttingTrees.length,
                        breeds: [tree.breed].filter(b => b),
                        breed_count: tree.breed ? 1 : 0,
                        has_images: tree.image_url ? 1 : 0,
                        plant_relationships: {
                            mother_trees: tree.plant_type === 'mother' ? 1 : 0,
                            cutting_trees: cuttingTrees.length,
                            complete_relationships: tree.plant_type === 'mother' ? cuttingTrees.length : 0,
                            broken_relationships: 0,
                            independent_trees: tree.plant_type === 'mother' || tree.plant_type === 'cutting' ? 0 : 1
                        }
                    },
                    clipboard_source: 'tree_copy',
                    copied_tree_data: treeClipboardData
                };
                
                // ✅ FIXED: Store both dome-specific and global clipboard
                window.dragClipboard = singleTreeClipboard;
                window.clipboardArea = singleTreeClipboard;
                
                // Store in localStorage with dome isolation
                try {
                    // Store dome-specific clipboard (won't interfere with other domes)
                    localStorage.setItem(`domeClipboard_${domeId}`, JSON.stringify(singleTreeClipboard));
                    
                    // Store global clipboard for intentional cross-dome pasting
                    localStorage.setItem('copiedTreeData', JSON.stringify(treeClipboardData));
                    localStorage.setItem('globalTreeClipboard', JSON.stringify(treeClipboardData));
                    localStorage.setItem('globalDragClipboard', JSON.stringify(singleTreeClipboard));
                    
                    console.log('✅ Tree data saved with dome isolation');
                } catch (e) {
                    console.warn('⚠️ Could not save to localStorage:', e);
                }
                
                // Show paste button
                const pasteBtn = document.getElementById('pasteAreaBtn');
                if (pasteBtn) {
                    pasteBtn.style.display = 'block';
                    pasteBtn.textContent = `📋 Paste "${tree.name}"${cuttingTrees.length > 0 ? ` (+${cuttingTrees.length} cuttings)` : ''}`;
                }
                
                // Show success message with relationship info
                let message = `Tree "${tree.name}" copied to clipboard`;
                if (tree.plant_type === 'mother' && cuttingTrees.length > 0) {
                    message += ` with ${cuttingTrees.length} cutting tree(s)`;
                } else if (tree.plant_type === 'cutting' && motherTree) {
                    message += ` (cutting from "${motherTree.name}")`;
                }
                
                showStatus(message, 'success');
                console.log('📋 Tree copied successfully:', treeClipboardData);
                
            } catch (error) {
                console.error('❌ Error copying tree:', error);
                showStatus('Failed to copy tree', 'error');
            }
        }

        // ✅ FIXED: Navigation functions
        function goBack() {
            console.log('Going back to dome_info');
            window.location.href = `/dome_info/${domeId}`;
        }

        function openDomeInfo() {
            window.location.href = `/dome_info/${domeId}`;
        }

        function openTreeInfo(treeId) {
            window.location.href = `/tree_info/${treeId}`;
        }

        function goToMainIndex() {
            console.log('Going back to farm dome view');
            window.location.href = `/farm/{{ dome.farm_id }}/domes`;
        }

        function goToFarms() {
            console.log('Going to farms management');
            window.location.href = '/farms';
        }

        // ✅ FIXED: Status indicator functions
        function showStatus(message, type = 'info', duration = 3000) {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.className = `status-indicator status-${type}`;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, duration);
        }

        // ✅ FIXED: Debug functions
        function showDebug() {
            document.getElementById('debugPanel').style.display = 'block';
            refreshDebugInfo();
        }
function handlePasteButtonClick() {
    console.log('🎯 Paste button clicked');
    
    // Check what's in clipboard
    const clipboard = dragClipboard || clipboardArea;
    
    if (!clipboard) {
        // Try loading from global storage
        const globalDrag = localStorage.getItem('globalDragClipboard');
        const globalRegular = localStorage.getItem('globalRegularClipboard');
        
        if (globalDrag) {
            dragClipboard = JSON.parse(globalDrag);
            console.log('✅ Loaded drag clipboard from global storage');
        } else if (globalRegular) {
            clipboardArea = JSON.parse(globalRegular);
            console.log('✅ Loaded regular clipboard from global storage');
        } else {
            showStatus('No area in clipboard', 'warning');
            return;
        }
    }
    
    // ✅ ENHANCED: Add data paste functionality with relationship handling
    if (clipboard && clipboard.relationship_metadata) {
        console.log('🔗 Processing clipboard with relationship data');
        
        // Extract relationship metadata
        const relationshipData = clipboard.relationship_metadata;
        const motherCuttingPairs = relationshipData.mother_cutting_pairs || [];
        
        console.log(`🔗 Found ${motherCuttingPairs.length} mother-cutting relationships in clipboard`);
        
        // Process mother trees with cutting trees
        if (motherCuttingPairs.length > 0) {
            console.log('🌳 Processing mother trees with cutting relationships...');
            
            // Group cutting trees by their mother
            const motherGroups = {};
            motherCuttingPairs.forEach(pair => {
                const motherId = pair.mother_original_id;
                if (!motherGroups[motherId]) {
                    motherGroups[motherId] = {
                    mother: pair,
                    cuttings: []
                    };
                }
                if (pair.cutting_original_id) {
                    motherGroups[motherId].cuttings.push(pair);
                }
            });
            
            // Log the relationship structure
            Object.keys(motherGroups).forEach(motherId => {
                const group = motherGroups[motherId];
                console.log(`🌳 Mother "${group.mother.mother_name}" has ${group.cuttings.length} cutting(s)`);
                group.cuttings.forEach(cutting => {
                    console.log(`  ✂️ Cutting: "${cutting.cutting_name}"`);
                });
            });
            
            // Store relationship data for paste operation
            clipboard.processedRelationships = {
            motherGroups: motherGroups,
            totalRelationships: motherCuttingPairs.length,
            preservedRelationships: motherCuttingPairs.filter(p => p.relationship_preserved).length
            };
            
            console.log('✅ Relationship data processed and stored in clipboard');
        }
    }
    
    // Show paste options dialog
    showPasteOptionsDialog();
}   
// ✅ ENHANCED: Show paste options dialog with comprehensive tree breakdown
function showPasteOptionsDialog() {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) {
        console.warn('⚠️ No clipboard data available for paste options');
        return;
    }
    
    console.log('📋 Showing paste options dialog with clipboard data:', clipboard);
    
    // ✅ CRITICAL: Get accurate tree breakdown
    let totalTrees = 0;
    let treesInOriginalArea = 0;
    let relatedTreesOutside = 0;
    let treesData = [];
    
    // Get trees data
    if (clipboard.trees && Array.isArray(clipboard.trees)) {
        treesData = clipboard.trees;
        totalTrees = clipboard.trees.length;
    } else if (clipboard.trees_data && Array.isArray(clipboard.trees_data)) {
        treesData = clipboard.trees_data;
        totalTrees = clipboard.trees_data.length;
    } else if (clipboard.tree_count !== undefined) {
        totalTrees = clipboard.tree_count;
    }
    
    // ✅ ENHANCED: Calculate tree breakdown
    if (clipboard.summary) {
        treesInOriginalArea = clipboard.summary.trees_in_original_area || totalTrees;
        relatedTreesOutside = clipboard.summary.related_trees_outside_area || 0;
    } else if (treesData.length > 0) {
        // Calculate manually if summary not available
        treesInOriginalArea = treesData.filter(tree => tree.isInOriginalArea !== false).length;
        relatedTreesOutside = treesData.filter(tree => tree.isInOriginalArea === false).length;
    } else {
        treesInOriginalArea = totalTrees;
        relatedTreesOutside = 0;
    }
    
    // ✅ ENHANCED: Get breed information
    let breeds = [];
    let breedCount = 0;
    
    if (treesData && treesData.length > 0) {
        breeds = [...new Set(treesData.map(tree => tree.breed).filter(breed => breed && breed.trim()))];
        breedCount = breeds.length;
    } else if (clipboard.summary && clipboard.summary.breeds) {
        breeds = clipboard.summary.breeds;
        breedCount = clipboard.summary.breed_count || breeds.length;
    }
    
    // ✅ ENHANCED: Get relationship information
    let relationshipInfo = '';
    let hasRelationships = false;
    if (clipboard.summary && clipboard.summary.plant_relationships) {
        const rel = clipboard.summary.plant_relationships;
        const mothers = rel.mother_trees || 0;
        const cuttings = rel.cutting_trees || 0;
        const complete = rel.complete_relationships || 0;
        
        if (mothers > 0 || cuttings > 0) {
            relationshipInfo = `${mothers} mothers, ${cuttings} cuttings`;
            hasRelationships = true;
            if (complete > 0) {
                relationshipInfo += ` (${complete} complete relationships)`;
            }
        }
    }
    
    // ✅ ENHANCED: Create comprehensive clipboard info
    const clipboardInfo = {
        name: clipboard.name || 'Unnamed Area',
        width: clipboard.width || 1,
        height: clipboard.height || 1,
        totalTrees: totalTrees,
        treesInArea: treesInOriginalArea,
        relatedOutside: relatedTreesOutside,
        type: clipboard.type || 'dragArea',
        breeds: breeds,
        breedCount: breedCount,
        breedText: breedCount > 0 ? `${breedCount} (${breeds.join(', ')})` : 'None',
        relationshipInfo: relationshipInfo,
        hasRelationships: hasRelationships,
        hasImages: clipboard.summary ? clipboard.summary.has_images || 0 : 0,
        clipboardSource: clipboard.clipboard_source || 'unknown'
    };
    
    console.log('📊 Final clipboard info for dialog:', clipboardInfo);
    
    // ✅ ENHANCED: Create modal with clear tree breakdown
    const modal = document.createElement('div');
    modal.className = 'paste-options-modal';
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 12px;
                padding: 25px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                max-height: 80vh;
                overflow-y: auto;
            " onclick="event.stopPropagation();">
                <h5 style="margin: 0 0 20px 0; color: #9c27b0;">📋 Paste Area Options</h5>
                
                <!-- ✅ ENHANCED: Clear tree breakdown -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px;">
                        <div><strong>Area:</strong> ${clipboardInfo.name}</div>
                        <div><strong>Size:</strong> ${clipboardInfo.width}×${clipboardInfo.height}</div>
                        <div><strong>Type:</strong> ${clipboardInfo.type === 'dragArea' ? 'Drag Area' : 'Regular Area'}</div>
                        <div><strong>Source:</strong> ${clipboardInfo.clipboardSource}</div>
                    </div>
                    
                    <!-- ✅ CRITICAL: Clear tree breakdown -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <div style="font-weight: bold; margin-bottom: 10px; color: #495057;">🌳 Trees Included:</div>
                        
                        ${clipboardInfo.relatedOutside > 0 ? `
                            <!-- Show breakdown when related trees are included -->
                            <div style="background: #e3f2fd; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <div style="font-size: 16px; font-weight: bold; color: #1976d2; margin-bottom: 8px;">
                                    Total: ${clipboardInfo.totalTrees} trees
                                </div>
                                <div style="font-size: 14px; color: #424242;">
                                    📦 <strong>${clipboardInfo.treesInArea}</strong> trees in original area<br>
                                    🔗 <strong>${clipboardInfo.relatedOutside}</strong> related trees (mothers/cuttings outside area)
                                </div>
                                <div style="margin-top: 8px; padding: 8px; background: #fff3e0; border-radius: 4px; font-size: 12px; color: #e65100;">
                                    ℹ️ Related trees are included to preserve plant relationships
                                </div>
                            </div>
                        ` : `
                            <!-- Simple display when no related trees -->
                            <div style="background: #e8f5e8; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <div style="font-size: 16px; font-weight: bold; color: #2e7d32;">
                                    ${clipboardInfo.totalTrees} trees in area
                                </div>
                            </div>
                        `}
                    </div>
                    
                    ${clipboardInfo.breedCount > 0 ? `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                            <div style="font-size: 14px;"><strong>🧬 Breeds:</strong> ${clipboardInfo.breedText}</div>
                        </div>
                    ` : ''}
                    
                    ${clipboardInfo.hasRelationships ? `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                            <div style="font-size: 14px;"><strong>🔗 Relationships:</strong> ${clipboardInfo.relationshipInfo}</div>
                            ${clipboardInfo.relatedOutside > 0 ? `
                                <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                    Related trees outside the area are included to maintain relationships
                                </div>
                            ` : ''}
                        </div>
                    ` : ''}
                    
                    ${clipboardInfo.hasImages > 0 ? `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dee2e6;">
                            <div style="font-size: 14px;"><strong>🖼️ Images:</strong> ${clipboardInfo.hasImages} trees with images</div>
                        </div>
                    ` : ''}
                </div>
                
                <!-- ✅ ENHANCED: Paste options with clear descriptions -->
                <div style="margin-bottom: 20px;">
                    <h6 style="margin: 0 0 15px 0; color: #495057;">Choose paste method:</h6>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="enableClickToPaste(); this.closest('.paste-options-modal').remove();" style="
                            padding: 12px 20px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 8px;
                        ">
                            🎯 Click to Paste All ${clipboardInfo.totalTrees} Trees
                        </button>
                        
                        <button onclick="showManualPasteDialog(); this.closest('.paste-options-modal').remove();" style="
                            padding: 12px 20px;
                            background: #28a745;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 8px;
                        ">
                            📍 Manual Position (All ${clipboardInfo.totalTrees} Trees)
                        </button>
                        
                        ${clipboardInfo.relatedOutside > 0 ? `
                            <button onclick="pasteAreaTreesOnly(); this.closest('.paste-options-modal').remove();" style="
                                padding: 12px 20px;
                                background: #17a2b8;
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 14px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                📦 Area Trees Only (${clipboardInfo.treesInArea} Trees)
                            </button>
                        ` : ''}
                        
                        <button onclick="pasteAreaOnlyFromDialog(); this.closest('.paste-options-modal').remove();" style="
                            padding: 12px 20px;
                            background: #ffc107;
                            color: #212529;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 8px;
                        ">
                            🔲 Area Boundary Only (No Trees)
                        </button>
                    </div>
                </div>
                
                <!-- ✅ ENHANCED: Additional options -->
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <button onclick="clearClipboard(); this.closest('.paste-options-modal').remove();" style="
                        padding: 8px 16px;
                        background: #dc3545;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                    ">
                        🗑️ Clear Clipboard
                    </button>
                    
                    <button onclick="this.closest('.paste-options-modal').remove();" style="
                        padding: 8px 16px;
                        background: #6c757d;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                    ">
                        ❌ Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    console.log('✅ Paste options dialog shown with clear tree breakdown:', {
        totalTrees: clipboardInfo.totalTrees,
        treesInArea: clipboardInfo.treesInArea,
        relatedOutside: clipboardInfo.relatedOutside
    });
}
function pasteAreaTreesOnly() {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) {
        showStatus('No area in clipboard', 'error');
        return;
    }
    
    console.log('📦 Pasting area trees only (excluding related trees outside area)...');
    
    // ✅ Filter to only include trees that were in the original area
    const originalTrees = clipboard.trees ? clipboard.trees.filter(tree => tree.isInOriginalArea !== false) : [];
    
    // Create a modified clipboard with only area trees
    const areaTreesOnlyClipboard = {
        ...clipboard,
        trees: originalTrees,
        trees_data: originalTrees,
        selectedTrees: originalTrees,
        tree_count: originalTrees.length,
        tree_ids: originalTrees.map(t => t.id),
        summary: {
            ...clipboard.summary,
            total_trees: originalTrees.length,
            trees_in_original_area: originalTrees.length,
            related_trees_outside_area: 0
        }
    };
    
    // Temporarily replace clipboard and paste
    const originalClipboard = window.dragClipboard || window.clipboardArea;
    window.dragClipboard = areaTreesOnlyClipboard;
    window.clipboardArea = areaTreesOnlyClipboard;
    
    enableClickToPaste();
    
    // Note: Don't restore clipboard immediately - let user complete the paste operation
    console.log(`🎯 Click-to-paste enabled for ${originalTrees.length} area trees only`);
}
// ✅ ADD THIS NEW FUNCTION for area-only pasting from dialog
function pasteAreaOnlyFromDialog() {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) {
        showStatus('No area in clipboard', 'error');
        return;
    }
    
    console.log('🔲 Pasting area boundary only (no trees)...');
    
    // Create a modified clipboard without any trees
    const areaOnlyClipboard = {
        ...clipboard,
        trees: [],
        trees_data: [],
        selectedTrees: [],
        tree_count: 0,
        tree_ids: [],
        summary: {
            ...clipboard.summary,
            total_trees: 0,
            trees_in_original_area: 0,
            related_trees_outside_area: 0,
            plant_relationships: {
                mother_trees: 0,
                cutting_trees: 0,
                complete_relationships: 0,
                broken_relationships: 0
            }
        }
    };
    
    // Temporarily replace clipboard and paste
    const originalClipboard = window.dragClipboard || window.clipboardArea;
    window.dragClipboard = areaOnlyClipboard;
    window.clipboardArea = areaOnlyClipboard;
    
    enableClickToPaste();
    
    console.log('🎯 Click-to-paste enabled for area boundary only');
}
function clearClipboard() {
    console.log('🗑️ Clearing clipboard...');
    window.dragClipboard = null;
    window.clipboardArea = null;
    
    try {
        localStorage.removeItem('dragClipboard');
    } catch (e) {
        console.warn('⚠️ Could not clear localStorage clipboard:', e);
    }
    
    showStatus('Clipboard cleared', 'info');
}
function enableClickToPaste(areaOnly = false) {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) {
        showStatus('No area in clipboard', 'error');
        return;
    }
    
    clickToPasteMode = true;
    const gridContainer = document.getElementById('gridContainer');
    const instructions = document.getElementById('clickToPasteInstructions');
    const clickBtn = document.getElementById('clickToPasteBtn');
    
    // ✅ ENHANCED: Visual feedback for click mode
    if (gridContainer) {
        gridContainer.classList.add('click-to-paste-mode');
        gridContainer.style.cursor = 'crosshair';
    }
    
    if (instructions) {
        instructions.style.display = 'block';
        instructions.innerHTML = `🎯 <strong>Click Mode Active:</strong> Click on any empty grid cell to paste "${clipboard.name}"`;
    }
    
    // ✅ ENHANCED: Update button to show cancel option
    if (clickBtn) {
        clickBtn.textContent = '❌ Cancel Click Mode';
        clickBtn.onclick = disableClickToPaste;
        clickBtn.className = 'btn-danger';
    }
    
    // ✅ CRITICAL: Re-render grid to remove tree buttons and add paste indicators
    renderGrid();
    
    // ✅ CRITICAL: Add paste listeners to all cells
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.addEventListener('click', handleClickToPasteUnified);
        cell.addEventListener('mouseenter', showPastePreviewUnified);
        cell.addEventListener('mouseleave', hidePastePreviewUnified);
    });
    
    showStatus(`🎯 PASTE MODE: Click on any empty grid cell to paste "${clipboard.name}"`, 'info');
    console.log('✅ Click-to-paste mode enabled');
}

function disableClickToPaste() {
    clickToPasteMode = false;
    
    // Remove click-to-paste styling from grid
    const grid = document.getElementById('treeGrid');
    if (grid) {
        grid.classList.remove('click-to-paste-mode');
    }
    
    // Remove event listeners from grid cells
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.removeEventListener('click', handleClickToPasteUnified);
        cell.removeEventListener('mouseenter', showPastePreviewUnified);
        cell.removeEventListener('mouseleave', hidePastePreviewUnified);
    });
    
    // Remove any paste preview overlays
    document.querySelectorAll('.paste-preview-overlay').forEach(el => el.remove());
    
    // Hide click-to-paste instructions
    const instructions = document.getElementById('clickToPasteInstructions');
    if (instructions) {
        instructions.style.display = 'none';
    }
    
    // Update button text
    const clickToPasteBtn = document.getElementById('clickToPasteBtn');
    if (clickToPasteBtn) {
        clickToPasteBtn.textContent = '🎯 Click to Paste';
    }
    
    console.log('✅ Click-to-paste mode disabled');
}
    const gridContainer = document.getElementById('gridContainer');
    const instructions = document.getElementById('clickToPasteInstructions');
    const clickBtn = document.getElementById('clickToPasteBtn');
    
    // ✅ ENHANCED: Restore normal grid appearance
    if (gridContainer) {
        gridContainer.classList.remove('click-to-paste-mode');
        gridContainer.style.cursor = 'default';
    }
    
    if (instructions) {
        instructions.style.display = 'none';
    }
    
    // ✅ ENHANCED: Restore button to original state
    if (clickBtn) {
        clickBtn.textContent = '🎯 Click to Paste';
        clickBtn.onclick = enableClickToPaste;
        clickBtn.className = 'btn-info';
    }
    
    // ✅ CRITICAL: Remove paste listeners
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.removeEventListener('click', handleClickToPasteUnified);
        cell.removeEventListener('mouseenter', showPastePreviewUnified);
        cell.removeEventListener('mouseleave', hidePastePreviewUnified);
    });
    
    // ✅ CRITICAL: Re-render grid to restore tree buttons
    renderGrid();
    
    hidePastePreviewUnified();
    console.log('✅ Click-to-paste mode disabled, tree-adding restored');
}

function handleClickToPasteUnified(e) {
    if (!clickToPasteMode) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const cell = e.target.closest('.grid-cell');
    if (!cell) return;
    
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    if (isNaN(row) || isNaN(col)) {
        console.error('❌ Invalid cell coordinates');
        return;
    }
    
    console.log(`🎯 Click to paste at position: ${row}, ${col}`);
    
    // Check if cell is occupied
    const existingTree = trees.find(tree => 
        tree.internal_row === row && tree.internal_col === col
    );
    
    if (existingTree) {
        showStatus('Cannot paste on occupied cell', 'error');
        return;
    }
    
    // Execute paste at clicked position
    executePasteAtPosition(row, col);
}
    
    const clipboard = dragClipboard || clipboardArea;
    if (!clipboard) return;
    
    // ✅ CRITICAL: Prevent all other click behaviors
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    
    const cell = e.currentTarget;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    console.log(`🎯 Click-to-paste at (${row}, ${col})`);
    
    // ✅ ENHANCED: Check if cell is empty (no tree)
    const hasTree = cell.classList.contains('occupied') || cell.querySelector('.tree-item');
    if (hasTree) {
        showStatus('Cannot paste here - cell contains a tree', 'error');
        return;
    }
    
    if (isValidPastePosition(row, col, clipboard)) {
        executePasteAtPosition(row, col);
        disableClickToPaste();
    } else {
        showStatus('Cannot paste here - area would overlap existing content or extend outside grid', 'error');
    }
}
function addAreaSafely(newArea, source = 'unknown') {
    // Check if area already exists by ID
    const existingIndex = dragAreas.findIndex(area => area.id === newArea.id);
    
    if (existingIndex === -1) {
        // Area doesn't exist, add it
        dragAreas.push(newArea);
        console.log(`✅ Added new area "${newArea.name}" from ${source}:`, newArea.id);
        return true;
    } else {
        // Area exists, check if we should update it
        const existing = dragAreas[existingIndex];
        
        // Prefer database version over localStorage version
        if (source === 'database' && existing.saved_to_db === false) {
            dragAreas[existingIndex] = newArea;
            console.log(`✅ Updated area "${newArea.name}" with database version:`, newArea.id);
            return true;
        } else {
            console.log(`⚠️ Area "${newArea.name}" already exists, skipping duplicate from ${source}:`, newArea.id);
            return false;
        }
    }
}
function removeDuplicateAreas() {
    const seen = new Set();
    const uniqueAreas = [];
    
    // Sort areas to prefer database versions over local versions
    const sortedAreas = [...dragAreas].sort((a, b) => {
        // Database areas (saved_to_db !== false) come first
        if (a.saved_to_db !== false && b.saved_to_db === false) return -1;
        if (a.saved_to_db === false && b.saved_to_db !== false) return 1;
        return 0;
    });
    
    for (const area of sortedAreas) {
        const key = `${area.name}_${area.minRow}_${area.minCol}_${area.maxRow}_${area.maxCol}`;
        
        if (!seen.has(key)) {
            seen.add(key);
            uniqueAreas.push(area);
        } else {
            console.log(`🗑️ Removing duplicate area: "${area.name}" (ID: ${area.id})`);
        }
    }
    
    const removedCount = dragAreas.length - uniqueAreas.length;
    if (removedCount > 0) {
        dragAreas.length = 0; // Clear array
        dragAreas.push(...uniqueAreas); // Add unique areas
        console.log(`✅ Removed ${removedCount} duplicate areas`);
        return true;
    }
    
    return false;
}
function addClickToPasteListeners() {
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.addEventListener('click', handleClickToPaste);
        cell.addEventListener('mouseenter', showPastePreview);
        cell.addEventListener('mouseleave', hidePastePreview);
    });
}
function removeClickToPasteListeners() {
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.removeEventListener('click', handleClickToPaste);
        cell.removeEventListener('mouseenter', showPastePreview);
        cell.removeEventListener('mouseleave', hidePastePreview);
    });
}


// ✅ STEP 6: Add CSS for better visual feedback
const pasteModeCss = `
<style>
/* ✅ Enhanced paste mode styles */
.click-to-paste-mode {
    border: 3px dashed #17a2b8 !important;
    background: rgba(23, 162, 184, 0.05) !important;
}

.click-to-paste-mode .grid-cell:not(.occupied) {
    border: 2px dashed #17a2b8 !important;
    background: rgba(23, 162, 184, 0.1) !important;
    cursor: crosshair !important;
}

.click-to-paste-mode .grid-cell:not(.occupied):hover {
    background: rgba(23, 162, 184, 0.3) !important;
    border: 2px solid #17a2b8 !important;
    transform: scale(1.02);
    transition: all 0.2s ease;
}

.click-to-paste-mode .grid-cell.occupied {
    background: rgba(220, 53, 69, 0.1) !important;
    border: 2px solid #dc3545 !important;
    cursor: not-allowed !important;
}

.click-to-paste-mode .grid-cell.occupied:hover {
    background: rgba(220, 53, 69, 0.2) !important;
}

.click-to-paste-mode .grid-cell:not(.occupied):hover::after {
    content: "📋 Paste Here";
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #17a2b8;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
}

.click-to-paste-mode .grid-cell.occupied:hover::after {
    content: "❌ Occupied";
    background: #dc3545;
}

/* Hide add-tree buttons in paste mode */
.click-to-paste-mode .add-tree-btn {
    display: none !important;
}

/* Show paste indicators */
.paste-indicator {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 0.7; }
    50% { opacity: 1; }
    100% { opacity: 0.7; }
}
</style>
`;

// ✅ STEP 7: Add the CSS to the page
if (!document.getElementById('paste-mode-styles')) {
    const styleElement = document.createElement('div');
    styleElement.id = 'paste-mode-styles';
    styleElement.innerHTML = pasteModeCss;
    document.head.appendChild(styleElement);
}
function showPastePreview(e) {
    if (!clickToPasteMode || !clipboardArea) return;
    
    const cell = e.currentTarget;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    // Remove existing preview
    if (pastePreviewOverlay) {
        pastePreviewOverlay.remove();
    }
    
    // Check if paste is valid
    const isValid = isValidPastePosition(row, col);
    
    // Create preview overlay
    const grid = document.getElementById('treeGrid');
    const cellRect = cell.getBoundingClientRect();
    const gridRect = grid.getBoundingClientRect();
    
    pastePreviewOverlay = document.createElement('div');
    pastePreviewOverlay.className = `paste-preview-overlay ${isValid ? '' : 'paste-invalid'}`;
    
    const cellSize = cellRect.width;
    const width = clipboardArea.width * cellSize + (clipboardArea.width - 1) * 8; // 8px gap
    const height = clipboardArea.height * cellSize + (clipboardArea.height - 1) * 8;
    
    pastePreviewOverlay.style.cssText = `
        position: absolute;
        left: ${cellRect.left - gridRect.left + grid.scrollLeft}px;
        top: ${cellRect.top - gridRect.top + grid.scrollTop}px;
        width: ${width}px;
        height: ${height}px;
        border: 3px dashed ${isValid ? '#28a745' : '#dc3545'};
        background: ${isValid ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)'};
        pointer-events: none;
        z-index: 100;
        border-radius: 6px;
    `;
    
    // Add label
    const label = document.createElement('div');
    label.textContent = `${clipboardArea.name} (${clipboardArea.width}×${clipboardArea.height})`;
    label.style.cssText = `
        position: absolute;
        top: -25px;
        left: 0;
        background: ${isValid ? '#28a745' : '#dc3545'};
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
    `;
    pastePreviewOverlay.appendChild(label);
    
    grid.appendChild(pastePreviewOverlay);
}
function hidePastePreview() {
    if (pastePreviewOverlay) {
        pastePreviewOverlay.remove();
        pastePreviewOverlay = null;
    }
}
async function deleteArea(areaId) {
    try {
        console.log('🗑️ Attempting to delete area:', areaId);
        
        // Find the area in regular areas first
        let area = areas.find(a => a.id === areaId);
        let isRegularArea = true;
        let areaType = 'regular area';
        
        // If not found in regular areas, check drag areas
        if (!area) {
            area = dragAreas.find(a => a.id === areaId);
            isRegularArea = false;
            areaType = 'drag area';
        }
        
        if (!area) {
            console.error('❌ Area not found:', areaId);
            showStatus('Area not found', 'error');
            return;
        }
        
        console.log(`🔍 Found ${areaType}: "${area.name}"`);
        
        // ✅ ENHANCED: Show confirmation dialog with area details
        const treeCount = area.tree_count || area.trees?.length || 0;
        const confirmMessage = `Are you sure you want to delete ${areaType} "${area.name}"?\n\n` +
                              `📊 Details:\n` +
                              `• Type: ${areaType}\n` +
                              `• Trees: ${treeCount}\n` +
                              `• Size: ${area.width || 'unknown'}×${area.height || 'unknown'}\n\n` +
                              `⚠️ This will remove the area but keep the trees.`;
        
        if (!confirm(confirmMessage)) {
            console.log('❌ Area deletion canceled by user');
            return;
        }
        
        // ✅ CRITICAL: Show loading status
        showStatus(`Deleting ${areaType} "${area.name}"...`, 'info');
        
        try {
            let deleteResponse;
            let apiUrl;
            
            if (isRegularArea) {
                // ✅ Delete regular area via API
                apiUrl = `/api/delete_regular_area/${domeId}/${areaId}`;
                console.log(`🔄 Deleting regular area via: ${apiUrl}`);
                
                deleteResponse = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
            } else {
                // ✅ Delete drag area via API
                apiUrl = `/api/delete_drag_area/${domeId}/${areaId}`;
                console.log(`🔄 Deleting drag area via: ${apiUrl}`);
                
                deleteResponse = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
            }
            
            // ✅ ENHANCED: Handle API response
            console.log(`📡 Delete API response status: ${deleteResponse.status}`);
            
            if (deleteResponse.ok) {
                let result;
                try {
                    result = await deleteResponse.json();
                    console.log('📡 Delete API result:', result);
                } catch (parseError) {
                    console.warn('⚠️ Could not parse response as JSON, assuming success');
                    result = { success: true, message: 'Area deleted successfully' };
                }
                
                if (result.success !== false) { // Accept undefined as success
                    // ✅ CRITICAL: Remove from local arrays only after successful backend deletion
                    if (isRegularArea) {
                        const originalLength = areas.length;
                        areas = areas.filter(a => a.id !== areaId);
                        console.log(`✅ Removed from local regular areas array (${originalLength} -> ${areas.length})`);
                        
                        // Update regular areas display
                        if (typeof updateAreasDisplay === 'function') {
                            updateAreasDisplay();
                        }
                        if (typeof renderAreas === 'function') {
                            renderAreas();
                        }
                        if (typeof saveLineAreasToStorage === 'function') {
                            saveLineAreasToStorage();
                        }
                        
                    } else {
                        const originalLength = dragAreas.length;
                        dragAreas = dragAreas.filter(a => a.id !== areaId);
                        console.log(`✅ Removed from local drag areas array (${originalLength} -> ${dragAreas.length})`);
                        
                        // Update drag areas display
                        if (typeof updateDragAreasDisplay === 'function') {
                            updateDragAreasDisplay();
                        }
                        if (typeof renderDragAreas === 'function') {
                            renderDragAreas();
                        }
                        if (typeof saveDragAreasToStorage === 'function') {
                            saveDragAreasToStorage();
                        }
                    }
                    
                    // ✅ CRITICAL: Re-render grid to remove area visualization
                    renderGrid();
                    
                    // Update stats
                    if (typeof updateStats === 'function') {
                        updateStats();
                    }
                    
                    // ✅ ENHANCED: Success message with details
                    const successMessage = result.message || `${areaType.charAt(0).toUpperCase() + areaType.slice(1)} "${area.name}" deleted successfully`;
                    showStatus(successMessage, 'success');
                    
                    console.log(`✅ ${areaType} deleted successfully from both backend and frontend`);
                    
                } else {
                    // Backend returned success: false
                    console.error('❌ Backend deletion failed:', result.error);
                    showStatus(`Failed to delete ${areaType}: ${result.error}`, 'error');
                }
                
            } else {
                // HTTP error status
                let errorMessage = `HTTP ${deleteResponse.status}`;
                
                try {
                    const errorResult = await deleteResponse.json();
                    errorMessage = errorResult.error || errorMessage;
                } catch (parseError) {
                    console.warn('⚠️ Could not parse error response');
                    
                    // For 404 errors, assume the area was already deleted
                    if (deleteResponse.status === 404) {
                        console.log('⚠️ Area not found in backend (404), removing from frontend anyway');
                        
                        // Remove from frontend
                        if (isRegularArea) {
                            areas = areas.filter(a => a.id !== areaId);
                            if (typeof updateAreasDisplay === 'function') {
                                updateAreasDisplay();
                            }
                        } else {
                            dragAreas = dragAreas.filter(a => a.id !== areaId);
                            if (typeof updateDragAreasDisplay === 'function') {
                                updateDragAreasDisplay();
                            }
                        }
                        
                        renderGrid();
                        showStatus(`${areaType.charAt(0).toUpperCase() + areaType.slice(1)} "${area.name}" removed (was not found in database)`, 'success');
                        return;
                    }
                }
                
                console.error(`❌ Delete API failed with status ${deleteResponse.status}:`, errorMessage);
                showStatus(`Failed to delete ${areaType}: ${errorMessage}`, 'error');
            }
            
        } catch (networkError) {
            console.error('❌ Network error during deletion:', networkError);
            showStatus(`Network error deleting ${areaType}: ${networkError.message}`, 'error');
        }
        
    } catch (error) {
        console.error('❌ Unexpected error deleting area:', error);
        showStatus('Unexpected error deleting area', 'error');
    }
}

// ✅ ENHANCED: Debounced force rendering to prevent multiple rapid calls
let forceRenderTimeout;
function debouncedForceRender() {
    if (forceRenderTimeout) {
        clearTimeout(forceRenderTimeout);
    }
    
    forceRenderTimeout = setTimeout(() => {
        console.log('🔄 Force rendering all areas after backend load...');
        if (typeof forceRenderAllAreas === 'function') {
            forceRenderAllAreas();
        }
        forceRenderTimeout = null;
    }, 100);
}

// Use debounced version
debouncedForceRender();
function isValidPastePosition(row, col) {
    if (!clipboardArea) return false;
    
    // Check grid boundaries
    if (row + clipboardArea.height > currentRows || 
        col + clipboardArea.width > currentCols ||
        row < 0 || col < 0) {
        return false;
    }
    
    // Check for existing trees in the paste area
    for (let r = row; r < row + clipboardArea.height; r++) {
        for (let c = col; c < col + clipboardArea.width; c++) {
            const existingTree = trees.find(t => t.internal_row === r && t.internal_col === c);
            if (existingTree) {
                return false;
            }
        }
    }
    
    return true;
}
function checkPasteAreaAvailable(startRow, startCol, clipboard) {
    console.log(`🔍 Checking paste availability at (${startRow}, ${startCol})`);
    
    // If no trees to paste, area is always available
    if (!clipboard.trees || clipboard.trees.length === 0) {
        console.log('✅ No trees to paste - area available');
        return { available: true, conflicts: [] };
    }
    
    const conflicts = [];
    
    // Check each tree position
    for (const treeData of clipboard.trees) {
        // ✅ ENHANCED: Better relative position detection
        let relativeRow = 0;
        let relativeCol = 0;
        
        // Try multiple field names for relative positions
        if (treeData.relativeRow !== undefined && treeData.relativeCol !== undefined) {
            relativeRow = treeData.relativeRow;
            relativeCol = treeData.relativeCol;
        } else if (treeData.relative_row !== undefined && treeData.relative_col !== undefined) {
            relativeRow = treeData.relative_row;
            relativeCol = treeData.relative_col;
        } else if (treeData.row !== undefined && treeData.col !== undefined) {
            // Calculate relative from absolute positions
            const clipboardMinRow = clipboard.minRow || clipboard.min_row || 0;
            const clipboardMinCol = clipboard.minCol || clipboard.min_col || 0;
            relativeRow = treeData.row - clipboardMinRow;
            relativeCol = treeData.col - clipboardMinCol;
        } else if (treeData.internal_row !== undefined && treeData.internal_col !== undefined) {
            // Calculate relative from internal positions
            const clipboardMinRow = clipboard.minRow || clipboard.min_row || 0;
            const clipboardMinCol = clipboard.minCol || clipboard.min_col || 0;
            relativeRow = treeData.internal_row - clipboardMinRow;
            relativeCol = treeData.internal_col - clipboardMinCol;
        }
        
        const newRow = startRow + relativeRow;
        const newCol = startCol + relativeCol;
        
        console.log(`🌳 Checking tree "${treeData.name}" at relative (${relativeRow}, ${relativeCol}) -> absolute (${newRow}, ${newCol})`);
        
        // ✅ ENHANCED: Check if position is within dome bounds
        const maxRows = currentRows || 10;  // Use global currentRows or default
        const maxCols = currentCols || 10;  // Use global currentCols or default
        
        if (newRow < 0 || newRow >= maxRows || newCol < 0 || newCol >= maxCols) {
            console.warn(`❌ Tree "${treeData.name}" would be outside bounds at (${newRow}, ${newCol})`);
            conflicts.push({
                treeName: treeData.name,
                position: `(${newRow}, ${newCol})`,
                reason: 'outside_bounds',
                bounds: `Grid is ${maxCols}×${maxRows}`
            });
            continue;
        }
        
        // ✅ ENHANCED: Check if position is occupied by existing tree
        let existingTree = null;
        
        // Try to find existing tree using global trees array
        if (typeof trees !== 'undefined' && Array.isArray(trees)) {
            existingTree = trees.find(t => 
                t.internal_row === newRow && t.internal_col === newCol
            );
        }
        
        // Fallback: check using DOM elements if trees array not available
        if (!existingTree && typeof document !== 'undefined') {
            const cellElement = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
            if (cellElement && cellElement.querySelector('.tree-item')) {
                existingTree = { name: 'Unknown Tree', id: 'unknown' };
            }
        }
        
        if (existingTree) {
            console.warn(`❌ Tree "${treeData.name}" conflicts with existing tree "${existingTree.name}" at (${newRow}, ${newCol})`);
            conflicts.push({
                treeName: treeData.name,
                position: `(${newRow}, ${newCol})`,
                reason: 'position_occupied',
                existingTree: existingTree.name || 'Unknown Tree'
            });
        } else {
            console.log(`✅ Tree "${treeData.name}" can be placed at (${newRow}, ${newCol})`);
        }
    }
    
    const isAvailable = conflicts.length === 0;
    console.log(`🎯 Paste check result: ${isAvailable ? 'AVAILABLE' : 'CONFLICTS'} (${conflicts.length} conflicts)`);
    
    if (conflicts.length > 0) {
        console.log('❌ Conflicts found:', conflicts);
    }
    
    return {
        available: isAvailable,
        conflicts: conflicts
    };
}

// ✅ ADD THIS FUNCTION to show conflict resolution dialog
function showPasteConflictDialog(conflicts, clipboard, startRow, startCol) {
    console.log('🚨 Showing paste conflict dialog:', conflicts);
    
    const modal = document.createElement('div');
    modal.className = 'paste-conflict-modal';
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 600px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                max-height: 80vh;
                overflow-y: auto;
            " onclick="event.stopPropagation();">
                <h5 style="margin: 0 0 20px 0; color: #dc3545;">⚠️ Paste Conflicts Detected</h5>
                
                <p>Cannot paste "${clipboard.name}" at position (${startRow}, ${startCol}) due to conflicts:</p>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 15px 0; max-height: 200px; overflow-y: auto;">
                    ${conflicts.map(conflict => `
                        <div style="margin-bottom: 10px; padding: 8px; background: white; border-radius: 4px; border-left: 4px solid #dc3545;">
                            <strong>${conflict.treeName}</strong> → Position ${conflict.position}<br>
                            <small style="color: #666;">
                                ${conflict.reason === 'position_occupied' 
                                    ? `Occupied by "${conflict.existingTree}"` 
                                    : conflict.reason === 'outside_bounds'
                                    ? `Outside dome bounds (${conflict.bounds})`
                                    : 'Unknown conflict'}
                            </small>
                        </div>
                    `).join('')}
                </div>
                
                <div style="margin: 20px 0;">
                    <h6>Choose an option:</h6>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                        <button onclick="findAlternativePastePosition('${clipboard.name}', ${startRow}, ${startCol}); this.closest('.paste-conflict-modal').remove();" style="
                            padding: 10px 15px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">🔍 Find Alternative Position</button>
                        
                        <button onclick="pasteAreaOnly('${clipboard.name}', ${startRow}, ${startCol}); this.closest('.paste-conflict-modal').remove();" style="
                            padding: 10px 15px;
                            background: #28a745;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">📦 Paste Area Only (No Trees)</button>
                        
                        <button onclick="this.closest('.paste-conflict-modal').remove();" style="
                            padding: 10px 15px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">❌ Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}


function pasteAreaOnly(clipboardName, startRow, startCol) {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) return;
    
    console.log('📦 Pasting area only (no trees)...');
    
    // Create a modified clipboard without trees
    const areaOnlyClipboard = {
        ...clipboard,
        trees: [],
        trees_data: [],
        tree_count: 0,
        summary: {
            ...clipboard.summary,
            total_trees: 0,
            plant_relationships: {
                mother_trees: 0,
                cutting_trees: 0,
                complete_relationships: 0,
                broken_relationships: 0
            }
        }
    };
    
    // Temporarily replace clipboard and paste
    const originalClipboard = window.dragClipboard || window.clipboardArea;
    window.dragClipboard = areaOnlyClipboard;
    window.clipboardArea = areaOnlyClipboard;
    
    executePasteAtPosition(startRow, startCol).then(() => {
        // Restore original clipboard
        window.dragClipboard = originalClipboard;
        window.clipboardArea = originalClipboard;
    });
}

// ✅ ENHANCED: Better debug version of conflict checking
function debugPasteConflicts(startRow, startCol, clipboard) {
    console.log('🔍 DEBUG: Checking paste conflicts...');
    console.log('📋 Clipboard data:', clipboard);
    console.log('🎯 Paste position:', { startRow, startCol });
    console.log('🌳 Trees in clipboard:', clipboard.trees?.length || 0);
    console.log('📐 Grid dimensions:', { currentRows, currentCols });
    console.log('🌲 Existing trees:', trees?.length || 0);
    
    if (clipboard.trees && clipboard.trees.length > 0) {
        console.log('🌳 Tree details:');
        clipboard.trees.forEach((tree, index) => {
            console.log(`  ${index + 1}. "${tree.name}" - relative: (${tree.relativeRow || tree.relative_row || 'undefined'}, ${tree.relativeCol || tree.relative_col || 'undefined'})`);
        });
    }
    
    const result = checkPasteAreaAvailable(startRow, startCol, clipboard);
    console.log('🎯 Final conflict check result:', result);
    
    return result;
}
async function executePasteAtPosition(targetRow, targetCol, pasteMode = 'all') {
    try {
        console.log(`🎯 Executing paste at position (${targetRow}, ${targetCol}) with mode: ${pasteMode}`);
        
        if (!window.dragClipboard) {
            showStatus('No clipboard data available', 'error');
            return;
        }
        
        const clipboard = window.dragClipboard;
        console.log('📋 Clipboard data:', clipboard);
        
        // ✅ ENHANCED: Analyze clipboard for orphaned cuttings
        const clipboardAnalysis = analyzeClipboardForOrphanedCuttings(clipboard);
        console.log('🔍 Clipboard analysis:', clipboardAnalysis);
        
        // ✅ CRITICAL: Handle orphaned cuttings before paste
        let finalClipboard = clipboard;
        if (clipboardAnalysis.hasOrphanedCuttings && pasteMode === 'all') {
            const orphanHandling = await handleOrphanedCuttingsDialog(clipboardAnalysis);
            if (!orphanHandling) {
                console.log('❌ Paste cancelled due to orphaned cuttings');
                return;
            }
            
            if (orphanHandling.mode === 'find_mothers') {
                finalClipboard = await findAndLinkMothersForOrphans(clipboard, clipboardAnalysis);
            } else if (orphanHandling.mode === 'convert_to_independent') {
                finalClipboard = convertOrphansToIndependent(clipboard, clipboardAnalysis);
            }
            // 'keep_orphaned' mode uses original clipboard
        }
        
        // Determine trees to paste based on mode
        let treesToPaste = [];
        switch (pasteMode) {
            case 'all':
                treesToPaste = finalClipboard.trees_data || finalClipboard.trees || [];
                break;
            case 'area_only':
                treesToPaste = finalClipboard.trees_data?.filter(t => t.isInOriginalArea !== false) || [];
                break;
            case 'boundary':
                treesToPaste = [];
                break;
            default:
                treesToPaste = finalClipboard.trees_data || finalClipboard.trees || [];
        }
        
        console.log(`🌳 Pasting ${treesToPaste.length} trees with mode: ${pasteMode}`);
        
        if (treesToPaste.length === 0 && pasteMode !== 'boundary') {
            showStatus('No trees to paste', 'warning');
            return;
        }
        
        // ✅ ENHANCED: Prepare paste data with relationship handling
        const pasteData = {
            name: finalClipboard.name || 'Pasted Area',
            color: finalClipboard.color || '#007bff',
            minRow: targetRow,
            maxRow: targetRow + (finalClipboard.height || 1) - 1,
            minCol: targetCol,
            maxCol: targetCol + (finalClipboard.width || 1) - 1,
            width: finalClipboard.width || 1,
            height: finalClipboard.height || 1,
            trees_data: treesToPaste.map(tree => ({
                ...tree,
                internal_row: targetRow + (tree.relativeRow || tree.relative_row || 0),
                internal_col: targetCol + (tree.relativeCol || tree.relative_col || 0)
            })),
            // ✅ CRITICAL: Enhanced relationship metadata
            relationship_metadata: {
                ...finalClipboard.relationship_mapping,
                orphan_handling: clipboardAnalysis.hasOrphanedCuttings ? {
                    mode: orphanHandling?.mode || 'keep_orphaned',
                    orphaned_cuttings: clipboardAnalysis.orphanedCuttings.map(c => ({
                        cutting_id: c.id,
                        cutting_name: c.name,
                        original_mother_id: c.mother_plant_id,
                        new_handling: orphanHandling?.mode || 'keep_orphaned'
                    }))
                } : null
            }
        };
        
        console.log('📤 Sending paste data to backend:', pasteData);
        showStatus('Pasting area with relationship handling...', 'info');
        
        // ✅ ENHANCED: Use relationship-aware paste endpoint
        const response = await fetch(`/paste_drag_area_with_relationships/${domeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(pasteData)
        });
        
        console.log('📥 Backend response status:', response.status);
        
        const result = await response.json();
        console.log('📥 Backend response:', result);
        
        if (result.success) {
            // ✅ ENHANCED: Handle successful paste with relationship updates
            await handleSuccessfulPasteWithRelationshipUpdates(result, pasteData, clipboardAnalysis);
        } else {
            console.error('❌ Backend error response:', result);
            showStatus(`Paste failed: ${result.error}`, 'error');
        }
        
    } catch (error) {
        console.error('❌ Error pasting area:', error);
        showStatus('Error pasting area: ' + error.message, 'error');
    }
}
async function handleOrphanedCuttingsDialog(analysis) {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'orphan-handling-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10002;
            " onclick="this.remove(); resolve(null);">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 600px;
                    width: 90%;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h4 style="margin: 0 0 20px 0; color: #dc3545; display: flex; align-items: center; gap: 10px;">
                        ⚠️ Orphaned Cutting Trees Detected
                    </h4>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #ffc107;">
                        <div style="font-size: 14px; margin-bottom: 10px;">
                            <strong>Issue:</strong> ${analysis.orphanedCount} cutting tree(s) in the clipboard don't have their mother trees included.
                        </div>
                        <div style="font-size: 13px; color: #856404;">
                            <strong>Orphaned Cuttings:</strong><br>
                            ${analysis.orphanedCuttings.map(c => `• ${c.name} (missing mother ID: ${c.mother_plant_id})`).join('<br>')}
                        </div>
                        ${analysis.availableMotherCount > 0 ? `
                        <div style="margin-top: 10px; font-size: 13px; color: #155724;">
                            <strong>Available mothers in this dome:</strong> ${analysis.availableMotherCount} mother trees
                        </div>
                        ` : ''}
                    </div>
                    
                    <div style="display: grid; gap: 15px; margin-bottom: 25px;">
                        ${analysis.availableMotherCount > 0 ? `
                        <button class="orphan-option" data-mode="find_mothers" style="
                            padding: 15px 20px;
                            background: #28a745;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🔗</span>
                            <div>
                                <div style="margin-bottom: 4px;">Link to Existing Mother Trees</div>
                                <small style="opacity: 0.8; font-weight: normal;">Try to find matching mother trees in this dome and link the cuttings</small>
                            </div>
                        </button>
                        ` : ''}
                        
                        <button class="orphan-option" data-mode="convert_to_independent" style="
                            padding: 15px 20px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🌱</span>
                            <div>
                                <div style="margin-bottom: 4px;">Convert to Independent Trees</div>
                                <small style="opacity: 0.8; font-weight: normal;">Remove cutting relationships and make them independent trees</small>
                            </div>
                        </button>
                        
                        <button class="orphan-option" data-mode="keep_orphaned" style="
                            padding: 15px 20px;
                            background: #ffc107;
                            color: #212529;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">⚠️</span>
                            <div>
                                <div style="margin-bottom: 4px;">Keep as Orphaned Cuttings</div>
                                <small style="opacity: 0.8; font-weight: normal;">Paste as-is with broken relationships (not recommended)</small>
                            </div>
                        </button>
                    </div>
                    
                    <div style="padding-top: 15px; border-top: 1px solid #eee;">
                        <button onclick="this.closest('.orphan-handling-modal').remove(); resolve(null);" style="
                            width: 100%;
                            padding: 12px;
                            background: #dc3545;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                        ">Cancel Paste</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Add click handlers
        const optionButtons = modal.querySelectorAll('.orphan-option');
        optionButtons.forEach(button => {
            button.addEventListener('click', () => {
                const mode = button.dataset.mode;
                modal.remove();
                resolve({ mode: mode });
            });
            
            // Add hover effects
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'translateY(-2px)';
                button.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'translateY(0)';
                button.style.boxShadow = 'none';
            });
        });
        
        // Keyboard navigation
        modal.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                resolve(null);
            }
        });
        
        // Make resolve available globally for the cancel button
        window.resolve = resolve;
    });
}
async function findAndLinkMothersForOrphans(clipboard, analysis) {
    console.log('🔗 Finding mothers for orphaned cuttings...');
    
    const treesData = [...(clipboard.trees_data || clipboard.trees || [])];
    const availableMothers = analysis.availableMothers;
    
    // Try to match orphaned cuttings with available mothers
    for (const orphan of analysis.orphanedCuttings) {
        console.log(`🔍 Looking for mother for orphaned cutting: ${orphan.name}`);
        
        // Strategy 1: Match by breed
        let matchedMother = availableMothers.find(m => 
            m.breed && orphan.breed && 
            m.breed.toLowerCase() === orphan.breed.toLowerCase()
        );
        
        // Strategy 2: Match by name similarity
        if (!matchedMother) {
            matchedMother = availableMothers.find(m => 
                m.name && orphan.name &&
                (m.name.toLowerCase().includes(orphan.name.toLowerCase()) ||
                 orphan.name.toLowerCase().includes(m.name.toLowerCase()))
            );
        }
        
        // Strategy 3: Use first available mother of same breed
        if (!matchedMother && orphan.breed) {
            matchedMother = availableMothers.find(m => 
                m.breed && m.breed.toLowerCase() === orphan.breed.toLowerCase()
            );
        }
        
        // Strategy 4: Use any available mother (last resort)
        if (!matchedMother && availableMothers.length > 0) {
            matchedMother = availableMothers[0];
        }
        
        if (matchedMother) {
            console.log(`✅ Matched orphan "${orphan.name}" with mother "${matchedMother.name}"`);
            
            // Update the orphan's mother relationship
            const orphanIndex = treesData.findIndex(t => t.id === orphan.id);
            if (orphanIndex >= 0) {
                treesData[orphanIndex] = {
                    ...treesData[orphanIndex],
                    mother_plant_id: matchedMother.id,
                    mother_tree_id: matchedMother.id,
                    plant_type: 'cutting',
                    relationship_metadata: {
                        ...treesData[orphanIndex].relationship_metadata,
                        original_mother_id: orphan.mother_plant_id,
                        new_mother_id: matchedMother.id,
                        relationship_restored: true,
                        matching_strategy: 'auto_matched'
                    }
                };
            }
        } else {
            console.log(`⚠️ No suitable mother found for orphan "${orphan.name}"`);
        }
    }
    
    // Return updated clipboard
    return {
        ...clipboard,
        trees_data: treesData,
        trees: treesData
    };
}

// ✅ NEW: Convert orphaned cuttings to independent trees
function convertOrphansToIndependent(clipboard, analysis) {
    console.log('🌱 Converting orphaned cuttings to independent trees...');
    
    const treesData = [...(clipboard.trees_data || clipboard.trees || [])];
    
    for (const orphan of analysis.orphanedCuttings) {
        const orphanIndex = treesData.findIndex(t => t.id === orphan.id);
        if (orphanIndex >= 0) {
            treesData[orphanIndex] = {
                ...treesData[orphanIndex],
                plant_type: 'mother', // Convert to independent (mother type)
                mother_plant_id: null,
                mother_tree_id: null,
                cutting_notes: `Former cutting from mother ID ${orphan.mother_plant_id}. ${treesData[orphanIndex].cutting_notes || ''}`.trim(),
                relationship_metadata: {
                    ...treesData[orphanIndex].relationship_metadata,
                    original_mother_id: orphan.mother_plant_id,
                    converted_to_independent: true,
                    conversion_reason: 'orphaned_cutting'
                }
            };
            
            console.log(`✅ Converted orphan "${orphan.name}" to independent tree`);
        }
    }
    
    return {
        ...clipboard,
        trees_data: treesData,
        trees: treesData
    };
}

// ✅ ENHANCED: Handle successful paste with relationship updates
async function handleSuccessfulPasteWithRelationshipUpdates(result, pasteData, clipboardAnalysis) {
    console.log('✅ Handling successful paste with relationship updates...');
    console.log('📊 Paste result:', result);
    
    // ✅ CRITICAL: Force refresh all mother tree relationships if relationships were updated
    if (result.relationship_stats && result.relationship_stats.mothers_updated) {
        console.log('🔄 Forcing refresh of mother tree relationships...');
        
        for (const motherUpdate of result.relationship_stats.mothers_updated) {
            console.log(`🌳 Mother ${motherUpdate.mother_name} now has ${motherUpdate.cutting_count} cuttings`);
        }
        
        // Clear any cached relationship data
        if (window.treeRelationshipsCache) {
            window.treeRelationshipsCache = {};
        }
    }
    
    // ✅ ENHANCED: Show detailed success message with relationship information
    let successMessage = `Area "${pasteData.name}" pasted successfully!`;
    
    if (result.trees_created) {
        successMessage += `\n📊 Trees: ${result.trees_created} created`;
    }
    
    // ✅ ENHANCED: Show relationship statistics
    if (result.relationship_stats) {
        const stats = result.relationship_stats;
        if (stats.relationships_preserved > 0) {
            successMessage += `\n🔗 Relationships: ${stats.relationships_preserved} preserved`;
        }
        if (stats.relationships_broken > 0) {
            successMessage += `, ${stats.relationships_broken} broken`;
        }
        if (stats.mothers_created > 0) {
            successMessage += `\n🌳 Mothers: ${stats.mothers_created} created`;
        }
        if (stats.cuttings_created > 0) {
            successMessage += `\n✂️ Cuttings: ${stats.cuttings_created} created`;
        }
        if (stats.mothers_updated && stats.mothers_updated.length > 0) {
            successMessage += `\n🔄 Updated: ${stats.mothers_updated.length} mother trees`;
        }
    }
    
    // ✅ ENHANCED: Show orphan handling results
    if (clipboardAnalysis.hasOrphanedCuttings) {
        successMessage += `\n⚠️ Orphaned cuttings: ${clipboardAnalysis.orphanedCount} handled`;
    }
    
    showStatus(successMessage, 'success');
    
    // ✅ CRITICAL: Refresh the entire page to reload trees and areas with relationships
    console.log('🔄 Refreshing page to show pasted trees with updated relationships...');
    setTimeout(() => {
        window.location.reload();
    }, 2500); // Give user time to see success message
    
    console.log('✅ Paste completed successfully with relationships - page will refresh');
}
function analyzeClipboardForOrphanedCuttings(clipboard) {
const treesData = clipboard.trees_data || clipboard.trees || [];
const motherIds = new Set(treesData.filter(t => t.plant_type === 'mother').map(t => t.id));

// ✅ CRITICAL: Check if this is a "copy with relationships" operation
const isRelationshipPreservationMode = clipboard.clipboard_source === 'frontend_with_relationships' || 
clipboard.selection_mode === 'with_relationships' ||
clipboard.includes_relationships === true;

console.log('🔍 Analyzing clipboard for orphaned cuttings:', {
clipboard_source: clipboard.clipboard_source,
selection_mode: clipboard.selection_mode,
includes_relationships: clipboard.includes_relationships,
isRelationshipPreservationMode: isRelationshipPreservationMode
});

// ✅ FIXED: In relationship preservation mode, don't treat cuttings as orphaned
// if they have a valid mother_plant_id - we want to preserve the original relationship
let orphanedCuttings = [];

if (isRelationshipPreservationMode) {
// In relationship preservation mode, only consider cuttings truly orphaned 
// if they don't have a mother_plant_id at all
orphanedCuttings = treesData.filter(tree =>
tree.plant_type === 'cutting' && !tree.mother_plant_id
);
console.log('🔗 Relationship preservation mode: Only considering cuttings without mother_plant_id as orphaned');
} else {
// In normal mode, consider cuttings orphaned if their mother is not in the selection
orphanedCuttings = treesData.filter(tree =>
tree.plant_type === 'cutting' &&
tree.mother_plant_id &&
!motherIds.has(tree.mother_plant_id)
);
console.log('📋 Normal copy mode: Considering cuttings orphaned if mother not in selection');
}

const availableMothersInDome = trees.filter(t => t.plant_type === 'mother');

console.log('📊 Orphaned cutting analysis result:', {
totalCuttings: treesData.filter(t => t.plant_type === 'cutting').length,
orphanedCount: orphanedCuttings.length,
availableMotherCount: availableMothersInDome.length
});

return {
hasOrphanedCuttings: orphanedCuttings.length > 0,
orphanedCuttings: orphanedCuttings,
orphanedCount: orphanedCuttings.length,
availableMothers: availableMothersInDome,
availableMotherCount: availableMothersInDome.length,
totalTrees: treesData.length,
motherTrees: treesData.filter(t => t.plant_type === 'mother'),
cuttingTrees: treesData.filter(t => t.plant_type === 'cutting'),
isRelationshipPreservationMode: isRelationshipPreservationMode
};
}

async function processTreesWithRelationships(treesToPaste, startRow, startCol, clipboard) {
    console.log('🔗 Processing trees with comprehensive relationship mapping...');
    
    const processedTrees = [];
    const relationshipMapping = {
        motherCuttingPairs: [],
        oldToNewMapping: {},
        originalMothers: [],
        originalCuttings: [],
        positionMapping: {}
    };
    
    // Step 1: Identify mothers and cuttings with detailed analysis
    const motherTrees = treesToPaste.filter(t => t.plant_type === 'mother');
    const cuttingTrees = treesToPaste.filter(t => t.plant_type === 'cutting');
    const otherTrees = treesToPaste.filter(t => !t.plant_type || (t.plant_type !== 'mother' && t.plant_type !== 'cutting'));
    
    console.log(`🔍 Tree analysis: ${motherTrees.length} mothers, ${cuttingTrees.length} cuttings, ${otherTrees.length} others`);
    
    // ✅ ENHANCED: Store original tree information with positions
    relationshipMapping.originalMothers = motherTrees.map(t => ({
        id: t.id,
        name: t.name,
        breed: t.breed || '',
        original_position: { row: t.internal_row, col: t.internal_col },
        cutting_count: cuttingTrees.filter(c => c.mother_plant_id === t.id).length
    }));
    
    relationshipMapping.originalCuttings = cuttingTrees.map(t => ({
        id: t.id,
        name: t.name,
        breed: t.breed || '',
        mother_id: t.mother_plant_id,
        mother_name: motherTrees.find(m => m.id === t.mother_plant_id)?.name || 'Unknown',
        original_position: { row: t.internal_row, col: t.internal_col },
        cutting_notes: t.cutting_notes || ''
    }));
    
    // Step 2: Process all trees and calculate new positions
    for (let i = 0; i < treesToPaste.length; i++) {
        const treeData = treesToPaste[i];
        
        // ✅ ENHANCED: Better relative position calculation
        let relativeRow = 0;
        let relativeCol = 0;
        
        // Try multiple position formats
        if (treeData.relativeRow !== undefined && treeData.relativeCol !== undefined) {
            relativeRow = treeData.relativeRow;
            relativeCol = treeData.relativeCol;
        } else if (treeData.relative_row !== undefined && treeData.relative_col !== undefined) {
            relativeRow = treeData.relative_row;
            relativeCol = treeData.relative_col;
        } else if (treeData.row !== undefined && treeData.col !== undefined) {
            const clipboardMinRow = clipboard.minRow || clipboard.min_row || 0;
            const clipboardMinCol = clipboard.minCol || clipboard.min_col || 0;
            relativeRow = treeData.row - clipboardMinRow;
            relativeCol = treeData.col - clipboardMinCol;
        } else if (treeData.internal_row !== undefined && treeData.internal_col !== undefined) {
            const clipboardMinRow = clipboard.minRow || clipboard.min_row || 0;
            const clipboardMinCol = clipboard.minCol || clipboard.min_col || 0;
            relativeRow = treeData.internal_row - clipboardMinRow;
            relativeCol = treeData.internal_col - clipboardMinCol;
        }
        
        const absoluteRow = startRow + relativeRow;
        const absoluteCol = startCol + relativeCol;
        
        // ✅ ENHANCED: Create comprehensive tree data with relationship info
        const processedTreeData = {
            // Basic tree info
            name: treeData.name || `Tree ${i + 1}`,
            breed: treeData.breed || '',
            life_days: treeData.life_days || 0,
            info: treeData.info || '',
            image_url: treeData.image_url || '',
            
            // Position data
            internal_row: absoluteRow,
            internal_col: absoluteCol,
            relativeRow: relativeRow,
            relativeCol: relativeCol,
            
            // ✅ CRITICAL: Plant relationship data (will be updated with new IDs later)
            plant_type: treeData.plant_type || 'mother',
            mother_plant_id: treeData.mother_plant_id || null, // Will be mapped to new ID
            cutting_notes: treeData.cutting_notes || '',
            
            // ✅ ENHANCED: Comprehensive relationship metadata for backend processing
            relationship_metadata: {
                original_tree_id: treeData.id,
                original_mother_id: treeData.mother_plant_id,
                is_in_original_area: treeData.isInOriginalArea !== false,
                needs_mother_mapping: treeData.plant_type === 'cutting' && treeData.mother_plant_id,
                paste_order: i,
                paste_timestamp: new Date().toISOString(),
                original_position: {
                    row: treeData.internal_row,
                    col: treeData.internal_col
                },
                new_position: {
                    row: absoluteRow,
                    col: absoluteCol
                }
            }
        };
        
        processedTrees.push(processedTreeData);
        
        // ✅ ENHANCED: Store position mapping for relationship fixing
        relationshipMapping.positionMapping[treeData.id] = {
            original: { row: treeData.internal_row, col: treeData.internal_col },
            new: { row: absoluteRow, col: absoluteCol },
            tree_name: treeData.name
        };
        
        // ✅ CRITICAL: Track relationship pairs for comprehensive mapping
        if (treeData.plant_type === 'cutting' && treeData.mother_plant_id) {
            const motherInClipboard = treesToPaste.find(t => t.id === treeData.mother_plant_id);
            
            if (motherInClipboard) {
                // Calculate mother's new position
                let motherRelativeRow = 0;
                let motherRelativeCol = 0;
                
                if (motherInClipboard.relativeRow !== undefined && motherInClipboard.relativeCol !== undefined) {
                    motherRelativeRow = motherInClipboard.relativeRow;
                    motherRelativeCol = motherInClipboard.relativeCol;
                } else if (motherInClipboard.relative_row !== undefined && motherInClipboard.relative_col !== undefined) {
                    motherRelativeRow = motherInClipboard.relative_row;
                    motherRelativeCol = motherInClipboard.relative_col;
                } else {
                    const clipboardMinRow = clipboard.minRow || clipboard.min_row || 0;
                    const clipboardMinCol = clipboard.minCol || clipboard.min_col || 0;
                    motherRelativeRow = motherInClipboard.internal_row - clipboardMinRow;
                    motherRelativeCol = motherInClipboard.internal_col - clipboardMinCol;
                }
                
                relationshipMapping.motherCuttingPairs.push({
                    cutting_original_id: treeData.id,
                    cutting_name: treeData.name,
                    cutting_breed: treeData.breed || '',
                    mother_original_id: treeData.mother_plant_id,
                    mother_name: motherInClipboard.name,
                    mother_breed: motherInClipboard.breed || '',
                    cutting_notes: treeData.cutting_notes || '',
                    relationship_preserved: true,
                    cutting_position: { row: absoluteRow, col: absoluteCol },
                    mother_position: {
                        row: startRow + motherRelativeRow,
                        col: startCol + motherRelativeCol
                    },
                    paste_order: {
                        cutting: i,
                        mother: treesToPaste.findIndex(t => t.id === treeData.mother_plant_id)
                    }
                });
                
                console.log(`🔗 Relationship pair: "${treeData.name}" (cutting) -> "${motherInClipboard.name}" (mother)`);
            } else {
                console.warn(`⚠️ Mother tree ${treeData.mother_plant_id} not found in clipboard for cutting "${treeData.name}"`);
                
                relationshipMapping.motherCuttingPairs.push({
                    cutting_original_id: treeData.id,
                    cutting_name: treeData.name,
                    cutting_breed: treeData.breed || '',
                    mother_original_id: treeData.mother_plant_id,
                    mother_name: 'Unknown (not in clipboard)',
                    mother_breed: '',
                    cutting_notes: treeData.cutting_notes || '',
                    relationship_preserved: false,
                    cutting_position: { row: absoluteRow, col: absoluteCol },
                    mother_position: null,
                    paste_order: { cutting: i, mother: -1 }
                });
            }
        }
        
        console.log(`🌳 Processed tree: "${processedTreeData.name}" (${processedTreeData.plant_type}) at (${absoluteRow}, ${absoluteCol})`);
    }
    
    console.log(`🔗 Relationship mapping complete: ${relationshipMapping.motherCuttingPairs.length} pairs identified`);
    console.log('🔗 Relationship pairs:', relationshipMapping.motherCuttingPairs);
    
    return { processedTrees, relationshipMapping };
}

async function handleSuccessfulPasteWithRelationships(saveResult, newAreaName, clipboard, relationshipMapping) {
    console.log('✅ Handling successful paste with relationship verification...');
    console.log('📊 Save result:', saveResult);
    console.log('🔗 Relationship mapping:', relationshipMapping);
    
    // ✅ ENHANCED: Create local drag area object with comprehensive backend data
    const newDragArea = {
        id: saveResult.drag_area_id || saveResult.area?.id,
        name: newAreaName,
        color: clipboard.color || '#007bff',
        width: clipboard.width,
        height: clipboard.height,
        minRow: saveResult.area?.min_row || saveResult.minRow,
        maxRow: saveResult.area?.max_row || saveResult.maxRow,
        minCol: saveResult.area?.min_col || saveResult.minCol,
        maxCol: saveResult.area?.max_col || saveResult.maxCol,
        trees: saveResult.area?.tree_ids || saveResult.tree_ids || [],
        tree_count: saveResult.trees_created || 0,
        visible: true,
        created_at: new Date().toISOString(),
        saved_to_db: true,
        relationship_metadata: saveResult.relationship_stats || relationshipMapping || {}
    };
    
    // Add to local dragAreas array
    if (typeof dragAreas === 'undefined') {
        window.dragAreas = [];
    }
    dragAreas.push(newDragArea);
    
    console.log('✅ Drag area added to local array:', newDragArea);
    
    // ✅ ENHANCED: Show detailed success message with relationship information
    let successMessage = `Area "${newAreaName}" pasted successfully!`;
    
    if (saveResult.trees_created) {
        successMessage += `\n📊 Trees: ${saveResult.trees_created} created`;
    }
    
    // ✅ ENHANCED: Show relationship statistics
    if (saveResult.relationship_stats) {
        const stats = saveResult.relationship_stats;
        if (stats.relationships_preserved > 0) {
            successMessage += `\n🔗 Relationships: ${stats.relationships_preserved} preserved`;
        }
        if (stats.relationships_broken > 0) {
            successMessage += `, ${stats.relationships_broken} broken`;
        }
        if (stats.mothers_created > 0) {
            successMessage += `\n🌳 Mothers: ${stats.mothers_created} created`;
        }
        if (stats.cuttings_created > 0) {
            successMessage += `\n✂️ Cuttings: ${stats.cuttings_created} created`;
        }
    } else if (relationshipMapping && relationshipMapping.motherCuttingPairs) {
        const preservedCount = relationshipMapping.motherCuttingPairs.filter(p => p.relationship_preserved).length;
        const brokenCount = relationshipMapping.motherCuttingPairs.filter(p => !p.relationship_preserved).length;
        
        if (preservedCount > 0) {
            successMessage += `\n🔗 Relationships: ${preservedCount} preserved`;
        }
        if (brokenCount > 0) {
            successMessage += `, ${brokenCount} broken`;
        }
    }
    
    showStatus(successMessage, 'success');
    
    // ✅ ENHANCED: Verify relationships were properly created
    if (saveResult.id_mapping && relationshipMapping.motherCuttingPairs.length > 0) {
        console.log('🔍 Verifying relationship preservation...');
        setTimeout(async () => {
            await verifyRelationshipPreservation(saveResult.id_mapping, relationshipMapping);
        }, 1000);
    }
    
    // ✅ CRITICAL: Refresh the entire page to reload trees and areas with relationships
    console.log('🔄 Refreshing page to show pasted trees with relationships...');
    setTimeout(() => {
        window.location.reload();
    }, 2000); // Give user time to see success message
    
    console.log('✅ Paste completed successfully with relationships - page will refresh');
}
async function verifyRelationshipPreservation(idMapping, relationshipMapping) {
    console.log('🔍 Verifying relationship preservation...');
    console.log('🆔 ID mapping:', idMapping);
    console.log('🔗 Expected relationships:', relationshipMapping.motherCuttingPairs);
    
    try {
        // Get fresh tree data from server
        const response = await fetch(`/api/get_trees/${domeId}`);
        if (!response.ok) {
            console.warn('⚠️ Could not fetch trees for relationship verification');
            return;
        }
        
        const result = await response.json();
        if (!result.success || !result.trees) {
            console.warn('⚠️ Invalid response for relationship verification');
            return;
        }
        
        const freshTrees = result.trees;
        let verificationResults = {
            total_expected: relationshipMapping.motherCuttingPairs.length,
            verified_correct: 0,
            verification_failed: 0,
            details: []
        };
        
        // Check each expected relationship
        for (const pair of relationshipMapping.motherCuttingPairs) {
            if (!pair.relationship_preserved) continue;
            
            const newCuttingId = idMapping[pair.cutting_original_id];
            const newMotherId = idMapping[pair.mother_original_id];
            
            if (newCuttingId && newMotherId) {
                const cuttingTree = freshTrees.find(t => t.id === newCuttingId);
                
                if (cuttingTree) {
                    const actualMotherId = cuttingTree.mother_plant_id;
                    const relationshipCorrect = actualMotherId === newMotherId;
                    
                    if (relationshipCorrect) {
                        verificationResults.verified_correct++;
                        console.log(`✅ Relationship verified: "${pair.cutting_name}" -> "${pair.mother_name}"`);
                    } else {
                        verificationResults.verification_failed++;
                        console.error(`❌ Relationship broken: "${pair.cutting_name}" expected mother ${newMotherId}, got ${actualMotherId}`);
                    }
                    
                    verificationResults.details.push({
                        cutting_name: pair.cutting_name,
                        mother_name: pair.mother_name,
                        expected_mother_id: newMotherId,
                        actual_mother_id: actualMotherId,
                        correct: relationshipCorrect
                    });
                } else {
                    verificationResults.verification_failed++;
                    console.error(`❌ Cutting tree not found: ${newCuttingId}`);
                }
            } else {
                verificationResults.verification_failed++;
                console.error(`❌ ID mapping failed: cutting ${pair.cutting_original_id} -> ${newCuttingId}, mother ${pair.mother_original_id} -> ${newMotherId}`);
            }
        }
        
        console.log('🔍 Relationship verification results:', verificationResults);
        
        // Show verification results to user
        if (verificationResults.verified_correct === verificationResults.total_expected) {
            console.log('✅ All relationships verified successfully!');
        } else {
            console.warn(`⚠️ Relationship verification: ${verificationResults.verified_correct}/${verificationResults.total_expected} correct`);
        }
        
    } catch (error) {
        console.error('❌ Error during relationship verification:', error);
    }
}
function findAlternativePastePosition(clipboardName, originalRow, originalCol) {
    const clipboard = window.dragClipboard || window.clipboardArea;
    if (!clipboard) return;
    
    console.log('🔍 Finding alternative paste position...');
    
    // Try positions in a spiral pattern around the original position
    const maxDistance = Math.max(currentRows, currentCols);
    
    for (let distance = 1; distance <= maxDistance; distance++) {
        for (let row = Math.max(0, originalRow - distance); row <= Math.min(currentRows - clipboard.height, originalRow + distance); row++) {
            for (let col = Math.max(0, originalCol - distance); col <= Math.min(currentCols - clipboard.width, originalCol + distance); col++) {
                // Skip positions we've already checked
                if (Math.abs(row - originalRow) < distance && Math.abs(col - originalCol) < distance) {
                    continue;
                }
                
                const conflictCheck = checkPasteAreaAvailable(row, col, clipboard);
                if (conflictCheck.available) {
                    console.log(`✅ Found alternative position: (${row}, ${col})`);
                    showStatus(`Found alternative position at (${row}, ${col})`, 'info');
                    executePasteAtPosition(row, col);
                    return;
                }
            }
        }
    }
    
    showStatus('No alternative position found for pasting', 'error');
}


function analyzeClipboardRelationships(clipboard) {
    if (!clipboard.trees || clipboard.trees.length === 0) {
        return { 
            mothers: 0, 
            cuttings: 0, 
            independent: 0, 
            completeRelationships: 0, 
            brokenRelationships: 0,
            totalTrees: 0,
            relationshipPairs: [],
            hasRelationships: false
        };
    }
    
    const mothers = clipboard.trees.filter(t => t.plant_type === 'mother');
    const cuttings = clipboard.trees.filter(t => t.plant_type === 'cutting');
    const independent = clipboard.trees.filter(t => 
        !t.plant_type || 
        (t.plant_type !== 'mother' && t.plant_type !== 'cutting')
    );
    
    const motherIds = new Set(mothers.map(m => m.id));
    const completeRelationships = cuttings.filter(c => 
        c.mother_plant_id && motherIds.has(c.mother_plant_id)
    ).length;
    const brokenRelationships = cuttings.filter(c => 
        c.mother_plant_id && !motherIds.has(c.mother_plant_id)
    ).length;
    
    // ✅ ENHANCED: Create detailed relationship pairs with more information
    const relationshipPairs = cuttings.map(cutting => {
        const mother = mothers.find(m => m.id === cutting.mother_plant_id);
        return {
            cutting_id: cutting.id,
            cutting_name: cutting.name,
            cutting_breed: cutting.breed || '',
            mother_id: cutting.mother_plant_id,
            mother_name: mother ? mother.name : 'Unknown',
            mother_breed: mother ? (mother.breed || '') : '',
            is_complete: !!mother,
            cutting_notes: cutting.cutting_notes || '',
            cutting_position: {
                row: cutting.internal_row,
                col: cutting.internal_col
            },
            mother_position: mother ? {
                row: mother.internal_row,
                col: mother.internal_col
            } : null
        };
    }).filter(pair => pair.mother_id);
    
    const hasRelationships = relationshipPairs.length > 0;
    
    console.log('🔗 Enhanced clipboard relationship analysis:', {
        mothers: mothers.length,
        cuttings: cuttings.length,
        independent: independent.length,
        completeRelationships,
        brokenRelationships,
        relationshipPairs: relationshipPairs.length,
        hasRelationships
    });
    
    return {
        mothers: mothers.length,
        cuttings: cuttings.length,
        independent: independent.length,
        completeRelationships,
        brokenRelationships,
        totalTrees: clipboard.trees.length,
        relationshipPairs,
        motherTrees: mothers,
        cuttingTrees: cuttings,
        independentTrees: independent,
        hasRelationships
    };
}
async function executeFallbackPaste(pasteData, startRow, startCol) {
    console.log('🔄 Executing fallback paste with relationship fixing...');
    
    try {
        // Remove relationship metadata for basic paste
        const basicPasteData = {
            ...pasteData,
            relationship_metadata: undefined
        };
        
        const saveResponse = await fetch(`/paste_drag_area/${domeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(basicPasteData)
        });
        
        if (!saveResponse.ok) {
            const errorText = await saveResponse.text();
            console.error('❌ Fallback paste also failed:', errorText);
            showStatus('❌ Paste failed: ' + errorText, 'error');
            return;
        }
        
        const saveResult = await saveResponse.json();
        console.log('📥 Fallback paste result:', saveResult);
        
        if (saveResult.success) {
            // ✅ ENHANCED: Try to manually fix relationships after basic paste
            if (pasteData.relationship_metadata && pasteData.relationship_metadata.mother_cutting_pairs.length > 0) {
                console.log('🔗 Attempting to fix relationships manually after fallback paste...');
                await fixRelationshipsAfterFallbackPaste(saveResult, pasteData.relationship_metadata);
            }
            
            await handleSuccessfulPasteWithRelationships(saveResult, pasteData.name, { color: pasteData.color }, pasteData.relationship_metadata || {});
        } else {
            console.error('❌ Fallback paste returned error:', saveResult.error);
            showStatus('Failed to paste area: ' + saveResult.error, 'error');
        }
        
    } catch (fallbackError) {
        console.error('❌ Fallback paste error:', fallbackError);
        showStatus('All paste methods failed: ' + fallbackError.message, 'error');
    }
}

async function fixRelationshipsAfterPaste(pasteResult, relationshipMetadata) {
    console.log('🔧 Fixing relationships after paste...');
    
    if (!pasteResult.tree_ids || !relationshipMetadata.mother_cutting_pairs) {
        console.warn('⚠️ Cannot fix relationships - missing data');
        return;
    }
    
    try {
        // Create mapping of old IDs to new IDs based on position
        const oldToNewIdMapping = {};
        
        if (pasteResult.trees_created_details) {
            pasteResult.trees_created_details.forEach(treeDetail => {
                if (treeDetail.original_tree_id && treeDetail.new_tree_id) {
                    oldToNewIdMapping[treeDetail.original_tree_id] = treeDetail.new_tree_id;
                }
            });
        }
        
        console.log('🔗 ID mapping for relationship fixing:', oldToNewIdMapping);
        
        // Update cutting trees with new mother IDs
        for (const pair of relationshipMetadata.mother_cutting_pairs) {
            const newCuttingId = oldToNewIdMapping[pair.cutting_original_id];
            const newMotherId = oldToNewIdMapping[pair.mother_original_id];
            
            if (newCuttingId && newMotherId) {
                console.log(`🔗 Fixing relationship: cutting ${newCuttingId} -> mother ${newMotherId}`);
                
                try {
                    const updateResponse = await fetch(`/api/update_tree_relationship`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            cutting_tree_id: newCuttingId,
                            mother_tree_id: newMotherId,
                            cutting_notes: pair.cutting_notes
                        })
                    });
                    
                    const updateResult = await updateResponse.json();
                    if (updateResult.success) {
                        console.log(`✅ Relationship fixed: cutting ${newCuttingId} -> mother ${newMotherId}`);
                    } else {
                        console.warn(`⚠️ Failed to fix relationship: ${updateResult.error}`);
                    }
                    
                } catch (updateError) {
                    console.warn(`⚠️ Error fixing relationship:`, updateError);
                }
            } else {
                console.warn(`⚠️ Cannot fix relationship - missing IDs: cutting ${newCuttingId}, mother ${newMotherId}`);
            }
        }
        
    } catch (error) {
        console.error('❌ Error fixing relationships:', error);
    }
}
async function fixRelationshipsAfterFallbackPaste(pasteResult, relationshipMetadata) {
    console.log('🔧 Fixing relationships after fallback paste...');
    console.log('📊 Paste result:', pasteResult);
    console.log('🔗 Relationship metadata:', relationshipMetadata);
    
    if (!pasteResult.tree_ids || !relationshipMetadata.mother_cutting_pairs) {
        console.warn('⚠️ Cannot fix relationships - missing data');
        return;
    }
    
    try {
        // ✅ ENHANCED: Create comprehensive mapping of old IDs to new IDs
        const oldToNewIdMapping = {};
        
        // Try multiple sources for ID mapping
        if (pasteResult.trees_created_details) {
            pasteResult.trees_created_details.forEach(treeDetail => {
                if (treeDetail.original_tree_id && treeDetail.new_tree_id) {
                    oldToNewIdMapping[treeDetail.original_tree_id] = treeDetail.new_tree_id;
                }
            });
        } else if (pasteResult.id_mapping) {
            Object.assign(oldToNewIdMapping, pasteResult.id_mapping);
        } else {
            // ✅ FALLBACK: Try to map by position if no explicit mapping
            console.log('🔄 Attempting position-based ID mapping...');
            
            // Get fresh tree data to match by position
            try {
                const treesResponse = await fetch(`/api/get_trees/${domeId}`);
                if (treesResponse.ok) {
                    const treesResult = await treesResponse.json();
                    if (treesResult.success && treesResult.trees) {
                        const freshTrees = treesResult.trees;
                        
                        // Match trees by position and name
                        for (const pair of relationshipMetadata.mother_cutting_pairs) {
                            const cuttingPosition = pair.cutting_position;
                            const motherPosition = pair.mother_position;
                            
                            if (cuttingPosition && motherPosition) {
                                const matchedCutting = freshTrees.find(t => 
                                    t.internal_row === cuttingPosition.row && 
                                    t.internal_col === cuttingPosition.col &&
                                    t.name === pair.cutting_name
                                );
                                
                                const matchedMother = freshTrees.find(t => 
                                    t.internal_row === motherPosition.row && 
                                    t.internal_col === motherPosition.col &&
                                    t.name === pair.mother_name
                                );
                                
                                if (matchedCutting && matchedMother) {
                                    oldToNewIdMapping[pair.cutting_original_id] = matchedCutting.id;
                                    oldToNewIdMapping[pair.mother_original_id] = matchedMother.id;
                                    console.log(`🎯 Position-matched: ${pair.cutting_name} (${matchedCutting.id}) -> ${pair.mother_name} (${matchedMother.id})`);
                                }
                            }
                        }
                    }
                }
            } catch (positionError) {
                console.warn('⚠️ Position-based mapping failed:', positionError);
            }
        }
        
        console.log('🔗 ID mapping for relationship fixing:', oldToNewIdMapping);
        
        let relationshipsFixed = 0;
        let relationshipsFailed = 0;
        
        // ✅ ENHANCED: Update cutting trees with new mother IDs
        for (const pair of relationshipMetadata.mother_cutting_pairs) {
            if (!pair.relationship_preserved) {
                console.log(`⏭️ Skipping broken relationship: ${pair.cutting_name} -> ${pair.mother_name}`);
                continue;
            }
            
            const newCuttingId = oldToNewIdMapping[pair.cutting_original_id];
            const newMotherId = oldToNewIdMapping[pair.mother_original_id];
            
            if (newCuttingId && newMotherId) {
                console.log(`🔗 Fixing relationship: cutting ${newCuttingId} -> mother ${newMotherId} (${pair.cutting_name} -> ${pair.mother_name})`);
                
                try {
                    const updateResponse = await fetch(`/api/update_tree_relationship`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            cutting_tree_id: newCuttingId,
                            mother_tree_id: newMotherId,
                            cutting_notes: pair.cutting_notes || '',
                            plant_type: 'cutting'
                        })
                    });
                    
                    if (!updateResponse.ok) {
                        throw new Error(`HTTP ${updateResponse.status}: ${updateResponse.statusText}`);
                    }
                    
                    const updateResult = await updateResponse.json();
                    if (updateResult.success) {
                        relationshipsFixed++;
                        console.log(`✅ Relationship fixed: "${pair.cutting_name}" -> "${pair.mother_name}"`);
                    } else {
                        relationshipsFailed++;
                        console.warn(`⚠️ Failed to fix relationship: ${updateResult.error}`);
                    }
                    
                } catch (updateError) {
                    relationshipsFailed++;
                    console.warn(`⚠️ Error fixing relationship for ${pair.cutting_name}:`, updateError);
                }
            } else {
                relationshipsFailed++;
                console.warn(`⚠️ Cannot fix relationship - missing IDs: cutting ${pair.cutting_name} (${newCuttingId}), mother ${pair.mother_name} (${newMotherId})`);
            }
        }
        
        // ✅ ENHANCED: Show summary of relationship fixing
        console.log(`🔗 Relationship fixing summary: ${relationshipsFixed} fixed, ${relationshipsFailed} failed`);
        
        if (relationshipsFixed > 0) {
            showStatus(`🔗 Fixed ${relationshipsFixed} relationships after paste`, 'success');
        }
        
        if (relationshipsFailed > 0) {
            showStatus(`⚠️ ${relationshipsFailed} relationships could not be fixed`, 'warning');
        }
        
        return {
            fixed: relationshipsFixed,
            failed: relationshipsFailed,
            total: relationshipsFixed + relationshipsFailed
        };
        
    } catch (error) {
        console.error('❌ Error fixing relationships after fallback paste:', error);
        showStatus('Error fixing relationships: ' + error.message, 'error');
        return { fixed: 0, failed: 0, total: 0 };
    }
}
async function getFreshTreeData(domeId) {
    try {
        const response = await fetch(`/api/get_trees/${domeId}`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        if (!result.success) {
            throw new Error(result.error || 'Failed to get tree data');
        }
        
        return result.trees || [];
    } catch (error) {
        console.error('❌ Error getting fresh tree data:', error);
        return [];
    }
}
async function handleSuccessfulPaste(saveResult, newAreaName, clipboard, relationshipMapping) {
    console.log('✅ Handling successful paste...');
    
    // ✅ ENHANCED: Create local drag area object with backend data
    const newDragArea = {
        id: saveResult.drag_area_id || saveResult.area?.id,
        name: newAreaName,
        color: clipboard.color || '#007bff',
        width: clipboard.width,
        height: clipboard.height,
        minRow: saveResult.area?.min_row || saveResult.minRow,
        maxRow: saveResult.area?.max_row || saveResult.maxRow,
        minCol: saveResult.area?.min_col || saveResult.minCol,
        maxCol: saveResult.area?.max_col || saveResult.maxCol,
        trees: saveResult.area?.tree_ids || saveResult.tree_ids || [],
        tree_count: saveResult.trees_created || 0,
        visible: true,
        created_at: new Date().toISOString(),
        saved_to_db: true,
        relationship_metadata: saveResult.relationship_stats || relationshipMapping || {}
    };
    
    // Add to local dragAreas array
    if (typeof dragAreas === 'undefined') {
        window.dragAreas = [];
    }
    dragAreas.push(newDragArea);
    
    console.log('✅ Drag area added to local array:', newDragArea);
    
    // ✅ ENHANCED: Show detailed success message
    let successMessage = `Area "${newAreaName}" pasted successfully!`;
    
    if (saveResult.trees_created) {
        successMessage += `\n📊 Trees: ${saveResult.trees_created} created`;
    }
    
    if (saveResult.relationship_stats) {
        const stats = saveResult.relationship_stats;
        if (stats.relationships_preserved > 0) {
            successMessage += `\n🔗 Relationships: ${stats.relationships_preserved} preserved`;
        }
        if (stats.relationships_broken > 0) {
            successMessage += `, ${stats.relationships_broken} broken`;
        }
        if (stats.mothers_created > 0) {
            successMessage += `\n🌳 Mothers: ${stats.mothers_created} created`;
        }
        if (stats.cuttings_created > 0) {
            successMessage += `\n✂️ Cuttings: ${stats.cuttings_created} created`;
        }
    } else if (relationshipMapping && relationshipMapping.motherCuttingPairs) {
        const preservedCount = relationshipMapping.motherCuttingPairs.filter(p => p.relationship_preserved).length;
        const brokenCount = relationshipMapping.motherCuttingPairs.filter(p => !p.relationship_preserved).length;
        
        if (preservedCount > 0) {
            successMessage += `\n🔗 Relationships: ${preservedCount} preserved`;
        }
        if (brokenCount > 0) {
            successMessage += `, ${brokenCount} broken`;
        }
    }
    
    showStatus(successMessage, 'success');
    
    // ✅ CRITICAL: Refresh the entire page to reload trees and areas
    console.log('🔄 Refreshing page to show pasted trees with relationships...');
    setTimeout(() => {
        window.location.reload();
    }, 2000); // Give user time to see success message
    
    console.log('✅ Paste completed successfully with relationships - page will refresh');
}
// ✅ NEW: Helper function to create tree with relationships
async function createTreeWithRelationships(treeData, startRow, startCol, newMotherId) {
    const newRow = startRow + (treeData.relativeRow || 0);
    const newCol = startCol + (treeData.relativeCol || 0);
    
    // Validate tree position
    if (newRow < 0 || newRow >= currentRows || newCol < 0 || newCol >= currentCols) {
        console.warn(`⚠️ Skipping tree "${treeData.name}" - outside bounds`);
        return { success: false, reason: 'outside_bounds' };
    }
    
    // Check if position is occupied
    const existingTree = trees.find(t => t.internal_row === newRow && t.internal_col === newCol);
    if (existingTree) {
        console.warn(`⚠️ Skipping tree "${treeData.name}" - position occupied`);
        return { success: false, reason: 'position_occupied' };
    }
    
    try {
        // ✅ ENHANCED: Include plant relationship data in tree creation
        const treePayload = {
            dome_id: domeId,
            internal_row: newRow,
            internal_col: newCol,
            name: treeData.name || `Tree ${newRow}-${newCol}`,
            breed: treeData.breed || '',
            life_days: treeData.life_days || 0,
            info: treeData.info || '',
            image_url: treeData.image_url || '',
            
            // ✅ NEW: Plant relationship data
            plant_type: treeData.plant_type || 'mother',
            mother_plant_id: newMotherId, // Use the mapped mother ID
            cutting_notes: treeData.cutting_notes || '',
            
            // ✅ NEW: Additional metadata for tracking
            paste_metadata: {
                original_tree_id: treeData.id,
                original_mother_id: treeData.mother_plant_id,
                relationship_preserved: !!newMotherId && !!treeData.mother_plant_id,
                paste_timestamp: new Date().toISOString()
            }
        };
        
        console.log(`🌱 Creating tree with relationships:`, {
            name: treePayload.name,
            plant_type: treePayload.plant_type,
            mother_plant_id: treePayload.mother_plant_id,
            original_mother: treeData.mother_plant_id,
            cutting_notes: treePayload.cutting_notes
        });
        
        const treeResponse = await fetch('/add_tree', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(treePayload)
        });
        
        const treeResult = await treeResponse.json();
        
        if (treeResult.success) {
            const newTree = {
                id: treeResult.tree_id || treeResult.tree?.id,
                name: treePayload.name,
                breed: treePayload.breed,
                internal_row: newRow,
                internal_col: newCol,
                life_days: treePayload.life_days,
                info: treePayload.info,
                image_url: treePayload.image_url,
                dome_id: domeId,
                
                // ✅ NEW: Include relationship data in frontend tree object
                plant_type: treePayload.plant_type,
                mother_plant_id: treePayload.mother_plant_id,
                cutting_notes: treePayload.cutting_notes,
                paste_metadata: treePayload.paste_metadata
            };
            
            trees.push(newTree);
            
            console.log(`✅ Tree created with relationships: "${treePayload.name}" (${treePayload.plant_type}) at (${newRow}, ${newCol}) with ID ${newTree.id}`);
            
            return { success: true, tree: newTree };
        } else {
            console.error(`❌ Failed to create tree "${treePayload.name}":`, treeResult.error);
            return { success: false, reason: 'api_error', error: treeResult.error };
        }
    } catch (treeError) {
        console.error(`❌ Error creating tree "${treeData.name}":`, treeError);
        return { success: false, reason: 'network_error', error: treeError.message };
    }
}

// ✅ NEW: Helper function to add new breeds from clipboard
async function addNewBreedsFromClipboard(clipboardBreeds) {
    if (!clipboardBreeds || clipboardBreeds.length === 0) return;
    
    // Ensure treeBreeds exists
    if (!window.treeBreeds || !Array.isArray(window.treeBreeds)) {
        window.treeBreeds = [];
    }
    
    const newBreeds = clipboardBreeds.filter(breed => !window.treeBreeds.includes(breed));
    
    if (newBreeds.length > 0) {
        console.log(`🧬 Adding ${newBreeds.length} new breeds from clipboard:`, newBreeds);
        
        // Add to local array
        window.treeBreeds.push(...newBreeds);
        
        // Update breed selects
        if (typeof populateBreedSelects === 'function') {
            populateBreedSelects();
        }
        
        // Save to backend
        if (typeof saveBreedsToBackend === 'function') {
            await saveBreedsToBackend();
        }
        
        showStatus(`Added ${newBreeds.length} new breeds: ${newBreeds.join(', ')}`, 'info');
    }
}

// ✅ NEW: Show relationship summary dialog
function showRelationshipSummary(relationshipData) {
    const modal = document.createElement('div');
    modal.className = 'relationship-summary-modal';
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            " onclick="event.stopPropagation();">
                <h5 style="margin: 0 0 20px 0; color: #007bff;">🔗 Plant Relationship Summary</h5>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                    <div style="margin-bottom: 10px;">
                        <strong>✅ Relationships Preserved:</strong> ${relationshipData.preserved}
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>❌ Relationships Broken:</strong> ${relationshipData.broken}
                    </div>
                    <div>
                        <strong>⚠️ Orphaned Cuttings:</strong> ${relationshipData.orphaned}
                    </div>
                </div>
                
                ${relationshipData.orphaned > 0 ? `
                    <div style="background: #fff3cd; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #ffc107;">
                        <strong>⚠️ Note:</strong> ${relationshipData.orphaned} cutting tree(s) were pasted without their mother trees. 
                        They have been converted to independent trees. You can manually link them to new mothers using the tree info page.
                    </div>
                ` : ''}
                
                <div style="text-align: right;">
                    <button onclick="this.closest('.relationship-summary-modal').remove();" style="
                        padding: 8px 16px;
                        background: #007bff;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 14px;
                    ">OK</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (modal.parentNode) {
            modal.remove();
        }
    }, 10000);
}
function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
async function pasteDragArea(row, col) {
    try {
        // ✅ Get clipboard data from multiple sources
        let clipboardData = null;
        
        // Try sessionStorage first (most recent)
        try {
            const sessionData = sessionStorage.getItem('dragClipboard');
            if (sessionData) {
                clipboardData = JSON.parse(sessionData);
                console.log('📋 Using clipboard data from sessionStorage');
            }
        } catch (e) {
            console.warn('⚠️ Failed to get clipboard from sessionStorage:', e);
        }
        
        // Fallback to localStorage
        if (!clipboardData) {
            try {
                const localData = localStorage.getItem('globalDragClipboard');
                if (localData) {
                    clipboardData = JSON.parse(localData);
                    console.log('📋 Using clipboard data from localStorage');
                }
            } catch (e) {
                console.warn('⚠️ Failed to get clipboard from localStorage:', e);
            }
        }
        
        if (!clipboardData) {
            showStatus('No drag area in clipboard', 'error');
            return;
        }
        
        // ✅ Debug clipboard data
        console.log('📋 Clipboard data for paste:', {
            name: clipboardData.name,
            trees: clipboardData.trees ? clipboardData.trees.length : 0,
            breeds: clipboardData.summary ? clipboardData.summary.breeds : [],
            breedCount: clipboardData.summary ? clipboardData.summary.breeds.length : 0
        });
        
        // ✅ Log tree breed data before pasting
        if (clipboardData.trees) {
            console.log('🧬 Trees to paste with breeds:');
            clipboardData.trees.forEach((tree, index) => {
                console.log(`   Tree ${index + 1}: "${tree.name}" - Breed: "${tree.breed || 'None'}"`);
            });
        }
        
        const newName = prompt('Enter name for pasted area:', clipboardData.name + ' Copy');
        if (!newName) return;
        
        showStatus('Pasting drag area...', 'info');
        
        const response = await fetch(`/paste_drag_area/${domeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: newName,
                row: row,
                col: col,
                create_trees: true,
                clipboard_data: clipboardData  // ✅ Send clipboard data directly
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                console.log('✅ Paste successful:', result);
                console.log('🧬 Breeds pasted:', result.breeds_pasted);
                console.log('🧬 Debug info:', result.debug_info);
                
                showStatus(result.message, 'success');
                
                // Refresh the grid
                location.reload();
            } else {
                showStatus('Error pasting: ' + result.error, 'error');
            }
        } else {
            showStatus('Error pasting drag area', 'error');
        }
        
    } catch (error) {
        console.error('❌ Error pasting drag area:', error);
        showStatus('Error pasting drag area: ' + error.message, 'error');
    }
}
function updatePasteButtonVisibility() {
    const pasteBtn = document.getElementById('pasteAreaBtn');
    const clickToPasteBtn = document.getElementById('clickToPasteBtn');
    
    // ✅ ENHANCED: Check both local and global clipboards
    const hasLocalClipboard = dragClipboard || clipboardArea;
    const hasGlobalDragClipboard = localStorage.getItem('globalDragClipboard');
    const hasGlobalRegularClipboard = localStorage.getItem('globalRegularClipboard');
    
    const hasAnyClipboard = hasLocalClipboard || hasGlobalDragClipboard || hasGlobalRegularClipboard;
    
    if (pasteBtn) {
        pasteBtn.style.display = hasAnyClipboard ? 'inline-block' : 'none';
        
        // ✅ CRITICAL: Set the onclick handler
        pasteBtn.onclick = handlePasteButtonClick;
        
        // ✅ ENHANCED: Update button text to show source
        if (hasAnyClipboard) {
            let clipboardInfo = '';
            if (dragClipboard) {
                clipboardInfo = `📋 Paste "${dragClipboard.name}" (Drag Area)`;
            } else if (clipboardArea) {
                clipboardInfo = `📋 Paste "${clipboardArea.name}" (Regular Area)`;
            } else if (hasGlobalDragClipboard) {
                const globalDrag = JSON.parse(hasGlobalDragClipboard);
                clipboardInfo = `📋 Paste "${globalDrag.name}" (From Other Dome)`;
            } else if (hasGlobalRegularClipboard) {
                const globalRegular = JSON.parse(hasGlobalRegularClipboard);
                clipboardInfo = `📋 Paste "${globalRegular.name}" (From Other Dome)`;
            }
            
            pasteBtn.innerHTML = clipboardInfo;
            pasteBtn.title = 'Click to show paste options';
        }
    }
    
    if (clickToPasteBtn) {
        clickToPasteBtn.style.display = hasAnyClipboard ? 'inline-block' : 'none';
        // ✅ CRITICAL: Set the onclick handler for click-to-paste button too
        clickToPasteBtn.onclick = enableClickToPaste;
    }
    
    console.log('✅ Paste button visibility updated:', hasAnyClipboard);
}
        // ✅ FIXED: Complete refreshDebugInfo function
        function refreshDebugInfo() {
            document.getElementById('frontendTreesCount').textContent = trees.length;
            document.getElementById('emptyPositionsCount').textContent = getEmptyPositions().length;
            document.getElementById('frontendTreesDisplay').textContent = trees.length;
            
            // Update trees data display
            document.getElementById('treesData').textContent = JSON.stringify(trees, null, 2);
            
            console.log('=== DEBUG INFO REFRESHED ===');
            console.log('Trees Count:', trees.length);
            console.log('Empty Positions:', getEmptyPositions().length);
            console.log('============================');
        }

        // ✅ FIXED: Get empty positions function
        function getEmptyPositions() {
            const emptyPositions = [];
            for (let row = 0; row < currentRows; row++) {
                for (let col = 0; col < currentCols; col++) {
                    const hasTree = trees.some(tree => 
                        tree.internal_row === row && tree.internal_col === col
                    );
                    if (!hasTree) {
                        emptyPositions.push({ row, col });
                    }
                }
            }
            return emptyPositions;
        }

        // ✅ FIXED: Force refresh trees function
        async function forceRefreshTrees() {
            try {
                showStatus('Refreshing trees data...', 'info');
                
                const response = await fetch(`/api/dome/${domeId}/trees`);
                const data = await response.json();
                
                if (data.success) {
                    trees = data.trees;
                    console.log('✅ Trees refreshed from API:', trees.length);
                    renderGrid();
                    updateStats();
                    refreshDebugInfo();
                    showStatus('Trees data refreshed successfully!', 'success');
                } else {
                    console.error('API error:', data.error);
                    showStatus('Failed to refresh trees: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Network error:', error);
                showStatus('Network error while refreshing trees', 'error');
            }
        }

        // ✅ FIXED: Render grid function
function renderGrid() {
    try {
        console.log('🔄 Rendering grid...');
        console.log('Trees count:', trees ? trees.length : 'undefined');
        console.log('Drag areas count:', dragAreas ? dragAreas.length : 'undefined');
        console.log('Regular areas count:', areas ? areas.length : 'undefined');
        
        const grid = document.getElementById('treeGrid');
        if (!grid) {
            console.error('❌ Grid container not found');
            return;
        }
        
        // Set grid layout
        grid.style.gridTemplateColumns = `repeat(${currentCols}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${currentRows}, 1fr)`;
        
        // Clear existing content
        grid.innerHTML = '';
        
        // Clear existing overlays first
        document.querySelectorAll('.drag-area-overlay, .area-overlay, .selection-box').forEach(overlay => {
            overlay.remove();
        });
        
        // Create cells
        for (let row = 0; row < currentRows; row++) {
            for (let col = 0; col < currentCols; col++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                // ✅ CRITICAL: Apply ALL area styling to each cell
                if (typeof applyAllAreaStyling === 'function') {
                    applyAllAreaStyling(cell, row, col);
                }
                
                // Selection mode event handlers
                cell.addEventListener('mousedown', (e) => {
                    if (selectionMode && !pasteMode && !clickToPasteMode) {
                        e.preventDefault();
                        e.stopPropagation();
                        handleCellMouseDown(e, row, col);
                        return false;
                    }
                });
                
                cell.addEventListener('mouseenter', (e) => {
                    if (selectionMode && !pasteMode && !clickToPasteMode && isSelecting) {
                        e.preventDefault();
                        handleCellMouseEnter(e, row, col);
                    }
                });
                
                cell.addEventListener('mouseup', (e) => {
                    if (selectionMode && !pasteMode && !clickToPasteMode) {
                        e.preventDefault();
                        e.stopPropagation();
                        handleCellMouseUp(e, row, col);
                        return false;
                    }
                });
                
                // Normal drag and drop events (only when not in paste mode)
                if (!selectionMode && !clickToPasteMode) {
                    cell.addEventListener('dragover', allowDrop);
                    cell.addEventListener('drop', (e) => dropTree(e, row, col));
                    cell.addEventListener('dragleave', (e) => {
                        e.currentTarget.classList.remove('drag-over', 'swap-target');
                    });
                }
                
                // Add coordinate label
                const coordLabel = document.createElement('div');
                coordLabel.className = 'coordinate-label';
                coordLabel.textContent = `${row},${col}`;
                cell.appendChild(coordLabel);
                
                // Check if there's a tree at this position
                const tree = trees.find(t => 
                    t.internal_row === row && t.internal_col === col
                );
                
                if (tree) {
                    cell.classList.add('occupied');
                    
                    // ✅ FIXED: Create tree element with breed information
                    let treeElement;
                    if (typeof createTreeElement === 'function') {
                        treeElement = createTreeElement(tree);
                    } else {
                        // ✅ FALLBACK: Create tree element manually with breed support
                        treeElement = createTreeElementWithBreed(tree);
                    }
                    
                    if (selectionMode) {
                        treeElement.style.pointerEvents = 'none';
                        treeElement.draggable = false;
                        const overlay = document.createElement('div');
                        overlay.className = 'selection-overlay';
                        cell.appendChild(overlay);
                    }
                    
                    cell.appendChild(treeElement);
                } else {
                    // Only add tree button when NOT in selection mode AND NOT in paste mode
                    if (!selectionMode && !clickToPasteMode) {
                        const addBtn = document.createElement('button');
                        addBtn.className = 'add-tree-btn';
                        addBtn.innerHTML = '+';
                        addBtn.title = `Add tree at (${row}, ${col})`;
                        addBtn.onclick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            addTreeAtPosition(row, col);
                        };
                        cell.appendChild(addBtn);
                    }
                    
                    // Add paste indicator when in paste mode
                    if (clickToPasteMode) {
                        const pasteIndicator = document.createElement('div');
                        pasteIndicator.className = 'paste-indicator';
                        pasteIndicator.innerHTML = '📋';
                        pasteIndicator.title = 'Click to paste here';
                        pasteIndicator.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            font-size: 24px;
                            opacity: 0.7;
                            pointer-events: none;
                            z-index: 5;
                        `;
                        cell.appendChild(pasteIndicator);
                    }
                }
                
                grid.appendChild(cell);
            }
        }
        
        if (typeof updateGridDisplay === 'function') {
            updateGridDisplay();
        }
        
        // ✅ CRITICAL: Render ALL areas after grid is ready
        setTimeout(() => {
            console.log('🎨 Rendering all areas after grid creation...');
            
            // Render regular areas first
            if (areas && areas.length > 0) {
                console.log(`Rendering ${areas.length} regular areas`);
                if (typeof renderAreas === 'function') {
                    renderAreas();
                }
            }
            
            // Render drag areas second
            if (dragAreas && dragAreas.length > 0 && dragSelector) {
                console.log(`Rendering ${dragAreas.length} drag areas`);
                if (typeof dragSelector.renderDragAreas === 'function') {
                    dragSelector.renderDragAreas();
                }
            }
            
            console.log('✅ All areas rendered successfully');
        }, 50); // Small delay to ensure grid is fully rendered
        
        console.log(`✅ Grid rendered with ${trees.length} trees`);
        
    } catch (error) {
        console.error('❌ Error in renderGrid:', error);
        const grid = document.getElementById('treeGrid');
        if (grid) {
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: red; background: #ffe6e6; border-radius: 8px;">
                    <h3>❌ Grid Rendering Error</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <button onclick="location.reload()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                        🔄 Reload Page
                    </button>
                </div>
            `;
        }
    }
}

// ✅ NEW: Fallback function to create tree element with breed support
function createTreeElementWithBreed(tree) {
    const treeElement = document.createElement('div');
    treeElement.className = 'tree-item';
    treeElement.draggable = true;
    treeElement.dataset.treeId = tree.id;
    
    // ✅ CRITICAL: Include breed in tree display
    const breedDisplay = tree.breed ? 
        `<div class="tree-breed" style="font-size: 10px; color: #28a745; font-weight: bold; margin: 2px 0; padding: 1px 4px; background: rgba(40, 167, 69, 0.1); border-radius: 3px; text-align: center;">${tree.breed}</div>` : 
        '';
    
    // Get life stage info
    const lifeDays = tree.life_days || 0;
    let lifeStage = 'Seedling';
    let stageColor = '#90EE90';
    let treeIcon = '🌱';
    
    if (lifeDays >= 60) {
        lifeStage = 'Mature';
        stageColor = '#228B22';
        treeIcon = '🌳';
    } else if (lifeDays >= 30) {
        lifeStage = 'Growing';
        stageColor = '#32CD32';
        treeIcon = '🌿';
    }
    
    treeElement.innerHTML = `
        <div class="tree-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 2px; cursor: pointer; transition: all 0.3s ease; border-radius: 8px;">
            <div class="tree-icon" style="font-size: 16px; margin: 1px 0; color: ${stageColor};">
                ${treeIcon}
            </div>
            <div class="tree-name" style="font-size: 11px; font-weight: bold; color: #333; text-align: center; margin: 1px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%;">
                ${tree.name}
            </div>
            ${breedDisplay}
            <div class="tree-age" style="font-size: 9px; color: #666; margin: 1px 0;">
                ${lifeDays} days
            </div>
            <div class="tree-stage" style="font-size: 8px; color: #888; margin: 1px 0; text-transform: uppercase;">
                ${lifeStage}
            </div>
        </div>
    `;
    
    // Add event listeners
    treeElement.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (typeof showTreeInfo === 'function') {
            showTreeInfo(tree.id);
        }
    });
    
    treeElement.addEventListener('dragstart', (e) => {
        if (!selectionMode) {
            e.dataTransfer.setData('text/plain', tree.id);
            e.dataTransfer.effectAllowed = 'move';
        } else {
            e.preventDefault();
        }
    });
    
    // Debug log to verify breed is included
    if (tree.breed) {
        console.log(`🧬 Tree "${tree.name}" rendered with breed: "${tree.breed}"`);
    }
    
    return treeElement;
}

// ✅ NEW: Function to apply ALL area styling to a cell
function applyAllAreaStyling(cell, row, col) {
    try {
        // ✅ CRITICAL: Apply styling for ALL matching areas, not just the first one
        let hasAreaStyling = false;
        let areaColors = [];
        let areaNames = [];
        
        // Check drag areas
        if (dragAreas && dragAreas.length > 0) {
            dragAreas.forEach((area, index) => {
                if (!area.visible) return;
                
                const inDragArea = row >= area.minRow && row <= area.maxRow && 
                                 col >= area.minCol && col <= area.maxCol;
                
                if (inDragArea) {
                    cell.classList.add('in-drag-area');
                    areaColors.push(area.color);
                    
                    hasAreaStyling = true;
                    
                    // Add drag area specific styling
                    if (areaColors.length === 1) {
                        // First area - use solid border
                        cell.style.borderColor = area.color;
                        cell.style.borderWidth = '2px';
                        cell.style.borderStyle = 'solid';
                    } else {
                        // Multiple areas - use gradient or mixed styling
                        cell.style.borderImage = `linear-gradient(45deg, ${areaColors.join(', ')}) 1`;
                        cell.style.borderWidth = '3px';
                        cell.style.borderStyle = 'solid';
                    }
                    
                    // Add area label for top-left corner
                    if (row === area.minRow && col === area.minCol) {
                        const areaLabel = document.createElement('div');
                        areaLabel.className = 'drag-area-label';
                        
                        
                        cell.appendChild(areaLabel);
                    }
                }
            });
        }
        
        // Check regular areas
        if (areas && areas.length > 0) {
            areas.forEach((area, index) => {
                if (!area.visible) return;
                
                const inRegularArea = row >= area.min_row && row <= area.max_row && 
                                     col >= area.min_col && col <= area.max_col;
                
                if (inRegularArea) {
                    cell.classList.add('in-regular-area');
                    areaColors.push(area.color);
                    areaNames.push(area.name);
                    hasAreaStyling = true;
                    
                    // Add regular area specific styling (background color with transparency)
                    if (!cell.classList.contains('in-drag-area')) {
                        // Only regular area
                        cell.style.backgroundColor = area.color + '20'; // 20% opacity
                        cell.style.boxShadow = `inset 0 0 0 1px ${area.color}`;
                    } else {
                        // Mixed with drag area - add subtle background
                        const currentBg = cell.style.backgroundColor || '';
                        if (!currentBg.includes('linear-gradient')) {
                            cell.style.backgroundColor = `linear-gradient(135deg, ${area.color}20, transparent)`;
                        }
                    }
                    
                    // Add area label for top-left corner
                    if (row === area.min_row && col === area.min_col) {
                        const areaLabel = document.createElement('div');
                        areaLabel.className = 'regular-area-label';
                        areaLabel.style.cssText = `
                            position: absolute;
                            top: -20px;
                            right: ${index * 60}px;
                            background: ${area.color};
                            color: white;
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-size: 10px;
                            font-weight: bold;
                            white-space: nowrap;
                            z-index: 10;
                            pointer-events: none;
                        `;
                        areaLabel.textContent = area.name;
                        cell.appendChild(areaLabel);
                    }
                }
            });
        }
        
        // Add tooltip for cells with multiple areas
        if (areaNames.length > 1) {
            cell.title = `Areas: ${areaNames.join(', ')}`;
        } else if (areaNames.length === 1) {
            cell.title = `Area: ${areaNames[0]}`;
        }
        
        // Add area info indicator for cells with areas
        if (hasAreaStyling && areaNames.length > 0) {
            const areaInfo = document.createElement('div');
            areaInfo.className = 'area-info-indicator';
            areaInfo.style.cssText = `
                position: absolute;
                bottom: 2px;
                right: 2px;
                font-size: 8px;
                color: ${areaColors[0] || '#666'};
                font-weight: bold;
                pointer-events: none;
                z-index: 5;
                text-shadow: 1px 1px 1px rgba(255,255,255,0.8);
            `;
            areaInfo.textContent = areaNames.length > 1 ? `${areaNames.length}A` : areaNames[0].substring(0, 3);
            cell.appendChild(areaInfo);
        }
        
    } catch (error) {
        console.warn('⚠️ Error applying area styling:', error);
    }
}

// ✅ ENHANCED: Function to force re-render all areas
function forceRenderAllAreas() {
    console.log('🔄 Force rendering all areas...');
    
    // Clear existing area styling
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('in-drag-area', 'in-regular-area');
        cell.style.borderColor = '';
        cell.style.borderWidth = '';
        cell.style.borderStyle = '';
        cell.style.backgroundColor = '';
        cell.style.boxShadow = '';
        cell.style.borderImage = '';
        
        // Remove existing area labels
        cell.querySelectorAll('.drag-area-label, .regular-area-label, .area-info-indicator').forEach(label => {
            label.remove();
        });
    });
    
    // Re-apply all area styling
    document.querySelectorAll('.grid-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        applyAllAreaStyling(cell, row, col);
    });
    
    console.log('✅ All areas re-rendered');
}

// ✅ Make functions globally accessible
window.applyAllAreaStyling = applyAllAreaStyling;
window.forceRenderAllAreas = forceRenderAllAreas;

// ✅ FIXED: Global events - place OUTSIDE renderGrid function
let globalEventsAdded = false;

function addGlobalSelectionEvents() {
    if (globalEventsAdded) return;
    
    document.addEventListener('mouseup', (e) => {
        if (selectionMode && isSelecting) {
            console.log('Global mouseup - ending selection');
            isSelecting = false;
            if (selectedCells.length > 0) {
                const createBtn = document.getElementById('createAreaBtn');
                if (createBtn) {
                    createBtn.disabled = false;
                }
                showStatus(`Selected ${selectedCells.length} cells. Enter name and create area.`, 'success');
            }
        }
    });

    document.addEventListener('selectstart', (e) => {
        if (selectionMode && isSelecting) {
            e.preventDefault();
            return false;
        }
    });

    document.addEventListener('contextmenu', (e) => {
        if (selectionMode && isSelecting) {
            e.preventDefault();
            return false;
        }
    });
    
    globalEventsAdded = true;
    console.log('✅ Global selection events added');
}
// ✅ EMERGENCY DEBUG: Add this to check what's happening
function emergencyDebug() {
    console.log('=== EMERGENCY DEBUG ===');
    console.log('Selection mode:', selectionMode);
    console.log('Grid has selection-mode-active class:', document.getElementById('treeGrid').classList.contains('selection-mode-active'));
    
    // Test CSS by manually adding class
    const testCell = document.querySelector('[data-row="0"][data-col="0"]');
    if (testCell) {
        console.log('Test cell found:', testCell);
        console.log('Test cell current classes:', testCell.className);
        
        testCell.classList.add('selecting');
        console.log('Added selecting class');
        console.log('Test cell classes after adding:', testCell.className);
        
        const computedStyle = window.getComputedStyle(testCell);
        console.log('Computed background:', computedStyle.backgroundColor);
        console.log('Computed border:', computedStyle.border);
        
        setTimeout(() => {
            testCell.classList.remove('selecting');
        }, 5000);
    }
    console.log('======================');
}

// Add button to test
// <button class="btn-danger" onclick="emergencyDebug()">🚨 Emergency Debug</button>
        // ✅ FIXED: Create tree element function with proper image handling
        function createTreeElement(tree) {
            const treeItem = document.createElement('div');
            treeItem.className = 'tree-item';
            treeItem.draggable = true;
            treeItem.dataset.treeId = tree.id;
                if (selectionMode) {
        treeItem.draggable = false;
        treeItem.style.pointerEvents = 'none';
    }
            treeItem.addEventListener('dragstart', dragStart);
            treeItem.addEventListener('dragend', dragEnd);
            
            // ✅ FIXED: Proper click handling with drag detection
            let isDragging = false;
            let dragStartTime = 0;
            
            treeItem.addEventListener('mousedown', () => {
                isDragging = false;
                dragStartTime = Date.now();
            });
            
            treeItem.addEventListener('dragstart', () => {
                isDragging = true;
            });
            
            treeItem.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Only navigate if not dragging and sufficient time has passed
                const timeSinceDragStart = Date.now() - dragStartTime;
                if (!isDragging && timeSinceDragStart < 200) {
                    console.log('Opening tree info for tree:', tree.id);
                    openTreeInfo(tree.id);
                }
            });
            
            // ✅ FIXED: Tree image handling with base64 support
            if (tree.image_url && tree.image_url.includes('data:image/')) {
                // Base64 image using img tag
                const treeImageContainer = document.createElement('div');
                treeImageContainer.className = 'tree-image-container';
                
                const treeImage = document.createElement('img');
                treeImage.src = tree.image_url;
                treeImage.alt = 'Tree Image';
                treeImage.className = 'tree-image-img';
                treeImage.style.pointerEvents = 'none';
                
                // Add error handling
                handleImageError(treeImage, '🌱');
                
                treeImageContainer.appendChild(treeImage);
                treeItem.appendChild(treeImageContainer);
            } else if (tree.image_url) {
                // Old file URL using background-image
                const treeImage = document.createElement('div');
                treeImage.className = 'tree-image';
                treeImage.style.backgroundImage = `url('${tree.image_url}?t=${Date.now()}')`;
                treeImage.style.pointerEvents = 'none';
                treeItem.appendChild(treeImage);
            } else {
                // No image - placeholder
                const treePlaceholder = document.createElement('div');
                treePlaceholder.className = 'tree-placeholder';
                treePlaceholder.textContent = '🌱';
                treePlaceholder.style.pointerEvents = 'none';
                treeItem.appendChild(treePlaceholder);
            }
            
            // Tree name
            const treeName = document.createElement('div');
            treeName.className = 'tree-name';
            treeName.textContent = tree.name || `Tree ${tree.id}`;
            treeName.style.pointerEvents = 'none';
            treeItem.appendChild(treeName);
            
            // Tree actions
            const actions = document.createElement('div');
            actions.className = 'tree-actions';
            actions.style.pointerEvents = 'auto';
            
            const editBtn = document.createElement('button');
            editBtn.className = 'action-btn edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit tree';
            editBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Editing tree:', tree.id);
                editTree(tree.id);
            };
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-btn delete-btn';
            deleteBtn.innerHTML = '🗑️';
            deleteBtn.title = 'Delete tree';
            deleteBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Deleting tree:', tree.id);
                deleteTree(tree.id);
            };
            
            // Add copy button
            const copyBtn = document.createElement('button');
            copyBtn.className = 'action-btn copy-btn';
            copyBtn.innerHTML = '📋';
            copyBtn.title = 'Copy tree';
            copyBtn.style.background = '#17a2b8';
            copyBtn.style.color = 'white';
            copyBtn.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                copyTreeToClipboard(tree);
            };

            actions.appendChild(editBtn);
            actions.appendChild(copyBtn);
            actions.appendChild(deleteBtn);
            treeItem.appendChild(actions);
            
            return treeItem;
        }

        // ✅ FIXED: Handle image error function
        function handleImageError(imgElement, fallbackContent = '🌱') {
            imgElement.onerror = function() {
                console.warn('Failed to load image:', this.src);
                
                // Replace with placeholder
                const placeholder = document.createElement('div');
                placeholder.className = 'tree-placeholder';
                placeholder.textContent = fallbackContent;
                placeholder.style.pointerEvents = 'none';
                
                // Replace the image container with placeholder
                const container = this.closest('.tree-image-container');
                if (container && container.parentNode) {
                    container.parentNode.replaceChild(placeholder, container);
                }
            };
            
            imgElement.onload = function() {
                console.log('✅ Tree image loaded successfully');
            };
        }

        // ✅ FIXED: Drag and drop functions
        function dragStart(e) {
            draggedTree = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            
            console.log('Drag started for tree:', e.target.dataset.treeId);
        }

        function dragEnd(e) {
            e.target.classList.remove('dragging');
            draggedTree = null;
            
            // Remove all drag indicators
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('drag-over', 'swap-target');
            });
            
            console.log('Drag ended');
        }

        function allowDrop(e) {
            e.preventDefault();
            
            if (!draggedTree) return;
            
            const cell = e.currentTarget;
            const hasTree = cell.classList.contains('occupied');
            
            if (hasTree) {
                cell.classList.add('swap-target');
                cell.classList.remove('drag-over');
            } else {
                cell.classList.add('drag-over');
                cell.classList.remove('swap-target');
            }
        }

        function dropTree(e, targetRow, targetCol) {
            e.preventDefault();
            
            if (!draggedTree) return;
            
            const treeId = draggedTree.dataset.treeId;
            const sourceTree = trees.find(t => t.id == treeId);
            
            if (!sourceTree) {
                console.error('Source tree not found');
                return;
            }
            
            const targetTree = trees.find(t => 
                t.internal_row === targetRow && t.internal_col === targetCol
            );
            
            if (targetTree) {
                // Swap trees
                swapTrees(sourceTree.id, targetTree.id);
            } else {
                // Move to empty position
                moveTree(sourceTree.id, targetRow, targetCol);
            }
        }

        // ✅ FIXED: Tree management functions
        async function moveTree(treeId, newRow, newCol) {
            try {
                showStatus('Moving tree...', 'info');
                
                const response = await fetch(`/api/trees/${treeId}/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        internal_row: newRow,
                        internal_col: newCol
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update local tree data
                    const tree = trees.find(t => t.id == treeId);
                    if (tree) {
                        tree.internal_row = newRow;
                        tree.internal_col = newCol;
                    }
                    
                    renderGrid();
                    updateStats();
                    showStatus('Tree moved successfully!', 'success');
                } else {
                    showStatus('Failed to move tree: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error moving tree:', error);
                showStatus('Error moving tree', 'error');
            }
        }
function hidePasteControls() {
    const controls = document.getElementById('pasteControls');
   
    
    if (controls) {
        controls.style.display = 'none';
    }
    
    // Show the main paste button again
    if (pasteBtn && (dragClipboard || clipboardArea)) {
        pasteBtn.style.display = 'inline-block';
    }
    
    console.log('✅ Paste controls hidden');
}
function handleCellMouseDown(e, row, col) {
    if (!selectionMode || pasteMode) return;
    
    console.log('🎯 Selection started at:', row, col); // Debug log
    
    e.preventDefault();
    e.stopPropagation();
    
    isSelecting = true;
    selectionStart = { row, col };
    selectionEnd = { row, col };
    
    clearSelection();
    updateSelection();
    
    // ✅ NEW: Visual feedback
    showStatus(`Selection started at (${row}, ${col})`, 'info', 1000);
}

function handleCellMouseEnter(e, row, col) {
    if (!selectionMode || !isSelecting || pasteMode) return;
    
    console.log('🎯 Mouse enter cell:', row, col);
    
    // Update selection end point
    selectionEnd = { row, col };
    
    // Immediately update visual selection
    updateSelection();
    
    // ✅ NEW: Add cursor trail effect
    const cell = e.currentTarget;
    cell.style.transition = 'all 0.1s ease';
}

function handleCellMouseUp(e, row, col) {
    if (!selectionMode || !isSelecting || pasteMode) return;
    
    isSelecting = false;
    
    if (selectedCells.length > 0) {
        document.getElementById('createAreaBtn').disabled = false;
        showStatus(`Selected ${selectedCells.length} cells. Enter name and create area.`, 'success');
    }
}

function updateSelection() {
    if (!selectionStart || !selectionEnd) {
        console.log('❌ No selection start/end points');
        return;
    }
    
    console.log('🎯 Updating selection from', selectionStart, 'to', selectionEnd);
    
    // Clear ALL previous selection classes
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('selecting', 'selection-start', 'selection-end');
        cell.style.backgroundColor = '';
        cell.style.border = '';
        cell.style.boxShadow = '';
    });
    
    const minRow = Math.min(selectionStart.row, selectionEnd.row);
    const maxRow = Math.max(selectionStart.row, selectionEnd.row);
    const minCol = Math.min(selectionStart.col, selectionEnd.col);
    const maxCol = Math.max(selectionStart.col, selectionEnd.col);
    
    selectedCells = [];
    
    // ✅ ENHANCED: Add selection with visual feedback
    for (let row = minRow; row <= maxRow; row++) {
        for (let col = minCol; col <= maxCol; col++) {
            selectedCells.push({ row, col });
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.classList.add('selecting');
                
                // ✅ NEW: Add extra visual feedback
                cell.style.backgroundColor = 'rgba(255, 152, 0, 0.8)';
                cell.style.border = '4px solid #ff9800';
                cell.style.boxShadow = '0 0 20px rgba(255, 152, 0, 1)';
                cell.style.zIndex = '15';
                cell.style.position = 'relative';
                cell.style.transform = 'scale(1.03)';
                
                // Mark start and end cells
                if (row === selectionStart.row && col === selectionStart.col) {
                    cell.classList.add('selection-start');
                }
                if (row === selectionEnd.row && col === selectionEnd.col) {
                    cell.classList.add('selection-end');
                }
                
                console.log('✅ Added selecting class to cell:', row, col);
            } else {
                console.log('❌ Cell not found:', row, col);
            }
        }
    }
    
    console.log('🎯 Selected cells count:', selectedCells.length);
    
    // ✅ NEW: Show selection info in real-time
    showStatus(`Selecting ${selectedCells.length} cells (${maxCol - minCol + 1}×${maxRow - minRow + 1})`, 'info', 500);
}

function clearSelection() {
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('selecting', 'selected');
    });
    
    selectedCells = [];
    selectionStart = null;
    selectionEnd = null;
    document.getElementById('createAreaBtn').disabled = true;
    document.getElementById('areaName').value = '';
}

async function createArea() {
    console.log('🎯 Creating area...');
    
    // ✅ ENHANCED: Get form elements with validation
    const nameInput = document.getElementById('areaName');
    const colorInput = document.getElementById('areaColor');
    
    if (!nameInput || !colorInput) {
        console.error('❌ Area form elements not found');
        showStatus('Area creation form not found', 'error');
        return;
    }
    
    const name = nameInput.value.trim();
    const color = colorInput.value;
    
    // ✅ ENHANCED: Better validation with specific messages
    if (!name) {
        showStatus('Please enter an area name', 'warning');
        nameInput.focus();
        return;
    }
    
    if (name.length < 2) {
        showStatus('Area name must be at least 2 characters long', 'warning');
        nameInput.focus();
        return;
    }
    
    if (name.length > 50) {
        showStatus('Area name is too long (max 50 characters)', 'warning');
        nameInput.focus();
        return;
    }
    
    if (selectedCells.length === 0) {
        showStatus('Please select some cells first by clicking and dragging', 'warning');
        return;
    }
    
    // ✅ ENHANCED: Validate selection size
    if (selectedCells.length > 1000) {
        const confirm = window.confirm(`You've selected ${selectedCells.length} cells. This is a very large area. Continue?`);
        if (!confirm) {
            console.log('Area creation cancelled - too large');
            return;
        }
    }
    
    // ✅ ENHANCED: Check for duplicate names (case-insensitive)
    const existingArea = areas.find(area => area.name.toLowerCase() === name.toLowerCase());
    if (existingArea) {
        showStatus(`Area name "${name}" already exists. Please choose a different name.`, 'warning');
        nameInput.focus();
        nameInput.select();
        return;
    }
    
    // ✅ ENHANCED: Validate color
    if (!color || color === '#000000') {
        const confirmColor = window.confirm('No color selected or black color chosen. Use a random color instead?');
        if (confirmColor) {
            colorInput.value = getRandomColor();
        } else {
            colorInput.focus();
            return;
        }
    }
    
    try {
        // ✅ ENHANCED: Calculate area bounds and properties
        const rows = selectedCells.map(c => c.row);
        const cols = selectedCells.map(c => c.col);
        
        const minRow = Math.min(...rows);
        const maxRow = Math.max(...rows);
        const minCol = Math.min(...cols);
        const maxCol = Math.max(...cols);
        
        // ✅ ENHANCED: Get trees in this area with detailed info
        const treesInArea = [];
        const treeIds = [];
        
        selectedCells.forEach(cell => {
            const tree = trees.find(t => t.internal_row === cell.row && t.internal_col === cell.col);
            if (tree) {
                treeIds.push(tree.id);
                treesInArea.push({
                    id: tree.id,
                    name: tree.name,
                    row: tree.internal_row,
                    col: tree.internal_col
                });
            }
        });
        
        console.log(`📊 Area stats: ${selectedCells.length} cells, ${treesInArea.length} trees`);
        
        // ✅ ENHANCED: Create comprehensive area data
        const areaData = {
            name: name,
            color: colorInput.value,
            min_row: minRow,
            max_row: maxRow,
            min_col: minCol,
            max_col: maxCol,
            width: maxCol - minCol + 1,
            height: maxRow - minRow + 1,
            cells: selectedCells.map(cell => ({
                row: cell.row,
                col: cell.col
            })),
            tree_ids: treeIds,
            dome_id: domeId,
            visible: true,
            created_at: new Date().toISOString()
        };
        
        console.log('📦 Area data prepared:', areaData);
        showStatus('Creating area...', 'info');
        
        // ✅ ENHANCED: Try API first, fallback to localStorage
        let apiSuccess = false;
        let areaId = null;
        
        try {
            console.log('📡 Attempting to save area to database...');
            
            // Try multiple API endpoints for compatibility
            let response;
            let apiEndpoint;
            
            try {
                // Try new regular area endpoint
                apiEndpoint = `/api/save_regular_area/${domeId}`;
                response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(areaData)
                });
            } catch (apiError) {
                console.warn('❌ Regular area API failed, trying generic endpoint:', apiError);
                
                // Fallback to generic areas endpoint
                apiEndpoint = `/api/dome/${domeId}/areas`;
                response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(areaData)
                });
            }
            
            console.log(`📡 API Response from ${apiEndpoint}:`, response.status, response.statusText);
            
            if (response.ok) {
                const result = await response.json();
                console.log('📦 API response data:', result);
                
                if (result.success) {
                    areaId = result.area_id || result.id;
                    apiSuccess = true;
                    console.log('✅ Area saved to database with ID:', areaId);
                } else {
                    console.warn('❌ API returned error:', result.error);
                    throw new Error(result.error || 'Unknown API error');
                }
            } else {
                const errorText = await response.text();
                console.warn(`❌ HTTP Error ${response.status}:`, errorText);
                throw new Error(`Server error: ${response.status}`);
            }
            
        } catch (apiError) {
            console.warn('❌ API save failed, using localStorage fallback:', apiError);
            apiSuccess = false;
        }
        
        // ✅ ENHANCED: Create area object for local storage
        const newArea = {
            id: areaId || Date.now(), // Use API ID or timestamp
            name: name,
            color: colorInput.value,
            min_row: minRow,
            max_row: maxRow,
            min_col: minCol,
            max_col: maxCol,
            width: maxCol - minCol + 1,
            height: maxRow - minRow + 1,
            cells: [...selectedCells],
            tree_ids: treeIds,
            trees_in_area: treesInArea,
            visible: true,
            created_at: new Date().toISOString(),
            dome_id: domeId,
            saved_to_db: apiSuccess
        };
        
        // ✅ ENHANCED: Add to local areas array
        areas.push(newArea);
        console.log('✅ Area added to local array:', newArea);
        
        // ✅ ENHANCED: Save to localStorage as backup
        try {
            saveLineAreasToStorage();
            console.log('✅ Areas saved to localStorage');
        } catch (storageError) {
            console.warn('❌ Failed to save to localStorage:', storageError);
        }
        
        // ✅ ENHANCED: Update UI components
        clearSelection();
        
        if (typeof renderAreas === 'function') {
            renderAreas();
            console.log('✅ Areas rendered');
        }
        
        if (typeof updateAreasDisplay === 'function') {
            updateAreasDisplay();
            console.log('✅ Areas display updated');
        }
        
        // ✅ ENHANCED: Show areas list
        const areasList = document.getElementById('lineAreasList');
        if (areasList) {
            areasList.style.display = 'block';
        }
        
        // ✅ ENHANCED: Clear form
        nameInput.value = '';
        colorInput.value = getRandomColor();
        
        // ✅ ENHANCED: Success message with details
        const statusMessage = apiSuccess 
            ? `Area "${name}" created and saved to database! (${selectedCells.length} cells, ${treesInArea.length} trees)`
            : `Area "${name}" created locally! (${selectedCells.length} cells, ${treesInArea.length} trees) - Will sync when connection is restored`;
        
        showStatus(statusMessage, 'success');
        console.log('✅ Area creation completed successfully');
        
        // ✅ ENHANCED: Update area counter
        if (typeof areaIdCounter !== 'undefined' && newArea.id >= areaIdCounter) {
            areaIdCounter = newArea.id + 1;
        }
        
    } catch (error) {
        console.error('❌ Error creating area:', error);
        
        // ✅ ENHANCED: Specific error messages
        let errorMessage = 'Error creating area';
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            errorMessage = 'Network error - area saved locally only';
            
            // Still try to save locally
            try {
                const fallbackArea = {
                    id: Date.now(),
                    name: name,
                    color: colorInput.value,
                    cells: [...selectedCells],
                    visible: true,
                    created_at: new Date().toISOString(),
                    saved_to_db: false
                };
                
                areas.push(fallbackArea);
                saveLineAreasToStorage();
                clearSelection();
                renderAreas();
                updateAreasDisplay();
                
                showStatus(`Area "${name}" saved locally (offline mode)`, 'warning');
                return;
                
            } catch (fallbackError) {
                console.error('❌ Fallback save failed:', fallbackError);
            }
        } else if (error.message.includes('Server error')) {
            errorMessage = `Server error - ${error.message}`;
        } else if (error.message.includes('JSON')) {
            errorMessage = 'Invalid server response';
        } else {
            errorMessage = `Error: ${error.message}`;
        }
        
        showStatus(errorMessage, 'error');
    }
}
function getRandomColor() {
    const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
        '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

function renderAreas() {
    // Remove existing area overlays
    document.querySelectorAll('.selection-box').forEach(box => box.remove());
    
    areas.forEach(area => {
        if (!area.visible) return;
        
        const minRow = area.minRow;
        const maxRow = area.maxRow;
        const minCol = area.minCol;
        const maxCol = area.maxCol;
        
        // Find the top-left and bottom-right cells
        const topLeftCell = document.querySelector(`[data-row="${minRow}"][data-col="${minCol}"]`);
        const bottomRightCell = document.querySelector(`[data-row="${maxRow}"][data-col="${maxCol}"]`);
        
        if (topLeftCell && bottomRightCell) {
            const grid = document.getElementById('treeGrid');
            const gridRect = grid.getBoundingClientRect();
            const topLeftRect = topLeftCell.getBoundingClientRect();
            const bottomRightRect = bottomRightCell.getBoundingClientRect();
            
            const overlay = document.createElement('div');
            overlay.className = 'selection-box';
            overlay.style.borderColor = area.color;
            overlay.style.backgroundColor = area.color + '20'; // 20% opacity
            
            // Position relative to grid
            overlay.style.position = 'absolute';
            overlay.style.left = (topLeftRect.left - gridRect.left + grid.scrollLeft) + 'px';
            overlay.style.top = (topLeftRect.top - gridRect.top + grid.scrollTop) + 'px';
            overlay.style.width = (bottomRightRect.right - topLeftRect.left) + 'px';
            overlay.style.height = (bottomRightRect.bottom - topLeftRect.top) + 'px';
            
            // Add label
            const label = document.createElement('div');
            label.className = 'selection-box-label';
            label.textContent = area.name;
            label.style.backgroundColor = area.color;
            overlay.appendChild(label);
            
            grid.style.position = 'relative';
            grid.appendChild(overlay);
        }
    });
}
function loadLineAreasFromStorage() {
    try {
        // Use dome-specific storage key
        const stored = localStorage.getItem(`lineAreas_dome_${domeId}`);
        if (stored) {
            const parsedAreas = JSON.parse(stored);
            
            // Validate the data structure
            if (Array.isArray(parsedAreas)) {
                areas = parsedAreas.map(area => ({
                    ...area,
                    visible: area.visible !== false, // Default to visible
                    cells: area.cells || []
                }));
                
                console.log('✅ Line areas loaded from storage:', areas);
                
                // Update the counter
                if (areas.length > 0) {
                    areaIdCounter = Math.max(...areas.map(a => a.id)) + 1;
                }
                
                return true;
            }
        }
        
        // Also try loading from global storage (for backward compatibility)
        const globalStored = localStorage.getItem('lineAreas');
        if (globalStored) {
            const parsedAreas = JSON.parse(globalStored);
            if (Array.isArray(parsedAreas)) {
                areas = parsedAreas.map(area => ({
                    ...area,
                    visible: area.visible !== false,
                    cells: area.cells || []
                }));
                
                console.log('✅ Line areas loaded from global storage:', areas);
                
                // Migrate to dome-specific storage
                saveLineAreasToStorage();
                
                return true;
            }
        }
        
        console.log('No line areas found in storage');
        return false;
        
    } catch (error) {
        console.error('❌ Error loading line areas from storage:', error);
        areas = [];
        return false;
    }
}
function renderLineAreas() {
    try {
        console.log('🎨 Rendering line areas:', areas.length);
        
        // Remove existing area overlays
        document.querySelectorAll('.area-overlay').forEach(overlay => {
            overlay.remove();
        });
        
        // Render each area
        areas.forEach(area => {
            if (area.visible && area.cells && area.cells.length > 0) {
                renderAreaOverlay(area);
            }
        });
        
        console.log('✅ Line areas rendered successfully');
        
    } catch (error) {
        console.error('❌ Error rendering line areas:', error);
    }
}
function updateLineAreasDisplay() {
    try {
        const container = document.getElementById('lineAreasContainer');
        const areasList = document.getElementById('lineAreasList');
        
        if (!container || !areasList) {
            console.error('❌ Line areas container not found');
            return;
        }
        
        if (areas.length === 0) {
            areasList.style.display = 'none';
            return;
        }
        
        areasList.style.display = 'block';
        
        container.innerHTML = areas.map(area => `
            <div class="area-item" style="border-left: 4px solid ${area.color};">
                <div style="display: flex; align-items: center;">
                    <div class="area-color" style="background-color: ${area.color};"></div>
                    <div class="area-info">
                        <strong>${area.name}</strong><br>
                        <small>${area.cells.length} cells selected</small><br>
                        <small style="color: #666;">Created: ${area.created_at ? new Date(area.created_at).toLocaleString() : 'Unknown'}</small>
                    </div>
                </div>
                <div class="area-actions">
                    <button class="area-btn toggle" onclick="toggleAreaVisibility(${area.id})" title="Show/Hide">
                        ${area.visible ? '👁️' : '🙈'}
                    </button>
                    <button class="area-btn copy" onclick="copyArea(${area.id})" title="Copy">📋</button>
                    <button class="area-btn edit" onclick="editArea(${area.id})" title="Edit">✏️</button>
                    <button class="area-btn delete" onclick="deleteArea(${area.id})" title="Delete">🗑️</button>
                </div>
            </div>
        `).join('');
        
        console.log('✅ Line areas display updated');
        
    } catch (error) {
        console.error('❌ Error updating line areas display:', error);
    }
}
function saveLineAreasToStorage() {
    try {
        // Save to dome-specific storage
        localStorage.setItem(`lineAreas_dome_${domeId}`, JSON.stringify(areas));
        localStorage.setItem(`areaIdCounter_dome_${domeId}`, areaIdCounter.toString());
        
        console.log('✅ Line areas saved to storage:', areas.length, 'areas');
        
    } catch (error) {
        console.error('❌ Error saving line areas to storage:', error);
    }
}
function updateAreasDisplay() {
    const container = document.getElementById('areasContainer');
    
    if (areas.length === 0) {
        container.innerHTML = '<p>No areas created yet</p>';
        return;
    }
    
    container.innerHTML = areas.map(area => `
        <div class="area-item">
            <div style="display: flex; align-items: center;">
                <div class="area-color" style="background-color: ${area.color};"></div>
                <div class="area-info">
                    <strong>${area.name}</strong><br>
                    <small>${area.cells.length} cells (${area.width}×${area.height}) at (${area.minRow},${area.minCol})</small>
                </div>
            </div>
            <div class="area-actions">
                <button class="area-btn toggle" onclick="toggleAreaVisibility(${area.id})" title="Show/Hide">
                    ${area.visible ? '👁️' : '🙈'}
                </button>
                <button class="area-btn copy" onclick="copyArea(${area.id})" title="Copy">📋</button>
                <button class="area-btn edit" onclick="editArea(${area.id})" title="Edit">✏️</button>
                <button class="area-btn delete" onclick="deleteArea(${area.id})" title="Delete">🗑️</button>
            </div>
        </div>
    `).join('');
}

function toggleAreaVisibility(areaId) {
    const area = areas.find(a => a.id === areaId);
    if (area) {
        area.visible = !area.visible;
        renderAreas();
        updateAreasDisplay();
        showStatus(`Area "${area.name}" ${area.visible ? 'shown' : 'hidden'}`, 'info');
    }
}

async function editArea(areaId) {
    const area = areas.find(a => a.id === areaId);
    if (!area) return;
    
    const newName = prompt('Enter new area name:', area.name);
    if (newName && newName.trim() && newName.trim() !== area.name) {
        // Check if new name already exists
        if (areas.some(a => a.name === newName.trim() && a.id !== areaId)) {
            alert('Area name already exists. Please choose a different name.');
            return;
        }
        
        // Update in database first
        const updated = await updateAreaInDatabase(areaId, { name: newName.trim() });
        
        if (updated) {
            area.name = newName.trim();
            renderAreas();
            updateAreasDisplay();
            showStatus(`Area renamed to "${area.name}"`, 'success');
        } else {
            showStatus(`Failed to rename area`, 'error');
        }
    }
}
function debugSelection() {
    console.log('=== SELECTION DEBUG ===');
    console.log('Selection mode:', selectionMode);
    console.log('Is selecting:', isSelecting);
    console.log('Selection start:', selectionStart);
    console.log('Selection end:', selectionEnd);
    console.log('Selected cells:', selectedCells);
    
    // Test if cells exist
    const testCell = document.querySelector('[data-row="0"][data-col="0"]');
    console.log('Test cell found:', !!testCell);
    
    if (testCell) {
        console.log('Test cell classes:', testCell.className);
        testCell.classList.add('selecting');
        console.log('Added selecting class to test cell');
        
        setTimeout(() => {
            testCell.classList.remove('selecting');
            console.log('Removed selecting class from test cell');
        }, 2000);
    }
    
    console.log('===================');
}

// Make it globally accessible

async function updateAreaInDatabase(areaId, updates) {
    try {
        const response = await fetch(`/api/dome/${domeId}/areas/${areaId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(updates)
        });
        
        const result = await response.json();
        return result.success;
    } catch (error) {
        console.error('Error updating area in database:', error);
        return false;
    }
}
async function copyArea(areaId) {
    try {
        showStatus('Copying area with trees...', 'info');
        console.log('📋 Copying area ID:', areaId);
        
        // ✅ CRITICAL: Use your backend API to copy regular area
        const response = await fetch(`/api/copy_regular_area/${domeId}/${areaId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const data = await response.json();
        console.log('Copy response:', data);
        
        if (data.success) {
            // ✅ CRITICAL: Store the complete area data with trees
            clipboardArea = data.area;
            
            // ✅ Save to global storage
            localStorage.setItem('globalRegularClipboard', JSON.stringify(clipboardArea));
            localStorage.setItem('globalRegularClipboardTimestamp', Date.now().toString());
            
            // ✅ Update UI
            updatePasteButtonVisibility();
            
            const successMessage = `Area "${clipboardArea.name}" copied with ${clipboardArea.tree_count} trees!`;
            showStatus(successMessage, 'success');
            
            console.log('✅ Area copied successfully:', clipboardArea);
            
        } else {
            console.error('❌ Copy failed:', data.error);
            showStatus('Failed to copy area: ' + data.error, 'error');
        }
        
    } catch (error) {
        console.error('❌ Error copying area:', error);
        showStatus('Error copying area: ' + error.message, 'error');
    }
}
// ✅ NEW: Global regular clipboard functions
function saveGlobalRegularClipboard() {
    try {
        if (clipboardArea) {
            localStorage.setItem('globalRegularClipboard', JSON.stringify(clipboardArea));
            localStorage.setItem('globalRegularClipboardTimestamp', Date.now().toString());
            console.log('✅ Global regular clipboard saved:', clipboardArea.name);
        }
    } catch (error) {
        console.error('❌ Failed to save global regular clipboard:', error);
    }
}

function loadGlobalRegularClipboard() {
    try {
        const stored = localStorage.getItem('globalRegularClipboard');
        const timestamp = localStorage.getItem('globalRegularClipboardTimestamp');
        
        if (stored) {
            const storedData = JSON.parse(stored);
            const age = Date.now() - parseInt(timestamp || '0');
            
            // Only load if less than 1 hour old
            if (age < 3600000) {
                clipboardArea = storedData;
                console.log('✅ Global regular clipboard loaded:', clipboardArea.name);
                return true;
            } else {
                console.log('⚠️ Global regular clipboard expired, clearing...');
                clearGlobalRegularClipboard();
            }
        }
    } catch (error) {
        console.error('❌ Failed to load global regular clipboard:', error);
    }
    return false;
}
function loadGlobalDragClipboard() {
    try {
        const stored = localStorage.getItem('globalDragClipboard');
        const timestamp = localStorage.getItem('globalDragClipboardTimestamp');
        
        if (stored) {
            const storedData = JSON.parse(stored);
            const age = Date.now() - parseInt(timestamp || '0');
            
            // Only load if less than 1 hour old
            if (age < 3600000) {
                dragClipboard = storedData;
                console.log('✅ Global drag clipboard loaded:', dragClipboard.name);
                return true;
            } else {
                console.log('⚠️ Global drag clipboard expired, clearing...');
                clearGlobalDragClipboard();
            }
        }
    } catch (error) {
        console.error('❌ Failed to load global drag clipboard:', error);
    }
    return false;
}
function saveGlobalDragClipboard() {
    try {
        if (dragClipboard) {
            localStorage.setItem('globalDragClipboard', JSON.stringify(dragClipboard));
            localStorage.setItem('globalDragClipboardTimestamp', Date.now().toString());
            console.log('✅ Global drag clipboard saved:', dragClipboard.name);
        }
    } catch (error) {
        console.error('❌ Failed to save global drag clipboard:', error);
    }
}
function clearGlobalRegularClipboard() {
    try {
        localStorage.removeItem('globalRegularClipboard');
        localStorage.removeItem('globalRegularClipboardTimestamp');
        clipboardArea = null;
        console.log('✅ Global regular clipboard cleared');
    } catch (error) {
        console.error('❌ Failed to clear global regular clipboard:', error);
    }
}
function broadcastClipboardUpdate(type, data) {
    try {
        const message = {
            type: 'clipboard_update',
            clipboard_type: type,
            data: data,
            timestamp: Date.now(),
            source_dome: domeId
        };
        
        localStorage.setItem('clipboardBroadcast', JSON.stringify(message));
        
        setTimeout(() => {
            localStorage.removeItem('clipboardBroadcast');
        }, 1000);
        
        console.log('📡 Clipboard update broadcasted:', message);
    } catch (error) {
        console.error('❌ Failed to broadcast clipboard update:', error);
    }
}
function saveClipboardToStorage() {
    try {
        if (clipboardArea) {
            localStorage.setItem('clipboardArea', JSON.stringify(clipboardArea));
            console.log('✅ Clipboard area saved to storage');
        }
    } catch (error) {
        console.error('❌ Failed to save clipboard area:', error);
    }
}
function showPasteControls() {
    // ✅ ENHANCED: Check for any available clipboard
    let clipboard = dragClipboard || clipboardArea;
    
    // If no local clipboard, check global storage
    if (!clipboard) {
        const globalDrag = localStorage.getItem('globalDragClipboard');
        const globalRegular = localStorage.getItem('globalRegularClipboard');
        
        if (globalDrag) {
            clipboard = JSON.parse(globalDrag);
            dragClipboard = clipboard; // Load into local variable
        } else if (globalRegular) {
            clipboard = JSON.parse(globalRegular);
            clipboardArea = clipboard; // Load into local variable
        }
    }
    
    if (!clipboard) {
        showStatus('No area in clipboard', 'warning');
        return;
    }
}
function executeSmartPaste() {
    const clipboard = dragClipboard || clipboardArea;
    if (!clipboard) {
        showStatus('No area in clipboard', 'error');
        return;
    }
    
    console.log('🤖 Executing smart paste...');
    
    // Find the best empty position
    const position = findBestPastePosition(clipboard);
    if (!position) {
        showStatus('No suitable position found for pasting. Try manual positioning.', 'error');
        return;
    }
    
    console.log(`🎯 Smart paste position found: (${position.row}, ${position.col})`);
    executePasteAtPosition(position.row, position.col);
}


function findBestPastePosition(clipboard) {
    const { width, height } = clipboard;
    
    console.log(`🔍 Looking for position for ${width}×${height} area...`);
    
    // Try to find a position where the area fits completely
    for (let row = 0; row <= currentRows - height; row++) {
        for (let col = 0; col <= currentCols - width; col++) {
            if (isValidPastePosition(row, col, clipboard)) {
                console.log(`✅ Found valid position: (${row}, ${col})`);
                return { row, col };
            }
        }
    }
    
    console.log('❌ No valid position found');
    return null;
}
function isValidPastePosition(row, col, clipboard = null) {
const cb = clipboard || dragClipboard || clipboardArea;
if (!cb) return false;

// Check grid boundaries
if (row + cb.height > currentRows ||
col + cb.width > currentCols ||
row < 0 || col < 0) {
return false;
}

// Only check for existing trees, not areas (allow pasting in empty areas)
for (let r = row; r < row + cb.height; r++) {
for (let c = col; c < col + cb.width; c++) {
// Check for existing trees only
const existingTree = trees.find(t => t.internal_row === r && t.internal_col === c);
if (existingTree) {
return false;
}
}
}

return true;
}
function showManualPasteDialog() {
    const clipboard = dragClipboard || clipboardArea;
    if (!clipboard) {
        showStatus('No area in clipboard', 'warning');
        return;
    }
    
    const modal = document.createElement('div');
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 12px;
                padding: 25px;
                max-width: 450px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            " onclick="event.stopPropagation();">
                <h5 style="margin: 0 0 20px 0; color: #9c27b0;">📍 Manual Paste Position</h5>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px;">
                        <div><strong>Area:</strong> ${clipboard.name}</div>
                        <div><strong>Size:</strong> ${clipboard.width}×${clipboard.height}</div>
                        <div><strong>Trees:</strong> ${clipboard.trees ? clipboard.trees.length : 0}</div>
                        <div><strong>Type:</strong> ${clipboard.type || 'Regular'}</div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Start Row:</label>
                        <input type="number" id="manual-paste-row" value="0" min="0" max="${currentRows - clipboard.height}" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Start Col:</label>
                        <input type="number" id="manual-paste-col" value="0" min="0" max="${currentCols - clipboard.width}" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                    <button onclick="executeManualPaste(); this.closest('[style*=\"position: fixed\"]').remove();" style="padding: 10px 20px; background: #9c27b0; color: white; border: none; border-radius: 6px; cursor: pointer;">📍 Paste Here</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    setTimeout(() => {
        document.getElementById('manual-paste-row').focus();
    }, 100);
}

function executeManualPaste() {
    const row = parseInt(document.getElementById('manual-paste-row').value);
    const col = parseInt(document.getElementById('manual-paste-col').value);
    
    const clipboard = dragClipboard || clipboardArea;
    
    if (isNaN(row) || isNaN(col)) {
        alert('Please enter valid row and column numbers');
        return;
    }
    
    if (!isValidPastePosition(row, col, clipboard)) {
        alert('Invalid position - area would overlap existing content or extend outside grid');
        return;
    }
    
    executePasteAtPosition(row, col);
}
function loadClipboardFromStorage() {
    try {
        const stored = localStorage.getItem('clipboardArea');
        if (stored) {
            clipboardArea = JSON.parse(stored);
            console.log('✅ Clipboard area loaded from storage:', clipboardArea);
            
            // Update UI to show clipboard is available
            if (typeof updatePasteButtonVisibility === 'function') {
                updatePasteButtonVisibility();
            }
            
            return true;
        }
    } catch (error) {
        console.error('❌ Failed to load clipboard area:', error);
    }
    return false;
}
function enablePasteMode() {
    if (!clipboardArea) {
        showStatus('No area in clipboard to paste', 'warning');
        return;
    }
    
    pasteMode = true;
    
    // ✅ CRITICAL: Show the paste controls container
    const pasteControls = document.getElementById('pasteControls');
    if (pasteControls) {
        pasteControls.style.display = 'block';
        console.log('✅ Paste controls shown');
    } else {
        console.error('❌ pasteControls element not found');
    }
    
    // ✅ CRITICAL: Show the click to paste button
    const clickToPasteBtn = document.getElementById('clickToPasteBtn');
    if (clickToPasteBtn) {
        clickToPasteBtn.style.display = 'inline-block';
        clickToPasteBtn.textContent = `🎯 Click to Paste "${clipboardArea.name}"`;
        console.log('✅ Click to paste button shown');
    } else {
        console.error('❌ clickToPasteBtn element not found');
    }
    
    updatePastePreview();
    
    showStatus(`Paste mode enabled for "${clipboardArea.name}". Choose location or click "Click to Paste".`, 'info');
}

function handlePasteClick(e) {
    if (!pasteMode || !clipboardArea) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const cell = e.currentTarget;
    const startRow = parseInt(cell.dataset.row);
    const startCol = parseInt(cell.dataset.col);
    
    pasteOffset = { row: startRow, col: startCol };
    
    // Check if paste area fits in grid
    const endRow = startRow + clipboardArea.height - 1;
    const endCol = startCol + clipboardArea.width - 1;
    
    if (endRow >= currentRows || endCol >= currentCols) {
        alert(`Cannot paste here. Area would extend beyond grid boundaries.\nRequired space: ${clipboardArea.width}×${clipboardArea.height}\nAvailable from (${startRow},${startCol}): ${currentCols - startCol}×${currentRows - startRow}`);
        return;
    }
    
    // Show preview of paste area
    showPastePreview(startRow, startCol);
}

function showPastePreview(startRow, startCol) {
    // Clear previous preview
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('selecting');
    });
    
    // Highlight paste area
    clipboardArea.cells.forEach(relativeCell => {
        const absoluteRow = startRow + relativeCell.row;
        const absoluteCol = startCol + relativeCell.col;
        const cell = document.querySelector(`[data-row="${absoluteRow}"][data-col="${absoluteCol}"]`);
        if (cell) {
            cell.classList.add('selecting');
        }
    });
    
    // Update paste preview
    const pastePreview = document.getElementById('pastePreview');
    pastePreview.innerHTML = `
        <strong>Paste preview:</strong> "${clipboardArea.name}"<br>
        <strong>Position:</strong> (${startRow},${startCol}) to (${startRow + clipboardArea.height - 1},${startCol + clipboardArea.width - 1})<br>
        <strong>Size:</strong> ${clipboardArea.width}×${clipboardArea.height}<br>
        <div style="margin-top: 8px; padding: 4px; background: #e8f5e8; border-radius: 4px;">
            ✅ Ready to paste! Click "Paste Here" to confirm.
        </div>
    `;
}

async function pasteArea() {
    if (!clipboardArea) {
        showStatus('No area in clipboard', 'error');
        return;
    }
    
    try {
        showStatus('Pasting area with trees...', 'info');
        
        // Generate unique area name
        let newAreaName = `${clipboardArea.name} Copy`;
        let counter = 1;
        while (areas.some(a => a.name === newAreaName)) {
            newAreaName = `${clipboardArea.name} Copy ${counter}`;
            counter++;
        }
        
        // Find empty position for the area
        const pastePosition = findEmptyAreaPosition(clipboardArea.width, clipboardArea.height);
        if (!pastePosition) {
            showStatus('No space available to paste this area', 'error');
            return;
        }
        
        const { row: pasteRow, col: pasteCol } = pastePosition;
        
        // ✅ ENHANCED: Create trees first
        const newTreeIds = [];
        
        if (clipboardArea.trees && clipboardArea.trees.length > 0) {
            for (const treeData of clipboardArea.trees) {
                const newRow = pasteRow + treeData.relativeRow;
                const newCol = pasteCol + treeData.relativeCol;
                
                // ✅ FIXED: Include breed in API request
                const treeResponse = await fetch('/add_tree', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        dome_id: domeId,
                        internal_row: newRow,
                        internal_col: newCol,
                        name: treeData.name || `Tree ${newRow}-${newCol}`,
                        breed: treeData.breed || '',  // ✅ ADD BREED FIELD
                        life_days: treeData.life_days || 0,
                        info: treeData.info || '',
                        image_url: treeData.image_url || ''
                    })
                });
                
                const treeResult = await treeResponse.json();
                
                if (treeResult.success) {
                    // ✅ FIXED: Include breed in local tree object
                    trees.push({
                        id: treeResult.tree_id,
                        name: treeData.name || `Tree ${newRow}-${newCol}`,
                        breed: treeData.breed || '',  // ✅ ADD BREED FIELD
                        internal_row: newRow,
                        internal_col: newCol,
                        life_days: treeData.life_days || 0,
                        info: treeData.info || '',
                        image_url: treeData.image_url || '',
                        dome_id: domeId
                    });
                    
                    newTreeIds.push(treeResult.tree_id);
                    
                    // ✅ ENHANCED: Log breed information
                    const breedInfo = treeData.breed ? `(breed: ${treeData.breed})` : '(no breed)';
                    console.log(`✅ Tree created at (${newRow}, ${newCol}): ${treeData.name} ${breedInfo}`);
                } else {
                    console.error('Failed to create tree:', treeResult.error);
                }
            }
        }
        
        // Create the area with tree IDs
        const newArea = {
            name: newAreaName,
            color: clipboardArea.color,
            min_row: pasteRow,
            max_row: pasteRow + clipboardArea.height - 1,
            min_col: pasteCol,
            max_col: pasteCol + clipboardArea.width - 1,
            width: clipboardArea.width,
            height: clipboardArea.height,
            tree_ids: newTreeIds // ✅ ADDED: Include tree IDs
        };
        
        // Save area to backend
        const areaResponse = await fetch(`/save_area/${domeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(newArea)
        });
        
        const areaResult = await areaResponse.json();
        
        if (areaResult.success) {
            // Add to local areas array
            areas.push({
                id: areaResult.area_id,
                ...newArea,
                visible: true
            });
            
            // Re-render everything
            renderGrid();
            renderAreas();
            updateAreasDisplay();
            updateStats();
            
            // ✅ ENHANCED: Show breed information in success message
            const breedCount = [...new Set(clipboardArea.trees.map(t => t.breed).filter(b => b))].length;
            const breedInfo = breedCount > 0 ? ` with ${breedCount} breeds` : '';
            
            showStatus(`Area "${newAreaName}" pasted with ${newTreeIds.length} trees${breedInfo} at (${pasteRow}, ${pasteCol})!`, 'success');
            console.log('✅ Area pasted successfully:', {
                area: newAreaName,
                position: `(${pasteRow}, ${pasteCol})`,
                trees: newTreeIds.length,
                breeds: breedCount
            });
            
        } else {
            showStatus('Failed to save area: ' + areaResult.error, 'error');
        }
        
    } catch (error) {
        console.error('Error pasting area:', error);
        showStatus('Error pasting area: ' + error.message, 'error');
    }
}
async function loadAreasFromBackend() {
    try {
        console.log('🔄 Loading areas from backend...');
        
        // ✅ Load drag areas
        try {
            const dragResponse = await fetch(`/api/get_drag_areas/${domeId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (dragResponse.ok) {
                const dragResult = await dragResponse.json();
                
                if (dragResult.success && dragResult.drag_areas) {
                    // ✅ Convert backend data to frontend format
                    dragAreas = dragResult.drag_areas.map(area => ({
                        id: area.id,
                        name: area.name,
                        color: area.color || '#007bff',
                        width: area.width,
                        height: area.height,
                        minRow: area.minRow,
                        maxRow: area.maxRow,
                        minCol: area.minCol,
                        maxCol: area.maxCol,
                        trees: area.trees || [],
                        tree_count: area.tree_count || 0,
                        visible: area.visible !== false,
                        created_at: area.createdAt || area.created_at,
                        saved_to_db: true
                    }));
                    
                    console.log(`✅ Loaded ${dragAreas.length} drag areas from backend`);
                } else {
                    console.log('No drag areas found in backend');
                    dragAreas = [];
                }
            } else {
                console.warn('❌ Failed to load drag areas from backend:', dragResponse.status);
                dragAreas = [];
            }
        } catch (dragError) {
            console.error('❌ Error loading drag areas:', dragError);
            dragAreas = [];
        }
        
        // ✅ Load regular areas
        try {
            const regularResponse = await fetch(`/api/regular_areas/${domeId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (regularResponse.ok) {
                const regularResult = await regularResponse.json();
                
                if (regularResult.success && regularResult.regular_areas) {
                    // ✅ Convert backend data to frontend format
                    areas = regularResult.regular_areas.map(area => ({
                        id: area.id,
                        name: area.name,
                        color: area.color || '#28a745',
                        width: area.width,
                        height: area.height,
                        min_row: area.min_row,
                        max_row: area.max_row,
                        min_col: area.min_col,
                        max_col: area.max_col,
                        cells: area.cells || [],
                        tree_count: area.tree_count || 0,
                        visible: area.visible !== false,
                        created_at: area.created_at,
                        saved_to_db: true
                    }));
                    
                    console.log(`✅ Loaded ${areas.length} regular areas from backend`);
                } else {
                    console.log('No regular areas found in backend');
                    areas = [];
                }
            } else {
                console.warn('❌ Failed to load regular areas from backend:', regularResponse.status);
                areas = [];
            }
        } catch (regularError) {
            console.error('❌ Error loading regular areas:', regularError);
            areas = [];
        }
        
        // ✅ Update displays after loading
        if (typeof updateDragAreasDisplay === 'function') {
            updateDragAreasDisplay();
        }
        if (typeof updateAreasDisplay === 'function') {
            updateAreasDisplay();
        }
        
        // ✅ CRITICAL: Re-render grid to show loaded areas
        renderGrid();
        
        console.log(`✅ Areas loading completed: ${dragAreas.length} drag areas, ${areas.length} regular areas`);
        
        return true;
        
    } catch (error) {
        console.error('❌ Error loading areas from backend:', error);
        return false;
    }
}
setTimeout(() => {
    console.log('🔄 Force rendering all areas after backend load...');
    forceRenderAllAreas();
}, 100);
// Add this debugging function to help identify the issue
async function debugColorUpdate(areaId, newColor) {
    console.log('🔍 DEBUG: Starting color update process...');
    console.log('🔍 DEBUG: Area ID:', areaId);
    console.log('🔍 DEBUG: New Color:', newColor);
    console.log('🔍 DEBUG: Dome ID:', domeId);
    
    // Check if area exists locally
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        console.error('❌ DEBUG: Area not found in local dragAreas array');
        console.log('🔍 DEBUG: Available drag areas:', dragAreas.map(a => ({id: a.id, name: a.name, color: a.color})));
        return false;
    }
    
    console.log('✅ DEBUG: Found area locally:', {
        id: area.id,
        name: area.name,
        currentColor: area.color,
        newColor: newColor
    });
    
    // Test the API endpoint
    const apiUrl = `/api/update_drag_area_color/${domeId}/${areaId}`;
    console.log('🔍 DEBUG: API URL:', apiUrl);
    
    try {
        console.log('🔍 DEBUG: Sending request to backend...');
        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                color: newColor
            })
        });
        
        console.log('🔍 DEBUG: Response status:', response.status);
        console.log('🔍 DEBUG: Response ok:', response.ok);
        
        const responseText = await response.text();
        console.log('🔍 DEBUG: Raw response:', responseText);
        
        let result;
        try {
            result = JSON.parse(responseText);
            console.log('🔍 DEBUG: Parsed response:', result);
        } catch (parseError) {
            console.error('❌ DEBUG: Failed to parse response as JSON:', parseError);
            console.log('🔍 DEBUG: Response was not valid JSON:', responseText);
            return false;
        }
        
        if (response.ok && result.success) {
            console.log('✅ DEBUG: Backend update successful');
            
            // Update local area
            area.color = newColor;
            console.log('✅ DEBUG: Local area updated');
            
            // Re-render
            renderGrid();
            updateDragAreasDisplay();
            
            // Verify the change was saved by immediately fetching from backend
            console.log('🔍 DEBUG: Verifying change was saved...');
            setTimeout(async () => {
                await verifyColorUpdate(areaId, newColor);
            }, 500);
            
            return true;
        } else {
            console.error('❌ DEBUG: Backend update failed');
            console.log('🔍 DEBUG: Response details:', {
                status: response.status,
                ok: response.ok,
                result: result
            });
            return false;
        }
        
    } catch (error) {
        console.error('❌ DEBUG: Network error:', error);
        return false;
    }
}

// Add this verification function
async function verifyColorUpdate(areaId, expectedColor) {
    console.log('🔍 VERIFY: Checking if color was saved to database...');
    
    try {
        const response = await fetch(`/api/get_drag_areas/${domeId}`);
        if (response.ok) {
            const result = await response.json();
            if (result.success && result.drag_areas) {
                const savedArea = result.drag_areas.find(a => a.id === areaId);
                if (savedArea) {
                    console.log('🔍 VERIFY: Area found in database:', {
                        id: savedArea.id,
                        name: savedArea.name,
                        savedColor: savedArea.color,
                        expectedColor: expectedColor,
                        match: savedArea.color === expectedColor
                    });
                    
                    if (savedArea.color === expectedColor) {
                        console.log('✅ VERIFY: Color was successfully saved to database!');
                    } else {
                        console.error('❌ VERIFY: Color in database does not match expected color!');
                        console.log('🔍 VERIFY: This indicates the backend update failed silently');
                    }
                } else {
                    console.error('❌ VERIFY: Area not found in database response');
                }
            }
        }
    } catch (error) {
        console.error('❌ VERIFY: Error checking database:', error);
    }
}

// Add this function to check your current update function
function checkCurrentUpdateFunction() {
    console.log('🔍 DEBUG: Checking if updateDragAreaColor function exists...');
    
    if (typeof updateDragAreaColor === 'function') {
        console.log('✅ DEBUG: updateDragAreaColor function exists');
        console.log('🔍 DEBUG: Function source:', updateDragAreaColor.toString().substring(0, 200) + '...');
    } else {
        console.error('❌ DEBUG: updateDragAreaColor function does not exist!');
        console.log('🔍 DEBUG: Available functions:', Object.getOwnPropertyNames(window).filter(name => name.includes('update')));
    }
}

// Run diagnostics
console.log('🔍 DEBUG: Running color update diagnostics...');
checkCurrentUpdateFunction();
// Add this helper function
async function retryDatabaseUpdate(updateFunction, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const result = await updateFunction();
            if (result) return true;
        } catch (error) {
            console.warn(`Retry ${i + 1}/${maxRetries} failed:`, error);
        }
        if (i < maxRetries - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
        }
    }
    return false;
}
function cancelPaste() {
    disableClickToPaste();
    hidePasteControls();
    showStatus('Paste cancelled', 'info');
}
function hidePasteControls() {
    const controls = document.getElementById('pasteControls');
    const clipboardStatus = document.getElementById('clipboardStatus');
    
    if (controls) {
        controls.style.display = 'none';
    }
    
    if (clipboardStatus) {
        clipboardStatus.style.display = 'none';
    }
}
function showPastePreviewUnified(e) {
    if (!clickToPasteMode) return;
    
    const cell = e.target.closest('.grid-cell');
    if (!cell) return;
    
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    if (isNaN(row) || isNaN(col)) return;
    
    const clipboard = dragClipboard || clipboardArea;
    if (!clipboard) return;
    
    // Show preview of where the area would be pasted
    const width = clipboard.width || 1;
    const height = clipboard.height || 1;
    
    // Remove existing preview
    document.querySelectorAll('.paste-preview-overlay').forEach(el => el.remove());
    
    // Check if paste position is valid
    const isValid = isValidPastePosition(row, col, clipboard);
    
    // Create preview overlay
    const overlay = document.createElement('div');
    overlay.className = `paste-preview-overlay ${isValid ? '' : 'paste-invalid'}`;
    overlay.style.cssText = `
        position: absolute;
        top: ${cell.offsetTop}px;
        left: ${cell.offsetLeft}px;
        width: ${width * (cell.offsetWidth + 8)}px;
        height: ${height * (cell.offsetHeight + 8)}px;
        pointer-events: none;
        z-index: 100;
        border: 3px dashed ${isValid ? '#28a745' : '#dc3545'};
        background: ${isValid ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)'};
        border-radius: 6px;
    `;
    
    cell.parentElement.appendChild(overlay);
    
    // Remove preview after a short delay
    setTimeout(() => {
        if (overlay.parentElement) {
            overlay.remove();
        }
    }, 2000);
}
function hidePastePreviewUnified(e) {
    if (!clickToPasteMode) return;
    
    // Remove all paste preview overlays
    document.querySelectorAll('.paste-preview-overlay').forEach(el => el.remove());
}
        async function swapTrees(treeId1, treeId2) {
            try {
                showStatus('Swapping trees...', 'info');
                document.getElementById('swapIndicator').style.display = 'block';
                
                const response = await fetch('/swap_trees', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tree1_id: treeId1,
                        tree2_id: treeId2
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update local tree data
                    const tree1 = trees.find(t => t.id == treeId1);
                    const tree2 = trees.find(t => t.id == treeId2);
                    
                    if (tree1 && tree2) {
                        const tempRow = tree1.internal_row;
                        const tempCol = tree1.internal_col;
                        
                        tree1.internal_row = tree2.internal_row;
                        tree1.internal_col = tree2.internal_col;
                        tree2.internal_row = tempRow;
                        tree2.internal_col = tempCol;
                    }
                    
                    renderGrid();
                    updateStats();
                    showStatus('Trees swapped successfully!', 'success');
                } else {
                    showStatus('Failed to swap trees: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error swapping trees:', error);
                showStatus('Error swapping trees', 'error');
            } finally {
                document.getElementById('swapIndicator').style.display = 'none';
            }
        }



// ✅ NEW: Create tree creation modal
// ✅ ENHANCED: Breed Management with Remove Functionality and Backend Storage
let treeBreeds = [];
let breedSyncInProgress = false;

// ✅ STEP 2: Core breed management functions
async function loadBreedsFromBackend() {
    try {
        console.log('📡 Loading breeds from backend...');
        
        // Get farm ID
        let currentFarmId = null;
        
        if (typeof farmId !== 'undefined' && farmId) {
            currentFarmId = farmId;
        } else if (typeof dome !== 'undefined' && dome && dome.farm_id) {
            currentFarmId = dome.farm_id;
        } else if (typeof domeId !== 'undefined' && domeId) {
            // Try to get farm ID from dome
            try {
                const domeResponse = await fetch(`/api/dome/${domeId}/info`);
                if (domeResponse.ok) {
                    const domeData = await domeResponse.json();
                    if (domeData.success && domeData.dome && domeData.dome.farm_id) {
                        currentFarmId = domeData.dome.farm_id;
                        window.farmId = currentFarmId;
                    }
                }
            } catch (domeError) {
                console.warn('⚠️ Could not get farm ID from dome:', domeError);
            }
        }
        
        if (!currentFarmId) {
            console.warn('⚠️ No farm ID available, skipping backend breed loading');
            return false;
        }
        
        const response = await fetch(`/api/farm/${currentFarmId}/breeds`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (response.ok) {
            const result = await response.json();
            if (result.success && result.breeds) {
                // ✅ FIXED: Handle both string arrays and object arrays
                const breedNames = result.breeds.map(breed => {
                    if (typeof breed === 'string') {
                        return breed;
                    } else if (typeof breed === 'object' && breed.name) {
                        return breed.name;
                    } else {
                        return String(breed);
                    }
                });
                
                // ✅ FIXED: Replace local array with backend data
                treeBreeds.length = 0; // Clear existing array
                treeBreeds.push(...breedNames);
                treeBreeds.sort(); // Keep alphabetical order
                
                // Save to localStorage as backup
                localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                localStorage.setItem(`farm_${currentFarmId}_breeds`, JSON.stringify(treeBreeds));
                
                console.log('✅ Breeds loaded from backend:', treeBreeds);
                return true;
            }
        } else if (response.status === 404) {
            console.log('ℹ️ No breeds endpoint found, using localStorage only');
            return false;
        }
    } catch (error) {
        console.warn('⚠️ Failed to load breeds from backend:', error);
        return false;
    }
    
    return false;
}


async function loadTrees() {
    try {
        console.log('🌳 Loading trees from backend...');
        
        const response = await fetch(`/api/trees/${domeId}`);
        if (response.ok) {
            const result = await response.json();
            if (result.success && result.trees) {
                trees = result.trees;
                
                // ✅ DEBUG: Check if breed data is included
                console.log(`✅ Loaded ${trees.length} trees`);
                const treesWithBreeds = trees.filter(t => t.breed && t.breed.trim().length > 0);
                console.log(`🧬 Trees with breeds: ${treesWithBreeds.length}`);
                
                if (treesWithBreeds.length > 0) {
                    console.log('🧬 Breeds found:', treesWithBreeds.map(t => `${t.name}: ${t.breed}`));
                }
                
                // ✅ DEBUG: Check specific tree structure
                if (trees.length > 0) {
                    console.log('🔍 First tree structure:', {
                        id: trees[0].id,
                        name: trees[0].name,
                        breed: trees[0].breed,
                        hasBreed: 'breed' in trees[0],
                        keys: Object.keys(trees[0])
                    });
                }
                
                return true;
            }
        }
        
        console.error('❌ Failed to load trees from backend');
        return false;
    } catch (error) {
        console.error('❌ Error loading trees:', error);
        return false;
    }
}
async function saveBreedsToBackend() {
    if (breedSyncInProgress) return;
    
    try {
        breedSyncInProgress = true;
        console.log('📡 Saving breeds to backend...');
        
        if (typeof farmId === 'undefined') {
            console.warn('⚠️ farmId not available, skipping backend save');
            return false;
        }
        
        const response = await fetch(`/api/farm/${farmId}/breeds`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                breeds: treeBreeds
            })
        });

        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                console.log('✅ Breeds saved to backend successfully');
                return true;
            }
        }
        console.warn('⚠️ Failed to save breeds to backend');
        return false;
    } catch (error) {
        console.warn('⚠️ Error saving breeds to backend:', error);
        return false;
    } finally {
        breedSyncInProgress = false;
    }
}

// ✅ ENHANCED: Save breeds with backend sync
async function saveBreeds() {
    // Save to localStorage as backup
    localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
    console.log('✅ Tree breeds saved to localStorage:', treeBreeds);
    
    // Also try to save to backend
    await saveBreedsToBackend();
}

// ✅ ENHANCED: Add new breed with backend sync


function recalculateDragAreaTreeCounts() {
    dragAreas.forEach(area => {
        const treesInArea = trees.filter(tree => 
            tree.internal_row >= area.minRow && 
            tree.internal_row <= area.maxRow &&
            tree.internal_col >= area.minCol && 
            tree.internal_col <= area.maxCol
        );
        
        area.trees = treesInArea.map(t => t.id);
        area.tree_count = treesInArea.length;
        
        console.log(`📊 Area "${area.name}": ${treesInArea.length} trees`);
    });
}
// ✅ NEW: Remove breed function
async function removeBreed(breedName) {
    try {
        console.log('🗑️ Removing breed:', breedName);
        
        // Get farm ID
        let currentFarmId = null;
        
        if (typeof farmId !== 'undefined' && farmId) {
            currentFarmId = farmId;
        } else if (typeof dome !== 'undefined' && dome && dome.farm_id) {
            currentFarmId = dome.farm_id;
        } else if (typeof domeId !== 'undefined' && domeId) {
            // Try to get farm ID from dome
            try {
                const domeResponse = await fetch(`/api/dome/${domeId}/info`);
                if (domeResponse.ok) {
                    const domeData = await domeResponse.json();
                    if (domeData.success && domeData.dome && domeData.dome.farm_id) {
                        currentFarmId = domeData.dome.farm_id;
                        window.farmId = currentFarmId;
                    }
                }
            } catch (domeError) {
                console.warn('⚠️ Could not get farm ID from dome:', domeError);
            }
        }
        
        if (!currentFarmId) {
            console.error('❌ No farm ID available for breed removal');
            return false;
        }
        
        // First, get all breeds to find the breed ID
        const getBreedsResponse = await fetch(`/api/farm/${currentFarmId}/breeds`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (!getBreedsResponse.ok) {
            console.error('❌ Failed to get breeds list');
            return false;
        }
        
        const breedsResult = await getBreedsResponse.json();
        if (!breedsResult.success || !breedsResult.breeds) {
            console.error('❌ Invalid breeds response');
            return false;
        }
        
        // Find the breed ID
        let breedId = null;
        for (const breed of breedsResult.breeds) {
            if (typeof breed === 'object' && breed.name === breedName) {
                breedId = breed.id;
                break;
            } else if (typeof breed === 'string' && breed === breedName) {
                // If breeds are returned as strings, we need to handle this differently
                console.warn('⚠️ Breeds returned as strings, cannot delete from backend');
                // Remove from local array only
                const index = treeBreeds.findIndex(b => b.toLowerCase() === breedName.toLowerCase());
                if (index !== -1) {
                    treeBreeds.splice(index, 1);
                    localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                    if (currentFarmId) {
                        localStorage.setItem(`farm_${currentFarmId}_breeds`, JSON.stringify(treeBreeds));
                    }
                    console.log('✅ Breed removed from local storage only');
                    return true;
                }
                return false;
            }
        }
        
        if (!breedId) {
            console.error('❌ Breed not found in backend');
            // Still try to remove from local array
            const index = treeBreeds.findIndex(b => b.toLowerCase() === breedName.toLowerCase());
            if (index !== -1) {
                treeBreeds.splice(index, 1);
                localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                if (currentFarmId) {
                    localStorage.setItem(`farm_${currentFarmId}_breeds`, JSON.stringify(treeBreeds));
                }
                console.log('✅ Breed removed from local storage (not found in backend)');
                return true;
            }
            return false;
        }
        
        // Delete breed from backend using DELETE request
        const deleteResponse = await fetch(`/api/farm/${currentFarmId}/breeds/${breedId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (deleteResponse.ok) {
            const result = await deleteResponse.json();
            if (result.success) {
                // Remove from local array
                const index = treeBreeds.findIndex(b => b.toLowerCase() === breedName.toLowerCase());
                if (index !== -1) {
                    treeBreeds.splice(index, 1);
                    
                    // Update localStorage
                    localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                    if (currentFarmId) {
                        localStorage.setItem(`farm_${currentFarmId}_breeds`, JSON.stringify(treeBreeds));
                    }
                }
                
                console.log('✅ Breed removed from backend and local storage successfully');
                return true;
            } else {
                console.error('❌ Backend rejected breed deletion:', result.error);
                return false;
            }
        } else {
            const errorResult = await deleteResponse.json().catch(() => ({}));
            console.error('❌ Backend request failed:', deleteResponse.status, errorResult.error || deleteResponse.statusText);
            return false;
        }
        
    } catch (error) {
        console.error('❌ Error removing breed:', error);
        return false;
    }
}
function toggleBreedDropdown() {
    const dropdown = document.getElementById('breedDropdown');
    const input = document.getElementById('breedSearchInput');
    
    if (!dropdown || !input) return;
    
    const isVisible = dropdown.style.display === 'block';
    dropdown.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        // Show all options when opening
        const options = dropdown.querySelectorAll('.breed-option');
        options.forEach(option => {
            option.style.display = '';
        });
        input.focus();
    }
}
function filterBreedOptions() {
    const input = document.getElementById('breedSearchInput');
    const dropdown = document.getElementById('breedDropdown');
    
    if (!input || !dropdown) return;
    
    const searchTerm = input.value.toLowerCase().trim();
    const options = dropdown.querySelectorAll('.breed-option[data-name]');
    let visibleCount = 0;
    
    // Show dropdown when typing
    dropdown.style.display = 'block';
    
    // Filter options
    options.forEach(option => {
        const name = option.getAttribute('data-name') || '';
        const matches = name.includes(searchTerm) || searchTerm === '';
        
        if (matches) {
            option.style.display = '';
            visibleCount++;
        } else {
            option.style.display = 'none';
        }
    });
    
    // Show "no results" message if no matches
    const noResultsMsg = dropdown.querySelector('.no-results-msg');
    if (visibleCount === 0 && searchTerm !== '') {
        if (!noResultsMsg) {
            const noResults = document.createElement('div');
            noResults.className = 'no-results-msg';
            noResults.style.cssText = `
                padding: 12px;
                text-align: center;
                color: #666;
                font-style: italic;
            `;
            noResults.textContent = `No breeds found matching "${searchTerm}"`;
            dropdown.appendChild(noResults);
        }
    } else if (noResultsMsg) {
        noResultsMsg.remove();
    }
}
function selectBreed(value, displayText) {
    const input = document.getElementById('breedSearchInput');
    const hiddenInput = document.getElementById('breedSelect');
    const dropdown = document.getElementById('breedDropdown');
    
    if (input) input.value = displayText;
    if (hiddenInput) hiddenInput.value = value;
    if (dropdown) dropdown.style.display = 'none';
    
    console.log('✅ Breed selected:', value);
    
    // Update breed info display
    updateBreedInfoDisplay();
}
if (typeof treeBreeds === 'undefined') {
    window.treeBreeds = [];
    
    // Try to load from localStorage
    try {
        const stored = localStorage.getItem('treeBreeds');
        if (stored) {
            window.treeBreeds = JSON.parse(stored);
            console.log('✅ Loaded breeds from localStorage:', window.treeBreeds);
        } else {
            // Default breeds
            window.treeBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado'];
            localStorage.setItem('treeBreeds', JSON.stringify(window.treeBreeds));
            console.log('✅ Initialized with default breeds:', window.treeBreeds);
        }
    } catch (error) {
        console.error('❌ Error loading breeds from localStorage:', error);
        window.treeBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado'];
    }
}

function updateBreedInfoDisplay() {
    const infoDisplay = document.getElementById('breedInfoDisplay');
    const selectedBreed = document.getElementById('breedSelect')?.value;
    
    if (!infoDisplay) return;
    
    if (selectedBreed) {
        infoDisplay.innerHTML = `
            <small style="color: #28a745; font-size: 12px; font-weight: bold;">
                ✅ Selected: ${selectedBreed}
            </small>
        `;
    } else {
        infoDisplay.innerHTML = `
            <small style="color: #666; font-size: 12px;">
                Available breeds (${treeBreeds.length}): ${treeBreeds.slice(0, 3).join(', ')}${treeBreeds.length > 3 ? ` and ${treeBreeds.length - 3} more...` : ''}
            </small>
        `;
    }
}
function updateBreedInfoDisplay() {
    const infoDisplay = document.getElementById('breedInfoDisplay');
    const selectedBreed = document.getElementById('breedSelect')?.value;
    
    if (!infoDisplay) return;
    
    if (selectedBreed) {
        infoDisplay.innerHTML = `
            <small style="color: #28a745; font-size: 12px; font-weight: bold;">
                ✅ Selected: ${selectedBreed}
            </small>
        `;
    } else {
        infoDisplay.innerHTML = `
            <small style="color: #666; font-size: 12px;">
                Available breeds (${treeBreeds.length}): ${treeBreeds.slice(0, 3).join(', ')}${treeBreeds.length > 3 ? ` and ${treeBreeds.length - 3} more...` : ''}
            </small>
        `;
    }
}

function updateBreedDropdown() {
    const dropdown = document.getElementById('breedDropdown');
    if (!dropdown) {
        console.warn('⚠️ breedDropdown element not found');
        return;
    }
    
    // Rebuild dropdown with updated breeds
    dropdown.innerHTML = `
        <div class="breed-option" data-value="" style="
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            color: #999;
        " onclick="selectBreed('', 'Select existing breed...')">
            Select existing breed...
        </div>
        ${treeBreeds.map(breed => `
            <div class="breed-option" 
                 data-value="${breed}" 
                 data-name="${breed.toLowerCase()}"
                 style="
                     padding: 12px;
                     cursor: pointer;
                     border-bottom: 1px solid #f0f0f0;
                 " 
                 onclick="selectBreed('${breed}', '${breed}')"
                 onmouseover="this.style.backgroundColor='#f8f9fa'"
                 onmouseout="this.style.backgroundColor='white'">
                ${breed}
            </div>
        `).join('')}
    `;
    
    // Update breed info display
    if (typeof updateBreedInfoDisplay === 'function') {
        updateBreedInfoDisplay();
    }
    
    console.log('✅ Breed dropdown updated with', treeBreeds.length, 'breeds');
}
function toggleNewBreedInput() {
    const section = document.getElementById('newBreedSection');
    if (!section) {
        console.error('❌ newBreedSection element not found');
        return;
    }
    
    const isVisible = section.style.display !== 'none';
    section.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        // Focus on input when showing
        setTimeout(() => {
            const input = document.getElementById('newBreedInput');
            if (input) {
                input.focus();
                input.select();
            }
        }, 100);
    } else {
        // Clear input when hiding
        const input = document.getElementById('newBreedInput');
        if (input) {
            input.value = '';
        }
    }
    
    console.log('✅ New breed section toggled:', !isVisible ? 'shown' : 'hidden');
}
async function addNewBreed(breedName) {
    try {
        console.log('🧬 Adding new breed:', breedName);
        
        const trimmedBreed = breedName.trim();
        if (!trimmedBreed) {
            console.warn('⚠️ Empty breed name provided');
            return false;
        }
        
        // Validate breed name
        if (trimmedBreed.length < 2) {
            console.warn('⚠️ Breed name too short');
            return false;
        }
        
        if (trimmedBreed.length > 50) {
            console.warn('⚠️ Breed name too long');
            return false;
        }
        
        // Check if breed already exists (case-insensitive)
        if (treeBreeds.find(b => b.toLowerCase() === trimmedBreed.toLowerCase())) {
            console.warn('⚠️ Breed already exists:', trimmedBreed);
            return false;
        }
        
        // Add to local array
        treeBreeds.push(trimmedBreed);
        treeBreeds.sort(); // Keep alphabetical order
        
        // Save to localStorage
        localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
        
        // Try to save to backend if farmId is available
        try {
            if (typeof farmId !== 'undefined' && farmId) {
                const response = await fetch(`/api/farm/${farmId}/breeds`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        breeds: treeBreeds
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('✅ Breed saved to backend successfully');
                    }
                } else {
                    console.warn('⚠️ Failed to save breed to backend, but saved locally');
                }
            }
        } catch (backendError) {
            console.warn('⚠️ Backend save failed, but breed saved locally:', backendError);
        }
        
        console.log('✅ Breed added successfully:', trimmedBreed);
        return true;
        
    } catch (error) {
        console.error('❌ Error adding breed:', error);
        return false;
    }
}
async function addNewBreed(breedName) {
    try {
        console.log('🧬 Adding new breed:', breedName);
        
        const trimmedBreed = breedName.trim();
        if (!trimmedBreed) {
            console.warn('⚠️ Empty breed name provided');
            return false;
        }
        
        // Validate breed name
        if (trimmedBreed.length < 2) {
            console.warn('⚠️ Breed name too short');
            return false;
        }
        
        if (trimmedBreed.length > 50) {
            console.warn('⚠️ Breed name too long');
            return false;
        }
        
        // Check if breed already exists (case-insensitive)
        if (treeBreeds.find(b => b.toLowerCase() === trimmedBreed.toLowerCase())) {
            console.warn('⚠️ Breed already exists:', trimmedBreed);
            return false;
        }
        
        // ✅ FIXED: Save to backend first
        const backendSuccess = await saveBreedToBackend(trimmedBreed);
        
        if (backendSuccess) {
            // Add to local array only after successful backend save
            treeBreeds.push(trimmedBreed);
            treeBreeds.sort(); // Keep alphabetical order
            
            // Save to localStorage as backup
            localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
            if (typeof farmId !== 'undefined' && farmId) {
                localStorage.setItem(`farm_${farmId}_breeds`, JSON.stringify(treeBreeds));
            }
            
            console.log('✅ Breed added successfully to backend and local storage:', trimmedBreed);
            return true;
        } else {
            console.error('❌ Failed to save breed to backend');
            return false;
        }
        
    } catch (error) {
        console.error('❌ Error adding breed:', error);
        return false;
    }
}



async function addBreedFromInput() {
    console.log('🔄 addBreedFromInput called');
    
    try {
        const input = document.getElementById('newBreedInput');
        if (!input) {
            throw new Error('newBreedInput element not found');
        }
        
        const breedName = input.value.trim();
        
        // Validation
        if (!breedName) {
            showErrorMessage('Please enter a breed name');
            input.focus();
            return;
        }
        
        if (breedName.length < 2) {
            showErrorMessage('Breed name must be at least 2 characters');
            input.focus();
            return;
        }
        
        if (breedName.length > 50) {
            showErrorMessage('Breed name is too long (max 50 characters)');
            input.focus();
            return;
        }
        
        // Check if breed already exists
        if (treeBreeds.some(breed => breed.toLowerCase() === breedName.toLowerCase())) {
            showErrorMessage('Breed already exists');
            input.focus();
            input.select();
            return;
        }
        
        // Show loading state
        const addButton = document.getElementById('addBreedBtn');
        if (addButton) {
            addButton.disabled = true;
            addButton.textContent = 'Adding...';
        }
        
        // ✅ FIXED: Save breed to backend first, then update local arrays
        const success = await saveBreedToBackend(breedName);
        
        if (success) {
            // ✅ FIXED: Add to local array only after successful backend save
            if (!treeBreeds.includes(breedName)) {
                treeBreeds.push(breedName);
                treeBreeds.sort(); // Keep alphabetical order
            }
            
            // ✅ FIXED: Save to localStorage as backup
            localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
            if (typeof farmId !== 'undefined' && farmId) {
                localStorage.setItem(`farm_${farmId}_breeds`, JSON.stringify(treeBreeds));
            }
            
            // Update UI
            if (typeof updateBreedDropdown === 'function') {
                updateBreedDropdown();
            }
            
            // Select the newly added breed
            if (typeof selectBreed === 'function') {
                selectBreed(breedName, breedName);
            }
            
            // Hide the new breed section
            const newBreedSection = document.getElementById('newBreedSection');
            if (newBreedSection) {
                newBreedSection.style.display = 'none';
            }
            
            // Clear input
            input.value = '';
            
            console.log(`✅ Breed "${breedName}" added successfully to backend and local storage`);
            showSuccessMessage(`Breed "${breedName}" added successfully!`);
            
        } else {
            showErrorMessage('Failed to add breed to server. Please try again.');
            input.focus();
        }
        
    } catch (error) {
        console.error('❌ Error in addBreedFromInput:', error);
        showErrorMessage('Error adding breed: ' + error.message);
    } finally {
        // Reset button state
        const addButton = document.getElementById('addBreedBtn');
        if (addButton) {
            addButton.disabled = false;
            addButton.textContent = 'Add';
        }
    }
}
async function saveBreedToBackend(breedName) {
    try {
        console.log(`📡 Saving breed "${breedName}" to backend...`);
        
        // Get farm ID (try multiple sources)
        let currentFarmId = null;
        
        if (typeof farmId !== 'undefined' && farmId) {
            currentFarmId = farmId;
        } else if (typeof dome !== 'undefined' && dome && dome.farm_id) {
            currentFarmId = dome.farm_id;
        } else if (typeof domeId !== 'undefined' && domeId) {
            // Try to get farm ID from dome data
            try {
                const domeResponse = await fetch(`/api/dome/${domeId}/info`);
                if (domeResponse.ok) {
                    const domeData = await domeResponse.json();
                    if (domeData.success && domeData.dome && domeData.dome.farm_id) {
                        currentFarmId = domeData.dome.farm_id;
                        window.farmId = currentFarmId; // Cache for future use
                    }
                }
            } catch (domeError) {
                console.warn('⚠️ Could not get farm ID from dome:', domeError);
            }
        }
        
        if (!currentFarmId) {
            console.error('❌ No farm ID available for breed creation');
            return false;
        }
        
        // Save breed to backend
        const response = await fetch(`/api/farm/${currentFarmId}/breeds`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: breedName,
                description: `${breedName} tree breed`
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                console.log(`✅ Breed "${breedName}" saved to backend successfully`);
                return true;
            } else {
                console.error(`❌ Backend rejected breed creation: ${result.error}`);
                return false;
            }
        } else {
            console.error(`❌ Backend request failed: ${response.status} ${response.statusText}`);
            return false;
        }
        
    } catch (error) {
        console.error(`❌ Error saving breed to backend: ${error}`);
        return false;
    }
}
function cancelNewBreed() {
    console.log('🔄 cancelNewBreed called');
    
    try {
        const section = document.getElementById('newBreedSection');
        const input = document.getElementById('newBreedInput');
        
        if (section) {
            section.style.display = 'none';
            console.log('✅ New breed section hidden');
        }
        
        if (input) {
            input.value = '';
            console.log('✅ New breed input cleared');
        }
        
    } catch (error) {
        console.error('❌ Error in cancelNewBreed:', error);
        showErrorMessage('Error canceling breed input: ' + error.message);
    }
}

function showBreedManager() {
    console.log('🔄 showBreedManager called');
    
    try {
        // Remove existing modal if any
        const existingModal = document.querySelector('.breed-manager-modal');
        if (existingModal) {
            existingModal.remove();
        }

        const modal = document.createElement('div');
        modal.className = 'breed-manager-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10002;
            " onclick="this.remove();">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h4 style="margin: 0 0 20px 0; color: #ffc107; display: flex; align-items: center; gap: 10px;">
                        🗂️ Breed Manager
                    </h4>
                    
                    <!-- Add New Breed Section -->
                    <div style="margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <h5 style="margin: 0 0 15px 0; color: #28a745;">➕ Add New Breed</h5>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="managerNewBreedInput" placeholder="Enter breed name..." style="
                                flex: 1;
                                padding: 10px;
                                border: 2px solid #e1e5e9;
                                border-radius: 6px;
                                font-size: 14px;
                            " maxlength="50">
                            <button type="button" id="managerAddBtn" style="
                                padding: 10px 16px;
                                background: #28a745;
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 14px;
                                white-space: nowrap;
                            ">Add Breed</button>
                        </div>
                    </div>
                    
                    <!-- Existing Breeds List -->
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h5 style="margin: 0; color: #333;">📋 Existing Breeds (${treeBreeds.length})</h5>
                            <button type="button" id="reloadBreedsBtn" style="
                                padding: 8px 12px;
                                background: #17a2b8;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 12px;
                            " title="Reload from server">🔄 Reload</button>
                        </div>
                        
                        <div id="breedManagerList" style="
                            max-height: 300px;
                            overflow-y: auto;
                            border: 1px solid #e1e5e9;
                            border-radius: 6px;
                            background: white;
                        ">
                            ${generateBreedListHTML()}
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 15px; border-top: 1px solid #eee;">
                        <button type="button" onclick="this.closest('.breed-manager-modal').remove();" style="
                            padding: 10px 20px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                        ">Close</button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        
        // ✅ CRITICAL: Add event listeners after modal is in DOM
        setTimeout(() => {
            const managerAddBtn = document.getElementById('managerAddBtn');
            const reloadBreedsBtn = document.getElementById('reloadBreedsBtn');
            const managerInput = document.getElementById('managerNewBreedInput');
            
            if (managerAddBtn) {
                managerAddBtn.addEventListener('click', addBreedFromManager);
                console.log('✅ Manager add button connected');
            }
            
            if (reloadBreedsBtn) {
                reloadBreedsBtn.addEventListener('click', loadBreedsFromBackendAndRefresh);
                console.log('✅ Reload button connected');
            }
            
            if (managerInput) {
                managerInput.focus();
                managerInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addBreedFromManager();
                    }
                });
                console.log('✅ Manager input connected');
            }
        }, 100);
        
        console.log('✅ Breed manager modal created successfully');
        
    } catch (error) {
        console.error('❌ Error in showBreedManager:', error);
        showErrorMessage('Error opening breed manager: ' + error.message);
    }
}
async function loadTreeBreeds() {
    try {
        // ✅ FIXED: Use proper variable and endpoint
        const farmId = window.farmId || (typeof dome !== 'undefined' && dome ? dome.farm_id : null);
        
        if (farmId) {
            const response = await fetch(`/api/farm/${farmId}/breeds`);
            if (response.ok) {
                const result = await response.json();
                if (result.success && result.breeds) {
                    // Extract breed names from breed objects
                    treeBreeds = result.breeds.map(breed => {
                        if (typeof breed === 'object' && breed.name) {
                            return breed.name;
                        } else if (typeof breed === 'string') {
                            return breed;
                        } else {
                            return String(breed);
                        }
                    });
                    
                    // Save to localStorage
                    localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                    localStorage.setItem(`farm_${farmId}_breeds`, JSON.stringify(treeBreeds));
                    
                    if (typeof populateBreedSelect === 'function') {
                        populateBreedSelect();
                    }
                    
                    console.log('✅ Breeds loaded from backend:', treeBreeds);
                    return;
                }
            }
        }
    } catch (error) {
        console.warn('⚠️ Failed to load breeds from backend:', error);
    }
    
    // ✅ FIXED: Fallback with proper error handling
    try {
        // Try to get farmId safely
        let farmId = null;
        
        if (typeof window.farmId !== 'undefined') {
            farmId = window.farmId;
        } else if (typeof dome !== 'undefined' && dome && dome.farm_id) {
            farmId = dome.farm_id;
        } else if (typeof domeId !== 'undefined') {
            // If we have domeId but no farmId, we can still use localStorage
            farmId = 'default';
        }
        
        if (farmId) {
            // Try localStorage first
            const localBreeds = localStorage.getItem(`farm_${farmId}_breeds`);
            if (localBreeds) {
                try {
                    const parsedBreeds = JSON.parse(localBreeds);
                    if (Array.isArray(parsedBreeds) && parsedBreeds.length > 0) {
                        treeBreeds = parsedBreeds;
                        console.log('✅ Breeds loaded from localStorage:', treeBreeds);
                        if (typeof populateBreedSelect === 'function') {
                            populateBreedSelect();
                        }
                        return;
                    }
                } catch (parseError) {
                    console.warn('⚠️ Error parsing stored breeds:', parseError);
                }
            }
            
            // Try global localStorage
            const globalBreeds = localStorage.getItem('treeBreeds');
            if (globalBreeds) {
                try {
                    const parsedBreeds = JSON.parse(globalBreeds);
                    if (Array.isArray(parsedBreeds) && parsedBreeds.length > 0) {
                        treeBreeds = parsedBreeds;
                        console.log('✅ Breeds loaded from global localStorage:', treeBreeds);
                        if (typeof populateBreedSelect === 'function') {
                            populateBreedSelect();
                        }
                        return;
                    }
                } catch (parseError) {
                    console.warn('⚠️ Error parsing global stored breeds:', parseError);
                }
            }
        }
        
        // ✅ FIXED: Default breeds as final fallback
        console.log('ℹ️ Using default breeds');
        treeBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado', 'Cherry', 'Peach'];
        
        // Save defaults to localStorage
        localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
        if (farmId) {
            localStorage.setItem(`farm_${farmId}_breeds`, JSON.stringify(treeBreeds));
        }
        
    } catch (error) {
        console.error('❌ Error in fallback breed loading:', error);
        // Ultimate fallback
        treeBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado'];
        localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
    }
    
    // ✅ FIXED: Always try to populate breed select
    try {
        if (typeof populateBreedSelect === 'function') {
            populateBreedSelect();
        }
        console.log('✅ Breed loading completed with', treeBreeds.length, 'breeds');
    } catch (populateError) {
        console.error('❌ Error populating breed select:', populateError);
    }
}
function populateBreedSelect() {
    const breedSelect = document.getElementById('treeBreed');
    if (!breedSelect) {
        console.error('❌ Breed select element not found');
        return;
    }
    
    console.log(`🧬 Populating breed select with current breed: "${currentTreeBreed}"`);
    
    // Clear existing options except the first one
    breedSelect.innerHTML = '<option value="">Select breed...</option>';
    
    // Add breed options
    treeBreeds.forEach(breed => {
        const option = document.createElement('option');
        option.value = breed;
        option.textContent = breed;
        
        // ✅ CRITICAL: Select current breed if it matches
        if (breed === currentTreeBreed) {
            option.selected = true;
            console.log(`✅ Selected current breed: "${breed}"`);
        }
        
        breedSelect.appendChild(option);
    });
    
    // Add "Other" option
    const otherOption = document.createElement('option');
    otherOption.value = 'OTHER';
    otherOption.textContent = '+ Add New Breed';
    breedSelect.appendChild(otherOption);
    
    console.log(`✅ Populated breed select with ${treeBreeds.length} breeds`);
    
    // ✅ FORCE: Set the value again to ensure it's selected
    if (currentTreeBreed) {
        breedSelect.value = currentTreeBreed;
        console.log(`🔧 Force-selected breed: "${currentTreeBreed}"`);
    }
}



// ✅ DEBUG: Function to check breed status
window.debugBreedStatus = function() {
    console.log('=== BREED DEBUG STATUS ===');
    console.log('Current tree breed:', currentTreeBreed);
    console.log('Available breeds:', treeBreeds);
    
    const breedSelect = document.getElementById('treeBreed');
    if (breedSelect) {
        console.log('Breed select element found:', true);
        console.log('Selected value:', breedSelect.value);
        console.log('Options count:', breedSelect.options.length);
        
        // List all options
        for (let i = 0; i < breedSelect.options.length; i++) {
            const option = breedSelect.options[i];
            console.log(`  Option ${i}: "${option.value}" (${option.selected ? 'SELECTED' : 'not selected'})`);
        }
    } else {
        console.log('❌ Breed select element NOT found');
    }
    
    console.log('========================');
};
// ✅ FIXED: Added proper separation between functions
function handleBreedSelection() {
    const breedSelect = document.getElementById('treeBreed');
    if (!breedSelect) return;
    
    breedSelect.addEventListener('change', async function() {
        if (this.value === 'OTHER') {
            // Use the new breed management system
            try {
                const newBreed = prompt('Enter new breed name:');
                if (newBreed && newBreed.trim()) {
                    const breedName = newBreed.trim();
                    
                    // Use the new addNewBreed function
                    const success = await addNewBreed(breedName);
                    
                    if (success) {
                        // Repopulate select and select the new breed
                        if (typeof populateBreedSelect === 'function') {
                            populateBreedSelect();
                        }
                        this.value = breedName;
                        
                        console.log(`✅ Added new breed: ${breedName}`);
                        showSuccessMessage(`Breed "${breedName}" added successfully!`);
                    } else {
                        // Reset to previous value
                        const currentBreed = typeof currentTreeBreed !== 'undefined' ? currentTreeBreed : '';
                        this.value = currentBreed;
                        showErrorMessage('Failed to add breed or breed already exists');
                    }
                } else {
                    // Reset to previous value
                    const currentBreed = typeof currentTreeBreed !== 'undefined' ? currentTreeBreed : '';
                    this.value = currentBreed;
                }
            } catch (error) {
                console.error('❌ Error in breed selection:', error);
                showErrorMessage('Error adding breed: ' + error.message);
                
                // Reset to previous value
                const currentBreed = typeof currentTreeBreed !== 'undefined' ? currentTreeBreed : '';
                this.value = currentBreed;
            }
        }
    });
}
// ✅ ENHANCED: Create tree creation modal with remove functionality
function createTreeCreationModal(row, col) {
    return new Promise((resolve) => {
        // Store resolve function globally
        window.currentTreeCreationResolve = resolve;
        
        // Remove existing modal if any
        const existingModal = document.querySelector('.tree-creation-modal');
        if (existingModal) {
            existingModal.remove();
        }

        // Get available mother plants
        const availableMotherPlants = trees.filter(tree => 
            tree.plant_type === 'mother' || !tree.plant_type
        );

        const modal = document.createElement('div');
        modal.className = 'tree-creation-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            " onclick="closeTreeCreationModal();">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 90vh;
                    overflow-y: auto;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h4 style="margin: 0 0 20px 0; color: #28a745; display: flex; align-items: center; gap: 10px;">
                        🌱 Add New Tree at (${row}, ${col})
                    </h4>
                    
                    <!-- Tree Name -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                            Tree Name:
                        </label>
                        <input type="text" id="treeNameInput" placeholder="Enter tree name" style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #e1e5e9;
                            border-radius: 8px;
                            font-size: 16px;
                            box-sizing: border-box;
                        " maxlength="100">
                        <small style="color: #666; font-size: 12px;">Maximum 100 characters</small>
                    </div>
                    
                    <!-- Tree Breed -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                            Tree Breed:
                        </label>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <!-- Searchable Breed Select -->
                            <div style="flex: 1; position: relative;">
                                <input type="text" 
                                       id="breedSearchInput" 
                                       placeholder="🔍 Search or select breed..." 
                                       style="
                                           width: 100%;
                                           padding: 12px;
                                           border: 2px solid #e1e5e9;
                                           border-radius: 8px;
                                           font-size: 16px;
                                           box-sizing: border-box;
                                       "
                                       autocomplete="off"
                                       onclick="toggleBreedDropdown()"
                                       oninput="filterBreedOptions()">
                                
                                <!-- Hidden input to store selected breed value -->
                                <input type="hidden" id="breedSelect" value="">
                                
                                <!-- Dropdown for breed options -->
                                <div id="breedDropdown" style="
                                    position: absolute;
                                    top: 100%;
                                    left: 0;
                                    right: 0;
                                    background: white;
                                    border: 2px solid #e1e5e9;
                                    border-top: none;
                                    border-radius: 0 0 8px 8px;
                                    max-height: 200px;
                                    overflow-y: auto;
                                    z-index: 10002;
                                    display: none;
                                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                                ">
                                    <!-- Options will be populated by updateBreedDropdown() -->
                                </div>
                            </div>
                            
                            <!-- Add New Breed Button -->
                            <button type="button" onclick="toggleNewBreedInput()" style="
                                padding: 12px 16px;
                                background: #ffc107;
                                color: #212529;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: bold;
                                white-space: nowrap;
                                transition: background-color 0.2s;
                            " onmouseover="this.style.backgroundColor='#e0a800'" 
                               onmouseout="this.style.backgroundColor='#ffc107'"
                               title="Add a new breed">
                                ➕ New
                            </button>
                            
                            <!-- Breed Manager Button -->
                            <button type="button" onclick="showBreedManager()" style="
                                padding: 12px 16px;
                                background: #17a2b8;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: bold;
                                white-space: nowrap;
                                transition: background-color 0.2s;
                            " onmouseover="this.style.backgroundColor='#138496'" 
                               onmouseout="this.style.backgroundColor='#17a2b8'"
                               title="Manage all breeds">
                                🗂️ Manage
                            </button>
                        </div>
                        
                        <!-- Breed Info Display -->
                        <div id="breedInfoDisplay" style="margin-top: 8px;">
                            <small style="color: #666; font-size: 12px;">
                                Available breeds (${treeBreeds.length}): ${treeBreeds.slice(0, 3).join(', ')}${treeBreeds.length > 3 ? ` and ${treeBreeds.length - 3} more...` : ''}
                            </small>
                        </div>
                        
                        <!-- New Breed Input Section (Hidden by default) -->
                        <div id="newBreedSection" style="
                            display: none;
                            margin-top: 15px;
                            padding: 15px;
                            background: #f8f9fa;
                            border-radius: 8px;
                            border: 2px solid #ffc107;
                        ">
                            <h6 style="margin: 0 0 10px 0; color: #ffc107; font-weight: bold;">
                                ➕ Add New Breed
                            </h6>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" 
                                       id="newBreedInput" 
                                       placeholder="Enter new breed name..." 
                                       style="
                                           flex: 1;
                                           padding: 10px;
                                           border: 2px solid #e1e5e9;
                                           border-radius: 6px;
                                           font-size: 14px;
                                       "
                                       maxlength="50"
                                       onkeydown="if(event.key==='Enter') addBreedFromInput(); if(event.key==='Escape') cancelNewBreed();">
                                <button type="button" 
                                        id="addBreedBtn"
                                        onclick="addBreedFromInput()" 
                                        style="
                                            padding: 10px 16px;
                                            background: #28a745;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            cursor: pointer;
                                            font-size: 14px;
                                            font-weight: bold;
                                            white-space: nowrap;
                                        ">
                                    Add
                                </button>
                                <button type="button" 
                                        onclick="cancelNewBreed()" 
                                        style="
                                            padding: 10px 16px;
                                            background: #6c757d;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            cursor: pointer;
                                            font-size: 14px;
                                            white-space: nowrap;
                                        ">
                                    Cancel
                                </button>
                            </div>
                            <small style="color: #666; font-size: 12px; margin-top: 5px; display: block;">
                                Enter a unique breed name (2-50 characters)
                            </small>
                        </div>
                    </div>
                    
                    <!-- Tree Type -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                            Tree Type:
                        </label>
                        <div style="display: flex; gap: 15px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="radio" name="treeType" value="mother" checked style="
                                    width: 18px;
                                    height: 18px;
                                    accent-color: #28a745;
                                ">
                                <span style="font-size: 16px;">🌳 Mother Plant</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="radio" name="treeType" value="cutting" style="
                                    width: 18px;
                                    height: 18px;
                                    accent-color: #28a745;
                                ">
                                <span style="font-size: 16px;">🌱 Cutting</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Mother Plant Selection (for cuttings) -->
                    <div id="motherPlantSection" style="margin-bottom: 20px; display: none;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                            Select Mother Plant:
                        </label>
                        <select id="motherPlantSelect" style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #e1e5e9;
                            border-radius: 8px;
                            font-size: 16px;
                            box-sizing: border-box;
                        ">
                            <option value="">Choose a mother plant...</option>
                            ${availableMotherPlants.map(tree =>
                            `<option value="${tree.id}" data-breed="${tree.breed || ''}">${tree.name} (${tree.breed || 'Unknown breed'}) - (${tree.internal_row},${tree.internal_col})</option>`
                            ).join('')}
                        </select>
                        ${availableMotherPlants.length === 0 ? 
                            '<small style="color: #dc3545; font-size: 12px;">No mother plants available. Create a mother plant first.</small>' : 
                            '<small style="color: #666; font-size: 12px;">Select the mother plant this cutting comes from</small>'
                        }
                    </div>
                    
                    <!-- Tree Info -->
                    <div style="margin-bottom: 25px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">
                            Additional Info (Optional):
                        </label>
                        <textarea id="treeInfoInput" placeholder="Enter any additional information about this tree..." style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #e1e5e9;
                            border-radius: 8px;
                            font-size: 14px;
                            resize: vertical;
                            min-height: 80px;
                            box-sizing: border-box;
                        " maxlength="500"></textarea>
                        <small style="color: #666; font-size: 12px;">Maximum 500 characters</small>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 15px; border-top: 1px solid #eee;">
                        <button type="button" onclick="closeTreeCreationModal()" style="
                            padding: 12px 24px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 16px;
                            transition: background-color 0.2s;
                        " onmouseover="this.style.backgroundColor='#5a6268'" 
                           onmouseout="this.style.backgroundColor='#6c757d'">
                            Cancel
                        </button>
                        <button type="button" onclick="submitTreeCreation(${row}, ${col})" style="
                            padding: 12px 24px;
                            background: #28a745;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 16px;
                            font-weight: bold;
                            transition: background-color 0.2s;
                        " onmouseover="this.style.backgroundColor='#218838'" 
                           onmouseout="this.style.backgroundColor='#28a745'">
                            🌱 Create Tree
                        </button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        
        // ✅ CRITICAL: Initialize breed dropdown and add event listeners
        setTimeout(() => {
            // Update breed dropdown with current breeds
            updateBreedDropdown();
            
            // Focus on tree name input
            const nameInput = document.getElementById('treeNameInput');
            if (nameInput) {
                nameInput.focus();
            }
            
            // Add tree type change listener
            const treeTypeRadios = document.querySelectorAll('input[name="treeType"]');
            treeTypeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const motherSection = document.getElementById('motherPlantSection');
                    const breedSelect = document.getElementById('treeBreed');
                    
                    if (motherSection) {
                        motherSection.style.display = this.value === 'cutting' ? 'block' : 'none';
                    }
                    
                    // Handle breed selection based on tree type
                    if (breedSelect) {
                        if (this.value === 'cutting') {
                            // Disable breed selection for cutting trees - will inherit from mother
                            breedSelect.disabled = true;
                            breedSelect.style.opacity = '0.6';
                            
                            // Add inheritance note if not already present
                            let inheritanceNote = document.getElementById('breedInheritanceNote');
                            if (!inheritanceNote) {
                                inheritanceNote = document.createElement('div');
                                inheritanceNote.id = 'breedInheritanceNote';
                                inheritanceNote.style.cssText = 'margin-top: 5px; padding: 8px; background: #e8f5e8; border-radius: 4px; font-size: 12px; color: #2e7d32;';
                                inheritanceNote.textContent = '🧬 Breed will be inherited from selected mother plant';
                                breedSelect.parentNode.appendChild(inheritanceNote);
                            }
                            inheritanceNote.style.display = 'block';
                        } else {
                            // Enable breed selection for mother plants
                            breedSelect.disabled = false;
                            breedSelect.style.opacity = '1';
                            
                            // Hide inheritance note
                            const inheritanceNote = document.getElementById('breedInheritanceNote');
                            if (inheritanceNote) {
                                inheritanceNote.style.display = 'none';
                            }
                        }
                    }
                });
            });
            
            // Add mother plant selection change handler for breed inheritance
            const motherPlantSelect = document.getElementById('motherPlantSelect');
            if (motherPlantSelect) {
                motherPlantSelect.addEventListener('change', function() {
                    const selectedMotherId = this.value;
                    const breedSelect = document.getElementById('treeBreed');
                    const treeTypeRadios = document.querySelectorAll('input[name="treeType"]');
                    const isCutting = Array.from(treeTypeRadios).find(radio => radio.checked)?.value === 'cutting';
                    
                    if (isCutting && selectedMotherId && breedSelect) {
                        // Find the selected mother plant and get its breed
                        const motherOption = this.options[this.selectedIndex];
                        if (motherOption && motherOption.dataset.breed) {
                            // Set the breed from mother plant
                            breedSelect.value = motherOption.dataset.breed;
                            console.log(`🧬 Inherited breed "${motherOption.dataset.breed}" from mother plant`);
                        }
                    }
                });
                
                // Add search functionality to mother plant select
                const motherPlantSection = document.getElementById('motherPlantSection');
                if (motherPlantSection && !document.getElementById('motherPlantSearch')) {
                    // Create search input
                    const searchInput = document.createElement('input');
                    searchInput.type = 'text';
                    searchInput.id = 'motherPlantSearch';
                    searchInput.placeholder = '🔍 Search mother plants...';
                    searchInput.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 5px; box-sizing: border-box;';
                    searchInput.autocomplete = 'off';
                    
                    // Insert search input before the select element
                    motherPlantSelect.parentNode.insertBefore(searchInput, motherPlantSelect);
                    
                    // Add search functionality
                    searchInput.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const options = motherPlantSelect.querySelectorAll('option');
                        
                        options.forEach(option => {
                            if (option.value === '') {
                                // Always show the default option
                                option.style.display = 'block';
                                return;
                            }
                            
                            const optionText = option.textContent.toLowerCase();
                            if (optionText.includes(searchTerm)) {
                                option.style.display = 'block';
                            } else {
                                option.style.display = 'none';
                            }
                        });
                        
                        // Auto-select if only one option matches
                        const visibleOptions = Array.from(options).filter(opt => 
                            opt.value !== '' && opt.style.display !== 'none'
                        );
                        
                        if (visibleOptions.length === 1) {
                            motherPlantSelect.value = visibleOptions[0].value;
                            // Trigger the change event to inherit breed
                            motherPlantSelect.dispatchEvent(new Event('change'));
                        }
                    });
                    
                    // Show all options when search is focused
                    searchInput.addEventListener('focus', function() {
                        const options = motherPlantSelect.querySelectorAll('option');
                        options.forEach(option => {
                            option.style.display = 'block';
                        });
                    });
                }
            }
            
            // Add click outside to close dropdown
            document.addEventListener('click', function(e) {
                const dropdown = document.getElementById('breedDropdown');
                const input = document.getElementById('breedSearchInput');
                
                if (dropdown && input && !dropdown.contains(e.target) && !input.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });
            
            console.log('✅ Tree creation modal initialized successfully');
            
        }, 100);
    });
}
function closeTreeCreationModal() {
    console.log('🔄 closeTreeCreationModal called');
    
    const modal = document.querySelector('.tree-creation-modal');
    if (modal) {
        modal.remove();
        console.log('✅ Tree creation modal closed');
    }
    
    // Resolve with null to indicate cancellation
    if (window.currentTreeCreationResolve) {
        window.currentTreeCreationResolve(null);
        window.currentTreeCreationResolve = null;
    }
}
async function submitTreeCreation(row, col) {
    console.log('🔄 submitTreeCreation called for position:', row, col);
    
    try {
        // Get form values
        const nameInput = document.getElementById('treeNameInput');
        const breedSelect = document.getElementById('breedSelect');
        const infoInput = document.getElementById('treeInfoInput');
        const treeTypeRadio = document.querySelector('input[name="treeType"]:checked');
        const motherPlantSelect = document.getElementById('motherPlantSelect');
        const cuttingNotesInput = document.getElementById('cuttingNotesInput');
        
        // Validation
        const treeName = nameInput?.value?.trim();
        if (!treeName) {
            showErrorMessage('Please enter a tree name');
            nameInput?.focus();
            return;
        }
        
        if (treeName.length < 2) {
            showErrorMessage('Tree name must be at least 2 characters');
            nameInput?.focus();
            return;
        }
        
        const selectedBreed = breedSelect?.value?.trim();
        if (!selectedBreed) {
            showErrorMessage('Please select a breed');
            const breedInput = document.getElementById('breedSearchInput');
            breedInput?.focus();
            return;
        }
        
        // ✅ FIXED: Use plant_type instead of tree_type
        const plantType = treeTypeRadio?.value || 'mother';
        let motherPlantId = null;
        let cuttingNotes = '';
        
        if (plantType === 'cutting') {
            motherPlantId = motherPlantSelect?.value;
            if (!motherPlantId) {
                showErrorMessage('Please select a mother plant for the cutting');
                motherPlantSelect?.focus();
                return;
            }
            cuttingNotes = cuttingNotesInput?.value?.trim() || '';
        }
        
        // ✅ FIXED: Use correct field names that match your backend
        const treeData = {
            name: treeName,
            breed: selectedBreed,
            info: infoInput?.value?.trim() || '',
            plant_type: plantType,  // ✅ FIXED: Use plant_type instead of tree_type
            mother_plant_id: motherPlantId,
            cutting_notes: cuttingNotes,
            internal_row: row,
            internal_col: col,
            dome_id: domeId,
            life_days: 0
        };
        
        console.log('🌱 Tree data prepared:', treeData);
        
        // Show loading state
        const submitButton = document.querySelector('button[onclick*="submitTreeCreation"]');
        if (submitButton) {
            submitButton.disabled = true;
            submitButton.textContent = '🔄 Creating...';
        }
        
        // Close modal and resolve with tree data
        const modal = document.querySelector('.tree-creation-modal');
        if (modal) {
            modal.remove();
        }
        
        if (window.currentTreeCreationResolve) {
            window.currentTreeCreationResolve(treeData);
            window.currentTreeCreationResolve = null;
        }
        
        console.log('✅ Tree creation data submitted successfully');
        
    } catch (error) {
        console.error('❌ Error in submitTreeCreation:', error);
        showErrorMessage('Error creating tree: ' + error.message);
        
        // Reset button state
        const submitButton = document.querySelector('button[onclick*="submitTreeCreation"]');
        if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = '🌱 Create Tree';
        }
    }
}
async function initializeBreedSystem() {
    console.log('🚀 Initializing breed system...');
    
    try {
        // Load breeds from localStorage first
        const storedBreeds = localStorage.getItem('treeBreeds');
        if (storedBreeds) {
            try {
                treeBreeds = JSON.parse(storedBreeds);
                console.log('✅ Loaded breeds from localStorage:', treeBreeds);
            } catch (error) {
                console.warn('⚠️ Error parsing stored breeds, using defaults');
                treeBreeds = ['Apple', 'Mango', 'Orange', 'Banana'];
            }
        } else {
            // Default breeds if none stored
            treeBreeds = ['Apple', 'Mango', 'Orange', 'Banana'];
            localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
            console.log('✅ Initialized with default breeds:', treeBreeds);
        }
        
        // Try to load from backend
        const backendLoaded = await loadBreedsFromBackend();
        if (backendLoaded) {
            console.log('✅ Breeds synchronized with backend');
        } else {
            console.log('ℹ️ Using local breeds only');
        }
        
        console.log('✅ Breed system initialized successfully');
        return true;
        
    } catch (error) {
        console.error('❌ Error initializing breed system:', error);
        
        // Fallback to basic breeds
        treeBreeds = ['Apple', 'Mango', 'Orange', 'Banana'];
        localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
        
        return false;
    }
}
        // Add keyboard navigation

    function detectButtonErrors() {
        const errors = [];
        
        // Check if buttons exist
        const breedManagerBtn = document.getElementById('breedManagerBtn');
        const addBreedBtn = document.getElementById('addBreedBtn');
        const cancelBreedBtn = document.getElementById('cancelBreedBtn');
        
        if (!breedManagerBtn) errors.push('❌ breedManagerBtn element not found');
        if (!addBreedBtn) errors.push('❌ addBreedBtn element not found');
        if (!cancelBreedBtn) errors.push('❌ cancelBreedBtn element not found');
        
        // Check if required functions exist
        if (typeof window.showBreedManager !== 'function') {
            errors.push('❌ showBreedManager function not defined');
        }
        if (typeof window.addBreedFromInput !== 'function') {
            errors.push('❌ addBreedFromInput function not defined');
        }
        if (typeof window.cancelNewBreed !== 'function') {
            errors.push('❌ cancelNewBreed function not defined');
        }
        
        // Check if treeBreeds array exists
        if (typeof window.treeBreeds === 'undefined') {
            errors.push('❌ treeBreeds array not defined');
        }
        
        return errors;
    }
    function safeCall(functionName, ...args) {
        try {
            console.log(`🔄 Attempting to call ${functionName}...`);
            
            if (typeof window[functionName] !== 'function') {
                throw new Error(`Function ${functionName} is not defined`);
            }
            
            const result = window[functionName](...args);
            console.log(`✅ Successfully called ${functionName}`);
            return result;
            
        } catch (error) {
            console.error(`❌ Error calling ${functionName}:`, error);
            
            // Show user-friendly error message
            const errorMsg = document.createElement('div');
            errorMsg.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #f8d7da;
                color: #721c24;
                padding: 12px 20px;
                border-radius: 6px;
                border: 1px solid #f5c6cb;
                z-index: 10004;
                font-weight: bold;
                max-width: 300px;
            `;
            errorMsg.innerHTML = `
                <strong>Button Error:</strong><br>
                Function "${functionName}" failed<br>
                <small>${error.message}</small>
            `;
            document.body.appendChild(errorMsg);
            
            setTimeout(() => {
                if (errorMsg.parentNode) {
                    errorMsg.remove();
                }
            }, 5000);
            
            return false;
        }
    }
    


window.toggleMotherPlantDropdown = function() {
    const dropdown = document.getElementById('motherPlantDropdown');
    const isVisible = dropdown.style.display === 'block';
    dropdown.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        // Show all options when opening
        const options = dropdown.querySelectorAll('.dropdown-option');
        options.forEach(option => option.style.display = 'block');
    }
};



window.filterMotherPlantDropdown = function() {
    const searchInput = document.getElementById('motherPlantSearchSelect');
    const dropdown = document.getElementById('motherPlantDropdown');
    const searchTerm = searchInput.value.toLowerCase().trim();
    const options = dropdown.querySelectorAll('.dropdown-option[data-name]');
    
    // Show dropdown when typing
    dropdown.style.display = 'block';
    
    let visibleCount = 0;
    
    // Filter options based on search term
    options.forEach(option => {
        const name = option.getAttribute('data-name') || '';
        const breed = option.getAttribute('data-breed') || '';
        const matches = name.includes(searchTerm) || breed.includes(searchTerm) || searchTerm === '';
        
        if (matches) {
            option.style.display = 'block';
            visibleCount++;
        } else {
            option.style.display = 'none';
        }
    });
    
    // Update results info
    const resultsDiv = document.getElementById('motherPlantResults');
    if (resultsDiv) {
        if (searchTerm !== '' && visibleCount === 0) {
            resultsDiv.innerHTML = `
                <div style="padding: 10px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 6px; margin-top: 8px;">
                    <small style="color: #721c24;">
                        🔍 No mother plants found matching "${searchTerm}"
                    </small>
                </div>
            `;
        } else if (searchTerm !== '') {
            resultsDiv.innerHTML = `
                <small style="color: #666; font-size: 12px;">
                    Found <span style="font-weight: bold; color: #28a745;">${visibleCount}</span> mother plants matching "${searchTerm}"
                </small>
            `;
        } else {
            const totalCount = options.length;
            resultsDiv.innerHTML = `
                <small style="color: #666; font-size: 12px;">
                    Available mother plants: <span id="motherPlantCount">${totalCount}</span>
                </small>
            `;
        }
    }
};
window.selectMotherPlant = function(value, displayText) {
    const searchInput = document.getElementById('motherPlantSearchSelect');
    const hiddenInput = document.getElementById('motherPlantSelect');
    const dropdown = document.getElementById('motherPlantDropdown');
    
    // Set values
    hiddenInput.value = value;
    searchInput.value = displayText;
    
    // Hide dropdown
    dropdown.style.display = 'none';
    
    // Update mother plant info
    if (typeof updateMotherPlantInfo === 'function') {
        updateMotherPlantInfo();
    }
    
    // Show status
    if (value && typeof showStatus === 'function') {
        const plantName = displayText.split(' (')[0]; // Extract just the name
        showStatus(`Selected mother plant: ${plantName}`, 'success');
    }
};

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('motherPlantSearchSelect');
    const dropdown = document.getElementById('motherPlantDropdown');
    
    if (searchInput && dropdown && 
        !searchInput.contains(event.target) && 
        !dropdown.contains(event.target)) {
        dropdown.style.display = 'none';
    }
});
window.handleTreeTypeChange = function() {
    const motherPlantRadio = document.getElementById('motherPlantRadio');
    const cuttingRadio = document.getElementById('cuttingRadio');
    const motherPlantSelection = document.getElementById('motherPlantSelection');
    const cuttingInfo = document.getElementById('cuttingInfo');
    
    // Get available mother plants from current scope
    const availableMotherPlants = trees.filter(tree => 
        tree.plant_type === 'mother' || !tree.plant_type
    );
    
    if (cuttingRadio.checked) {
        motherPlantSelection.style.display = 'block';
        cuttingInfo.style.display = 'block';
        
        // Reset search when switching to cutting mode
        clearMotherPlantSearch();
        
        // Disable cutting option if no mother plants available
        if (availableMotherPlants.length === 0) {
            cuttingRadio.disabled = true;
            motherPlantRadio.checked = true;
            motherPlantSelection.style.display = 'none';
            cuttingInfo.style.display = 'none';
            showStatus('No mother plants available. Create a mother plant first.', 'warning');
        }
    } else {
        motherPlantSelection.style.display = 'none';
        cuttingInfo.style.display = 'none';
    }
    
    updateMotherPlantInfo();
};
window.clearMotherPlantSearch = function() {
    const searchInput = document.getElementById('motherPlantSearchSelect');
    const hiddenInput = document.getElementById('motherPlantSelect');
    const dropdown = document.getElementById('motherPlantDropdown');
    
    if (searchInput) {
        searchInput.value = '';
    }
    if (hiddenInput) {
        hiddenInput.value = '';
    }
    if (dropdown) {
        dropdown.style.display = 'none';
        // Show all options
        const options = dropdown.querySelectorAll('.dropdown-option');
        options.forEach(option => option.style.display = 'block');
    }
    
    // Update mother plant info
    if (typeof updateMotherPlantInfo === 'function') {
        updateMotherPlantInfo();
    }
};

        // ✅ NEW: Update mother plant information
// ✅ ENHANCED: Update mother plant information with improved layout and validation
window.debugMotherPlants = function() {
    console.log('=== MOTHER PLANTS DEBUG ===');
    console.log('Total trees:', trees ? trees.length : 'undefined');
    
    if (trees && trees.length > 0) {
        const availableMotherPlants = trees.filter(tree => 
            tree.tree_type === 'mother_plant' || !tree.tree_type
        );
        
        console.log('Available mother plants:', availableMotherPlants.length);
        console.log('Mother plants list:');
        availableMotherPlants.forEach((tree, index) => {
            console.log(`  ${index + 1}. ${tree.name} (ID: ${tree.id}) - Type: ${tree.plant_type || 'undefined'} - Breed: ${tree.breed || 'No breed'}`);
        });
        
        // Check if any trees have plant_type defined
        const treesWithType = trees.filter(t => t.plant_type);
        const treesWithoutType = trees.filter(t => !t.plant_type);
        
        console.log('Trees with plant_type defined:', treesWithType.length);
        console.log('Trees without plant_type (considered mother plants):', treesWithoutType.length);
        
        if (treesWithoutType.length > 0) {
            console.log('Trees without plant_type:');
            treesWithoutType.forEach(tree => {
                console.log(`  - ${tree.name} (ID: ${tree.id})`);
            });
        }
    } else {
        console.log('No trees found');
    }
    console.log('========================');
};

// Add event listener for mother plant selection
const motherPlantSelect = document.getElementById('motherPlantSelect');
if (motherPlantSelect) {
    motherPlantSelect.addEventListener('change', updateMotherPlantInfo);
}

// ✅ ENHANCED: Debug trees function with complete logging
window.debugTrees = function() {
    console.log('=== FRONTEND TREES DEBUG ===');
    console.log('Total trees in frontend:', trees ? trees.length : 'undefined');
    
    if (trees && trees.length > 0) {
        // Check first few trees structure
        console.log('🔍 First 3 trees structure:');
        trees.slice(0, 3).forEach((tree, index) => {
            console.log(`   Tree ${index + 1}:`, {
                id: tree.id,
                name: tree.name,
                breed: tree.breed,
                plant_type: tree.plant_type,
                mother_plant_id: tree.mother_plant_id,
                hasBreed: 'breed' in tree,
                breedType: typeof tree.breed,
                keys: Object.keys(tree)
            });
        });
        
        // Check all trees for breed data
        const treesWithBreeds = trees.filter(t => t.breed && t.breed.trim().length > 0);
        const treesWithBreedProperty = trees.filter(t => 'breed' in t);
        const motherPlants = trees.filter(t => t.plant_type === 'mother' || !t.plant_type);
        const cuttings = trees.filter(t => t.plant_type === 'cutting');
        
        console.log('📊 Tree statistics:');
        console.log('   Trees with breed property:', treesWithBreedProperty.length);
        console.log('   Trees with actual breed values:', treesWithBreeds.length);
        console.log('   Mother plants:', motherPlants.length);
        console.log('   Cuttings:', cuttings.length);
        
        if (treesWithBreeds.length > 0) {
            console.log('🧬 Trees with breeds:');
            treesWithBreeds.forEach(tree => {
                console.log(`   ${tree.id}: "${tree.name}" - Breed: "${tree.breed}" - Type: ${tree.plant_type || 'mother'}`);
            });
        } else {
            console.log('❌ No trees have breed data in frontend');
        }
        
        if (cuttings.length > 0) {
            console.log('✂️ Cutting relationships:');
            cuttings.forEach(cutting => {
                const mother = trees.find(t => t.id == cutting.mother_plant_id);
                console.log(`   Cutting "${cutting.name}" -> Mother: ${mother ? mother.name : 'Unknown'}`);
            });
        }
    } else {
        console.log('❌ No trees found in frontend array');
    }
    
    console.log('========================');
};




// ✅ NEW: Show detailed mother plant information
window.showMotherPlantDetails = function() {
    // Get available mother plants from the current scope
    const availableMotherPlants = trees.filter(tree => 
        tree.tree_type === 'mother_plant' || !tree.tree_type
    );
    
    const detailsModal = document.createElement('div');
    detailsModal.className = 'mother-plant-details-modal';
    detailsModal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 12px;
                padding: 25px;
                max-width: 800px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            " onclick="event.stopPropagation();">
                <h4 style="margin: 0 0 20px 0; color: #28a745; display: flex; align-items: center; gap: 10px;">
                    🌳 Available Mother Plants (${availableMotherPlants.length})
                </h4>
                
                <div style="margin-bottom: 20px;">
                    <input type="text" id="detailsSearch" placeholder="🔍 Search mother plants..." style="
                        width: 100%;
                        padding: 10px 12px;
                        border: 2px solid #e1e5e9;
                        border-radius: 8px;
                        font-size: 14px;
                        box-sizing: border-box;
                    " oninput="filterDetailsTable()">
                </div>
                
                <div id="motherPlantDetailsTable" style="
                    max-height: 400px;
                    overflow-y: auto;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                ">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: #f8f9fa; position: sticky; top: 0;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Name</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Breed</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Position</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Cuttings</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Created</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #dee2e6;">Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${availableMotherPlants.map(tree => {
                                const cuttingCount = tree.cuttings ? tree.cuttings.length : 0;
                                const createdDate = tree.created_at ? new Date(tree.created_at).toLocaleDateString() : 'Unknown';
                                return `
                                    <tr data-name="${tree.name.toLowerCase()}" data-breed="${(tree.breed || '').toLowerCase()}" style="border-bottom: 1px solid #dee2e6;">
                                        <td style="padding: 12px; font-weight: 500;">${tree.name}</td>
                                        <td style="padding: 12px;">${tree.breed || '<em>No breed</em>'}</td>
                                        <td style="padding: 12px;">(${tree.internal_row}, ${tree.internal_col})</td>
                                        <td style="padding: 12px; text-align: center;">
                                            <span style="
                                                background: ${cuttingCount > 0 ? '#d4edda' : '#f8f9fa'};
                                                color: ${cuttingCount > 0 ? '#155724' : '#6c757d'};
                                                padding: 4px 8px;
                                                border-radius: 12px;
                                                font-size: 12px;
                                                font-weight: bold;
                                            ">${cuttingCount}</span>
                                        </td>
                                        <td style="padding: 12px; font-size: 12px; color: #666;">${createdDate}</td>
                                        <td style="padding: 12px; text-align: center;">
                                            <button onclick="selectMotherPlantFromDetails('${tree.id}', '${tree.name.replace(/'/g, "\\'")}');" style="
                                                padding: 6px 12px;
                                                background: #28a745;
                                                color: white;
                                                border: none;
                                                border-radius: 4px;
                                                cursor: pointer;
                                                font-size: 12px;
                                            ">Select</button>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
                
                <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button onclick="this.closest('.mother-plant-details-modal').remove();" style="
                        padding: 12px 24px;
                        background: #6c757d;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: bold;
                    ">Close</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(detailsModal);
};

// ✅ NEW: Filter details table
window.filterDetailsTable = function() {
    const searchInput = document.getElementById('detailsSearch');
    const table = document.getElementById('motherPlantDetailsTable');
    
    if (!searchInput || !table) return;
    
    const searchTerm = searchInput.value.toLowerCase().trim();
    const rows = table.querySelectorAll('tbody tr[data-name]');
    
    rows.forEach(row => {
        const name = row.getAttribute('data-name') || '';
        const breed = row.getAttribute('data-breed') || '';
        const matches = name.includes(searchTerm) || breed.includes(searchTerm);
        
        row.style.display = matches || searchTerm === '' ? '' : 'none';
    });
};

// ✅ NEW: Select mother plant from details modal
window.selectMotherPlantFromDetails = function(plantId, plantName) {
    const motherPlantSelect = document.getElementById('motherPlantSelect');
    if (motherPlantSelect) {
        motherPlantSelect.value = plantId;
        updateMotherPlantInfo(); // Update the info display
        
        // Close the details modal
        const modal = document.querySelector('.mother-plant-details-modal');
        if (modal) {
            modal.remove();
        }
        
        showStatus(`Selected mother plant: ${plantName}`, 'success');
    }
};
window.updateMotherPlantInfo = function() {
    const motherPlantSelect = document.getElementById('motherPlantSelect');
    const selectedMotherInfo = document.getElementById('selectedMotherInfo');
    
    if (!motherPlantSelect || !selectedMotherInfo) return;
    
    const selectedMotherId = motherPlantSelect.value;
    
    if (selectedMotherId) {
        const motherPlant = trees.find(t => t.id == selectedMotherId);
        if (motherPlant) {
            const cuttingCount = motherPlant.cuttings ? motherPlant.cuttings.length : 0;
            const createdDate = motherPlant.created_at ? new Date(motherPlant.created_at).toLocaleDateString() : 'Unknown';
            
            selectedMotherInfo.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <strong>Mother Plant:</strong> ${motherPlant.name}<br>
                        <strong>Breed:</strong> ${motherPlant.breed || 'No breed'}<br>
                        <strong>Position:</strong> (${motherPlant.internal_row}, ${motherPlant.internal_col})
                    </div>
                    <div>
                        <strong>Existing Cuttings:</strong> ${cuttingCount}<br>
                        <strong>Created:</strong> ${createdDate}<br>
                        <strong>Life Days:</strong> ${motherPlant.life_days || 0}
                    </div>
                </div>
                ${cuttingCount > 0 ? `
                    <div style="margin-top: 10px; padding: 8px; background: #e8f5e8; border-radius: 4px;">
                        <small style="color: #155724; font-weight: 500;">
                            💡 This mother plant already has ${cuttingCount} cutting${cuttingCount > 1 ? 's' : ''}
                        </small>
                    </div>
                ` : ''}
            `;
            
            // Auto-fill breed from mother plant
            const breedSelect = document.getElementById('breedSelect');
            if (breedSelect && motherPlant.breed) {
                breedSelect.value = motherPlant.breed;
            }
        }
    } else {
        selectedMotherInfo.innerHTML = `
            <div style="text-align: center; color: #666; padding: 20px;">
                Select a mother plant above to see cutting details.
            </div>
        `;
    }
};


// ✅ ENHANCED: Breed manager modal with improved functionality

window.generateBreedListHTML = function() {
    if (treeBreeds.length === 0) {
        return `
            <div style="padding: 20px; text-align: center; color: #666;">
                No breeds available. Add some breeds to get started!
            </div>
        `;
    }
    
    return treeBreeds.map((breed, index) => `
        <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: ${index < treeBreeds.length - 1 ? '1px solid #f0f0f0' : 'none'};
        ">
            <div style="flex: 1;">
                <strong style="color: #333;">${breed}</strong>
                <div style="font-size: 12px; color: #666; margin-top: 2px;">
                    Breed #${index + 1}
                </div>
            </div>
            <button onclick="removeBreedFromManager('${breed.replace(/'/g, "\\'")}'); event.stopPropagation();" style="
                padding: 6px 10px;
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            " title="Remove breed">🗑️ Remove</button>
        </div>
    `).join('');
};
window.addBreedFromManager = async function() {
    const input = document.getElementById('managerNewBreedInput');
    if (!input) return;
    
    const breedName = input.value.trim();
    
    if (!breedName) {
        alert('Please enter a breed name');
        input.focus();
        return;
    }
    
    if (breedName.length < 2) {
        alert('Breed name must be at least 2 characters');
        input.focus();
        return;
    }
    
    if (treeBreeds.some(breed => breed.toLowerCase() === breedName.toLowerCase())) {
        alert('Breed already exists');
        input.focus();
        input.select();
        return;
    }
    
    try {
        const success = await addNewBreed(breedName);
        
        if (success) {
            // Clear input
            input.value = '';
            
            // Refresh the breed manager list
            refreshBreedList();
            
            // Update the main breed dropdown if it exists
            updateBreedDropdown();
            
            console.log(`✅ Breed "${breedName}" added from manager`);
        } else {
            alert('Failed to add breed. Please try again.');
        }
    } catch (error) {
        console.error('❌ Error adding breed from manager:', error);
        alert('Error adding breed: ' + error.message);
    }
};

// ✅ ENHANCED: Remove breed from manager with better feedback
window.removeBreedFromManager = async function(breedName) {
    if (!confirm(`Are you sure you want to remove the breed "${breedName}"?\n\nThis will not affect existing trees with this breed.`)) {
        return;
    }
    
    try {
        const success = await removeBreed(breedName);
        
        if (success) {
            // Refresh the breed manager list
            refreshBreedList();
            
            // Update the main breed dropdown if it exists
            updateBreedDropdown();
            
            console.log(`✅ Breed "${breedName}" removed from manager`);
        } else {
            alert('Failed to remove breed. Please try again.');
        }
    } catch (error) {
        console.error('❌ Error removing breed from manager:', error);
        alert('Error removing breed: ' + error.message);
    }
};


// ✅ ENHANCED: Refresh breed list in manager with count update
window.refreshBreedList = function() {
    const listContainer = document.getElementById('breedManagerList');
    if (!listContainer) return;
    
    listContainer.innerHTML = generateBreedListHTML();
    
    // Update the header count
    const header = document.querySelector('.breed-manager-modal h5');
    if (header && header.textContent.includes('Existing Breeds')) {
        header.textContent = `📋 Existing Breeds (${treeBreeds.length})`;
    }
};


// ✅ ENHANCED: Update breed select dropdown with preservation of current selection
window.updateBreedSelect = function() {
    const breedSelect = document.getElementById('breedSelect');
    if (!breedSelect) {
        console.warn('⚠️ breedSelect element not found');
        return;
    }
    
    const currentValue = breedSelect.value;
    
    // ✅ FIXED: Ensure treeBreeds contains only strings
    const breedNames = treeBreeds.map(breed => {
        if (typeof breed === 'object' && breed.name) {
            return breed.name;
        } else if (typeof breed === 'string') {
            return breed;
        } else {
            return String(breed);
        }
    });
    
    // ✅ Rebuild options with proper breed names
    breedSelect.innerHTML = `
        <option value="">Select existing breed...</option>
        ${breedNames.map(breedName => `<option value="${breedName}">${breedName}</option>`).join('')}
    `;
    
    // ✅ Restore selection if it still exists
    if (breedNames.includes(currentValue)) {
        breedSelect.value = currentValue;
        console.log('✅ Restored breed selection:', currentValue);
    }
    
    console.log('✅ Breed select updated with', breedNames.length, 'breeds');
};


// ✅ ENHANCED: Toggle new breed input with better UX


// ✅ ENHANCED: Add breed from input with comprehensive validation



// ✅ ENHANCED: Cancel new breed input

    
function generateBreedListHTML() {
    if (treeBreeds.length === 0) {
        return `
            <div style="padding: 20px; text-align: center; color: #666;">
                No breeds available. Add some breeds to get started!
            </div>
        `;
    }
    
    return treeBreeds.map((breed, index) => `
        <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: ${index < treeBreeds.length - 1 ? '1px solid #f0f0f0' : 'none'};
        ">
            <div style="flex: 1;">
                <strong style="color: #333;">${breed}</strong>
                <div style="font-size: 12px; color: #666; margin-top: 2px;">
                    Breed #${index + 1}
                </div>
            </div>
            <button type="button" onclick="removeBreedFromManager('${breed.replace(/'/g, "\\'")}'); event.stopPropagation();" style="
                padding: 6px 10px;
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            " title="Remove breed">🗑️ Remove</button>
        </div>
    `).join('');
}
async function addBreedFromManager() {
    const input = document.getElementById('managerNewBreedInput');
    if (!input) return;
    
    const breedName = input.value.trim();
    
    if (!breedName) {
        showErrorMessage('Please enter a breed name');
        input.focus();
        return;
    }
    
    if (breedName.length < 2) {
        showErrorMessage('Breed name must be at least 2 characters');
        input.focus();
        return;
    }
    
    if (treeBreeds.some(breed => breed.toLowerCase() === breedName.toLowerCase())) {
        showErrorMessage('Breed already exists');
        input.focus();
        input.select();
        return;
    }
    
    try {
        const success = await addNewBreed(breedName);
        
        if (success) {
            // Clear input
            input.value = '';
            
            // Refresh the breed manager list
            refreshBreedList();
            
            // Update the main breed dropdown if it exists
            updateBreedDropdown();
            
            console.log(`✅ Breed "${breedName}" added from manager`);
            showSuccessMessage(`Breed "${breedName}" added successfully!`);
        } else {
            showErrorMessage('Failed to add breed. Please try again.');
        }
    } catch (error) {
        console.error('❌ Error adding breed from manager:', error);
        showErrorMessage('Error adding breed: ' + error.message);
    }
}
async function removeBreedFromManager(breedName) {
    if (!confirm(`Are you sure you want to remove the breed "${breedName}"?\n\nThis will not affect existing trees with this breed.`)) {
        return;
    }
    
    try {
        const success = await removeBreed(breedName);
        
        if (success) {
            // Refresh the breed manager list
            refreshBreedList();
            
            // Update the main breed dropdown if it exists
            updateBreedDropdown();
            
            console.log(`✅ Breed "${breedName}" removed from manager`);
            showSuccessMessage(`Breed "${breedName}" removed successfully!`);
        } else {
            showErrorMessage('Failed to remove breed. Please try again.');
        }
    } catch (error) {
        console.error('❌ Error removing breed from manager:', error);
        showErrorMessage('Error removing breed: ' + error.message);
    }
}
function refreshBreedList() {
    const listContainer = document.getElementById('breedManagerList');
    if (!listContainer) return;
    
    listContainer.innerHTML = generateBreedListHTML();
    
    // Update the header count
    const header = document.querySelector('.breed-manager-modal h5');
    if (header && header.textContent.includes('Existing Breeds')) {
        header.textContent = `📋 Existing Breeds (${treeBreeds.length})`;
    }
}
async function loadBreedsFromBackendAndRefresh() {
    const listContainer = document.getElementById('breedManagerList');
    if (listContainer) {
        listContainer.innerHTML = '<div style="text-align: center; padding: 20px;">🔄 Loading from server...</div>';
    }
    
    try {
        const success = await loadBreedsFromBackend();
        
        if (success) {
            showSuccessMessage('✅ Breeds reloaded from server successfully!');
            updateBreedDropdown();
        } else {
            showSuccessMessage('⚠️ Failed to reload from server, using local data');
        }
        
    } catch (error) {
        console.error('❌ Error reloading breeds from backend:', error);
        showSuccessMessage('❌ Error reloading from server: ' + error.message);
    } finally {
        // Always refresh the display
        refreshBreedList();
    }
}
window.updateBreedDropdown = function() {
    const dropdown = document.getElementById('breedDropdown');
    if (!dropdown) {
        console.warn('⚠️ breedDropdown element not found');
        return;
    }
    
    // Keep the first "Select existing breed..." option
    const firstOption = dropdown.querySelector('.breed-option[data-value=""]');
    
    // Rebuild dropdown with updated breeds
    dropdown.innerHTML = `
        <div class="breed-option" data-value="" style="
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            color: #999;
        " onclick="selectBreed('', 'Select existing breed...')">
            Select existing breed...
        </div>
        ${treeBreeds.map(breed => `
            <div class="breed-option" 
                 data-value="${breed}" 
                 data-name="${breed.toLowerCase()}"
                 style="
                     padding: 12px;
                     cursor: pointer;
                     border-bottom: 1px solid #f0f0f0;
                 " 
                 onclick="selectBreed('${breed}', '${breed}')"
                 onmouseover="this.style.backgroundColor='#f8f9fa'"
                 onmouseout="this.style.backgroundColor='white'">
                ${breed}
            </div>
        `).join('')}
    `;
    
    // Update breed info display
    updateBreedInfoDisplay();
    
    console.log('✅ Breed dropdown updated with', treeBreeds.length, 'breeds');
};
window.showSuccessMessage = function(message) {
    const successMsg = document.createElement('div');
    successMsg.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #d4edda;
        color: #155724;
        padding: 12px 20px;
        border-radius: 6px;
        border: 1px solid #c3e6cb;
        z-index: 10004;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `;
    successMsg.textContent = message;
    document.body.appendChild(successMsg);
    
    setTimeout(() => {
        if (successMsg.parentNode) {
            successMsg.remove();
        }
    }, 3000);
};
document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('breedSearchInput');
    const dropdown = document.getElementById('breedDropdown');
    
    if (searchInput && dropdown && 
        !searchInput.contains(event.target) && 
        !dropdown.contains(event.target)) {
        dropdown.style.display = 'none';
    }
});
document.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        // Check if we're in the new breed input
        if (e.target.id === 'newBreedInput') {
            e.preventDefault();
            addBreedFromInput();
        }
        // Check if we're in the breed search input
        else if (e.target.id === 'breedSearchInput') {
            e.preventDefault();
            // Select first visible option
            const dropdown = document.getElementById('breedDropdown');
            if (dropdown) {
                const firstVisible = dropdown.querySelector('.breed-option[style*="display: none"]') === null ? 
                    dropdown.querySelector('.breed-option[data-value]:not([data-value=""])') : null;
                if (firstVisible) {
                    const value = firstVisible.getAttribute('data-value');
                    selectBreed(value, value);
                }
            }
        }
    }
    // ESC key to close dropdown
    else if (e.key === 'Escape') {
        const dropdown = document.getElementById('breedDropdown');
        if (dropdown) {
            dropdown.style.display = 'none';
        }
    }
});

console.log('✅ Searchable breed selection loaded');
// ✅ COMPLETELY FIXED: Submit tree creation with mother plant and cutting support


// Make resolve available globally for cancel button



// ✅ ENHANCED: Initialize breeds with backend sync
document.addEventListener('DOMContentLoaded', async function() {
    console.log('🚀 Initializing breed system...');
    
    // ✅ Load from localStorage first
    try {
        const stored = localStorage.getItem('treeBreeds');
        if (stored) {
            const parsedBreeds = JSON.parse(stored);
            if (Array.isArray(parsedBreeds)) {
                // ✅ FIXED: Ensure we store only breed names
                treeBreeds = parsedBreeds.map(breed => {
                    if (typeof breed === 'object' && breed.name) {
                        return breed.name;
                    } else if (typeof breed === 'string') {
                        return breed;
                    } else {
                        return String(breed);
                    }
                });
                console.log('📦 Loaded breeds from localStorage:', treeBreeds.length);
            }
        }
    } catch (error) {
        console.error('❌ Error loading breeds from localStorage:', error);
        treeBreeds = [];
    }
    
    // ✅ Try to load from backend
    try {
        const backendSuccess = await loadBreedsFromBackend();
        if (backendSuccess) {
            console.log('📡 Successfully loaded breeds from backend');
        } else {
            console.log('⚠️ Backend loading failed, using localStorage/defaults');
        }
    } catch (error) {
        console.error('❌ Error loading breeds from backend:', error);
    }
    
    // ✅ Add default breeds if none exist
    if (treeBreeds.length === 0) {
        const defaultBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado'];
        treeBreeds = defaultBreeds;
        localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
        console.log('✅ Added default breeds:', defaultBreeds);
    }
    
    console.log('✅ Breed system initialized with', treeBreeds.length, 'breeds:', treeBreeds);
});

// ✅ DEBUG: Function to check breed data format
window.debugBreedData = function() {
    console.log('=== BREED DATA DEBUG ===');
    console.log('treeBreeds array:', treeBreeds);
    console.log('treeBreeds length:', treeBreeds.length);
    console.log('treeBreeds types:', treeBreeds.map(b => typeof b));
    
    if (window.fullBreedObjects) {
        console.log('fullBreedObjects:', window.fullBreedObjects);
        console.log('fullBreedObjects length:', window.fullBreedObjects.length);
    } else {
        console.log('fullBreedObjects: not available');
    }
    
    // Check localStorage
    const stored = localStorage.getItem('treeBreeds');
    if (stored) {
        try {
            const parsed = JSON.parse(stored);
            console.log('localStorage breeds:', parsed);
        } catch (e) {
            console.log('localStorage parse error:', e);
        }
    } else {
        console.log('localStorage: no breeds stored');
    }
    
    console.log('========================');
};

console.log('✅ Fixed breed management system loaded!');

// ✅ STEP 10: Add Enter key support for new breed input in modal
document.addEventListener('DOMContentLoaded', function() {
    console.log('📄 DOM loaded, initializing breed system...');
    
    setTimeout(async () => {
        try {
            // Try to load from backend first
            const backendLoaded = await loadBreedsFromBackend();
            
            if (!backendLoaded) {
                // Fallback to localStorage
                const stored = localStorage.getItem('treeBreeds');
                if (stored) {
                    try {
                        const storedBreeds = JSON.parse(stored);
                        if (Array.isArray(storedBreeds) && storedBreeds.length > 0) {
                            treeBreeds.length = 0;
                            treeBreeds.push(...storedBreeds);
                            console.log('✅ Loaded breeds from localStorage:', treeBreeds);
                        }
                    } catch (parseError) {
                        console.warn('⚠️ Error parsing stored breeds:', parseError);
                    }
                }
                
                // If still no breeds, use defaults
                if (treeBreeds.length === 0) {
                    treeBreeds.push('Apple', 'Orange', 'Mango', 'Banana', 'Coconut', 'Avocado');
                    localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
                    console.log('✅ Initialized with default breeds:', treeBreeds);
                }
            }
            
            // Update dropdown if it exists
            if (document.getElementById('breedDropdown')) {
                updateBreedDropdown();
            }
            
            console.log('✅ Breed system initialized with', treeBreeds.length, 'breeds');
            
        } catch (error) {
            console.error('❌ Error initializing breed system:', error);
        }
    }, 1000);
});

    // Global keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            // Check if we're in the new breed input
            if (e.target.id === 'newBreedInput') {
                e.preventDefault();
                addBreedFromInput();
            }
            // Check if we're in the breed search input
            else if (e.target.id === 'breedSearchInput') {
                e.preventDefault();
                // Select first visible option
                const dropdown = document.getElementById('breedDropdown');
                if (dropdown) {
                    const firstVisible = dropdown.querySelector('.breed-option[data-value]:not([data-value=""]):not([style*="display: none"])');
                    if (firstVisible) {
                        const value = firstVisible.getAttribute('data-value');
                        selectBreed(value, value);
                    }
                }
            }
            // Check if we're in the manager new breed input
            else if (e.target.id === 'managerNewBreedInput') {
                e.preventDefault();
                addBreedFromManager();
            }
        }
        // ESC key to close dropdown
        else if (e.key === 'Escape') {
            const dropdown = document.getElementById('breedDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }
    });
;

// ✅ DEBUG FUNCTION
window.debugBreedFunctions = function() {
    console.log('=== BREED FUNCTIONS DEBUG ===');
    console.log('toggleNewBreedInput:', typeof window.toggleNewBreedInput);
    console.log('addBreedFromInput:', typeof window.addBreedFromInput);
    console.log('cancelNewBreed:', typeof window.cancelNewBreed);
    console.log('showBreedManager:', typeof window.showBreedManager);
    console.log('addNewBreed:', typeof addNewBreed);
    console.log('removeBreed:', typeof removeBreed);
    console.log('treeBreeds:', treeBreeds);
    console.log('treeBreeds length:', treeBreeds.length);
    console.log('========================');
};

console.log('✅ All breed management functions loaded and ready!');
console.log('✅ Breed management system loaded and ready!');

        async function addRandomTree() {
            const emptyPositions = getEmptyPositions();
            if (emptyPositions.length === 0) {
                alert('No empty positions available!');
                return;
            }
            
            const randomPosition = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            const treeName = `Tree ${Date.now()}`;
            
            addTreeAtPosition(randomPosition.row, randomPosition.col);
        }
(async function initializeBreeds() {
    console.log('🚀 Initializing breed management system...');
    
    // First, load from localStorage as fallback
    try {
        const localBreeds = JSON.parse(localStorage.getItem('treeBreeds') || '[]');
        if (localBreeds.length > 0) {
            treeBreeds = localBreeds;
            console.log('📦 Loaded breeds from localStorage:', treeBreeds);
        }
    } catch (error) {
        console.error('❌ Error loading breeds from localStorage:', error);
        treeBreeds = [];
    }
    
    // Try to load from backend (if available)
    try {
        if (typeof loadBreedsFromBackend === 'function') {
            const backendLoaded = await loadBreedsFromBackend();
            if (backendLoaded) {
                console.log('✅ Breeds loaded from backend');
            }
        }
    } catch (error) {
        console.warn('⚠️ Backend breed loading failed:', error);
    }
    
    // If no breeds exist anywhere, add defaults
    if (treeBreeds.length === 0) {
        const defaultBreeds = ['Apple', 'Orange', 'Mango', 'Coconut', 'Banana', 'Avocado', 'Cherry', 'Peach'];
        treeBreeds = defaultBreeds;
        
        // Save defaults
        try {
            localStorage.setItem('treeBreeds', JSON.stringify(treeBreeds));
            console.log('✅ Default breeds saved:', defaultBreeds);
        } catch (error) {
            console.error('❌ Failed to save default breeds:', error);
        }
    }
    
    console.log('✅ Breed management system initialized with', treeBreeds.length, 'breeds:', treeBreeds);
})();
async function addTreeAtPosition(row, col) {
    console.log(`🌱 Adding tree at position (${row}, ${col})`);
    
    // Check if position is already occupied
    const existingTree = trees.find(t => t.internal_row === row && t.internal_col === col);
    if (existingTree) {
        showStatus('Position already occupied by a tree', 'error');
        return;
    }
    
    try {
        // Show tree creation modal and wait for user input
        const treeData = await createTreeCreationModal(row, col);
        
        if (!treeData) {
            console.log('Tree creation cancelled');
            return;
        }
        
        console.log('🔍 Creating tree with data:', treeData);
        showStatus('Creating tree...', 'info');
        
        // ✅ FIXED: Use correct field names and API endpoint
        const treePayload = {
            name: treeData.name,
            breed: treeData.breed || '',
            info: treeData.info || '',
            internal_row: row,
            internal_col: col,
            life_days: 0,
            image_url: '',
            plant_type: treeData.plant_type || 'mother',  // ✅ FIXED: Use plant_type instead of tree_type
            mother_plant_id: treeData.mother_plant_id || null,  // ✅ FIXED: Ensure null if not provided
            cutting_notes: treeData.cutting_notes || ''
        };
        
        console.log('📤 Sending tree payload:', treePayload);
        
        // ✅ FIXED: Use correct API endpoint
        const response = await fetch(`/api/dome/${domeId}/trees`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(treePayload)
        });
        
        const result = await response.json();
        console.log('📥 API Response:', result);
        
        if (result.success) {
            // ✅ FIXED: Use the complete tree data from API response
            const newTree = result.tree || {
                id: result.tree_id,
                name: treeData.name,
                breed: treeData.breed || '',
                internal_row: row,
                internal_col: col,
                life_days: 0,
                info: treeData.info || '',
                image_url: '',
                dome_id: domeId,
                plant_type: treeData.plant_type || 'mother',  // ✅ FIXED: Use plant_type
                mother_plant_id: treeData.mother_plant_id || null,
                cutting_notes: treeData.cutting_notes || '',
                created_at: new Date().toISOString()
            };
            
            console.log('🌳 New tree object:', newTree);
            
            // Add tree to local array
            trees.push(newTree);
            
            // ✅ FIXED: Update mother plant's cuttings if this is a cutting
            if (newTree.plant_type === 'cutting' && newTree.mother_plant_id) {
                const motherPlant = trees.find(t => t.id == newTree.mother_plant_id);
                if (motherPlant) {
                    if (!motherPlant.cuttings) {
                        motherPlant.cuttings = [];
                    }
                    motherPlant.cuttings.push({
                        id: newTree.id,
                        name: newTree.name,
                        created_at: newTree.created_at,
                        position: `(${row}, ${col})`
                    });
                    
                    console.log(`✅ Added cutting to mother plant "${motherPlant.name}":`, {
                        cutting_id: newTree.id,
                        cutting_name: newTree.name,
                        total_cuttings: motherPlant.cuttings.length
                    });
                }
            }
            
            // Re-render grid and update stats
            renderGrid();
            updateStats();
            
            // ✅ FIXED: Use correct plant_type for success message
            const typeText = newTree.plant_type === 'cutting' ? 'cutting' : 'mother plant';
            showStatus(`${typeText.charAt(0).toUpperCase() + typeText.slice(1)} "${newTree.name}" created successfully!`, 'success');
            console.log(`✅ ${typeText} created:`, newTree);
            
        } else {
            console.error('❌ Failed to create tree:', result.error);
            showStatus('Failed to create tree: ' + (result.error || 'Unknown error'), 'error');
        }
        
    } catch (error) {
        console.error('❌ Error creating tree:', error);
        showStatus('Error creating tree: ' + error.message, 'error');
    }
}
function getTreeLineage(treeId) {
    const tree = trees.find(t => t.id == treeId);
    if (!tree) return null;
    
    const lineage = {
        tree: tree,
        mother: null,
        cuttings: []
    };
    
    // Find mother plant if this is a cutting
    if (tree.mother_plant_id) {
        lineage.mother = trees.find(t => t.id == tree.mother_plant_id);
    }
    
    // Find all cuttings if this is a mother plant
    if (tree.plant_type === 'mother') {
        lineage.cuttings = trees.filter(t => t.mother_plant_id == treeId);
    }
    
    return lineage;
}

// ✅ NEW: Function to display tree lineage information
function showTreeLineage(treeId) {
    const lineage = getTreeLineage(treeId);
    if (!lineage) {
        showStatus('Tree not found', 'error');
        return;
    }
    
    let lineageInfo = `Tree: ${lineage.tree.name}\n`;
    lineageInfo += `Type: ${lineage.tree.plant_type === 'cutting' ? 'Cutting' : 'Mother Plant'}\n`;
    lineageInfo += `Created: ${new Date(lineage.tree.created_at).toLocaleDateString()}\n\n`;
    
    if (lineage.mother) {
        lineageInfo += `Mother Plant: ${lineage.mother.name}\n`;
        lineageInfo += `Mother Position: (${lineage.mother.internal_row}, ${lineage.mother.internal_col})\n\n`;
    }
    
    if (lineage.cuttings.length > 0) {
        lineageInfo += `Cuttings (${lineage.cuttings.length}):\n`;
        lineage.cuttings.forEach((cutting, index) => {
            lineageInfo += `${index + 1}. ${cutting.name} at (${cutting.internal_row}, ${cutting.internal_col})\n`;
        });
    }
    
    alert(lineageInfo);
}
async function deleteTree(treeId) {
    // ✅ ENHANCED: Get tree info for better confirmation
    const tree = trees.find(t => t.id === treeId);
    const treeName = tree ? tree.name : `Tree ${treeId}`;
    
    // ✅ ENHANCED: Check for relationships before deleting
    let confirmMessage = `Are you sure you want to delete "${treeName}"?`;
    
    if (tree) {
        // Check if this is a mother tree with cuttings
        const cuttingTrees = trees.filter(t => t.mother_plant_id === treeId);
        if (cuttingTrees.length > 0) {
            confirmMessage += `\n\nThis is a mother tree with ${cuttingTrees.length} cutting tree(s). The cutting trees will become independent.`;
        }
        
        // Check if this is a cutting tree
        if (tree.mother_plant_id) {
            const motherTree = trees.find(t => t.id === tree.mother_plant_id);
            if (motherTree) {
                confirmMessage += `\n\nThis is a cutting tree from mother "${motherTree.name}".`;
            }
        }
    }
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        showStatus('Deleting tree...', 'info');
        console.log('🗑️ Deleting tree ID:', treeId);
        
        // ✅ ENHANCED: Try multiple endpoints with better error handling
        let response;
        let data;
        let method = 'unknown';
        
        try {
            // Method 1: DELETE request
            response = await fetch(`/delete_tree/${treeId}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            data = await response.json();
            method = 'DELETE';
            
        } catch (deleteError) {
            console.log('DELETE method failed, trying POST...', deleteError);
            
            try {
                // Method 2: POST request
                response = await fetch('/delete_tree', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tree_id: treeId, dome_id: domeId })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                data = await response.json();
                method = 'POST';
                
            } catch (postError) {
                console.log('POST method also failed, trying cleanup...', postError);
                
                // Method 3: Try cleanup first, then delete
                try {
                    await fetch('/api/cleanup_orphaned_relationships', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    console.log('✅ Cleanup completed, retrying delete...');
                    
                    // Retry DELETE after cleanup
                    response = await fetch(`/delete_tree/${treeId}`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    data = await response.json();
                    method = 'DELETE_AFTER_CLEANUP';
                    
                } catch (cleanupError) {
                    console.error('All delete methods failed:', cleanupError);
                    throw new Error('All delete methods failed: ' + cleanupError.message);
                }
            }
        }
        
        console.log(`Delete response (${method}):`, data);
        
        if (data.success) {
            // ✅ ENHANCED: Update local data properly
            
            // Remove tree from local array
            trees = trees.filter(tree => tree.id !== treeId);
            console.log(`🗑️ Removed tree ${treeId} from local trees array`);
            
            // ✅ ENHANCED: Update cutting trees if this was a mother
            if (tree && tree.plant_type === 'mother') {
                trees.forEach(t => {
                    if (t.mother_plant_id === treeId) {
                        t.mother_plant_id = null;
                        t.plant_type = 'independent';
                        console.log(`🔗 Updated cutting tree "${t.name}" to independent`);
                    }
                });
            }
            
            // ✅ ENHANCED: Remove tree from drag areas and update counts
            if (typeof dragAreas !== 'undefined' && Array.isArray(dragAreas)) {
                dragAreas.forEach(area => {
                    if (area.trees && area.trees.includes(treeId)) {
                        area.trees = area.trees.filter(id => id !== treeId);
                        area.tree_count = Math.max(0, (area.tree_count || 1) - 1);
                        console.log(`🗑️ Removed tree ${treeId} from drag area "${area.name}"`);
                    }
                });
            }
            
            // ✅ ENHANCED: Update all displays
            if (typeof renderGrid === 'function') renderGrid();
            if (typeof updateStats === 'function') updateStats();
            
            // Update drag areas display
            if (dragSelector && typeof dragSelector.updateDragAreasDisplay === 'function') {
                dragSelector.updateDragAreasDisplay();
            }
            
            // Re-render drag areas
            if (dragSelector && typeof dragSelector.renderDragAreas === 'function') {
                dragSelector.renderDragAreas();
            }
            
            // ✅ ENHANCED: Show detailed success message
            let successMessage = `Tree "${treeName}" deleted successfully!`;
            if (data.cutting_trees_updated > 0) {
                successMessage += ` (${data.cutting_trees_updated} cutting trees updated)`;
            }
            if (data.plant_relationships_deleted > 0) {
                successMessage += ` (${data.plant_relationships_deleted} relationships removed)`;
            }
            
            showStatus(successMessage, 'success');
            console.log('✅ Tree deleted successfully');
            
        } else {
            console.error('❌ Delete failed:', data.error);
            
            // ✅ ENHANCED: Better error messages
            let errorMessage = 'Failed to delete tree';
            if (data.error.includes('constraint')) {
                errorMessage += ': Database constraint error. Try running cleanup first.';
                
                // ✅ NEW: Offer cleanup option
                if (confirm(errorMessage + '\n\nWould you like to try cleaning up orphaned relationships first?')) {
                    try {
                        await fetch('/api/cleanup_orphaned_relationships', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        showStatus('Cleanup completed. Please try deleting again.', 'info');
                    } catch (cleanupError) {
                        showStatus('Cleanup failed: ' + cleanupError.message, 'error');
                    }
                }
            } else {
                errorMessage += ': ' + (data.error || 'Unknown error');
            }
            
            showStatus(errorMessage, 'error');
        }
        
    } catch (error) {
        console.error('❌ Network error deleting tree:', error);
        showStatus('Network error while deleting tree: ' + error.message, 'error');
    }
}
async function cleanupOrphanedRelationships() {
    try {
        showStatus('Cleaning up orphaned relationships...', 'info');
        
        const response = await fetch('/api/cleanup_orphaned_relationships', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        
        const data = await response.json();
        
        if (data.success) {
            showStatus(`Cleanup completed: ${data.deleted_count} orphaned relationships removed`, 'success');
        } else {
            showStatus('Cleanup failed: ' + data.error, 'error');
        }
        
    } catch (error) {
        console.error('❌ Error during cleanup:', error);
        showStatus('Cleanup error: ' + error.message, 'error');
    }
}
async function deleteSelectedTrees() {
    if (!dragSelector || dragSelector.selectedTrees.size === 0) {
        showStatus('No trees selected for deletion', 'warning');
        return;
    }
    
    const selectedTreeIds = Array.from(dragSelector.selectedTrees);
    const treeNames = selectedTreeIds.map(id => {
        const tree = trees.find(t => t.id == id);
        return tree ? tree.name : `Tree ${id}`;
    });
    
    if (!confirm(`Are you sure you want to delete ${selectedTreeIds.length} selected trees?\n\n${treeNames.join(', ')}`)) {
        return;
    }
    
    try {
        showStatus(`Deleting ${selectedTreeIds.length} trees...`, 'info');
        
        const response = await fetch('/delete_trees', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tree_ids: selectedTreeIds })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Remove deleted trees from local array
            trees = trees.filter(tree => !selectedTreeIds.includes(tree.id));
            
            // Clear selection
            dragSelector.clearSelection();
            
            // Update displays
            renderGrid();
            updateStats();
            if (dragSelector.updateDragAreasDisplay) dragSelector.updateDragAreasDisplay();
            if (dragSelector.renderDragAreas) dragSelector.renderDragAreas();
            
            showStatus(`${data.deleted_count} trees deleted successfully!`, 'success');
            
            if (data.errors.length > 0) {
                console.warn('Some trees could not be deleted:', data.errors);
            }
        } else {
            showStatus('Failed to delete trees: ' + data.error, 'error');
        }
        
    } catch (error) {
        console.error('❌ Error deleting multiple trees:', error);
        showStatus('Network error while deleting trees', 'error');
    }
}
async function deleteTreeAlternative(treeId) {
    if (!confirm('Are you sure you want to delete this tree?')) {
        return;
    }
    
    try {
        showStatus('Deleting tree...', 'info');
        console.log('🗑️ Deleting tree ID:', treeId);
        
        // ✅ Try different possible endpoints
        let response;
        let data;
        
        // Method 1: Try POST to /delete_tree
        try {
            response = await fetch('/delete_tree', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tree_id: treeId, dome_id: domeId })
            });
            data = await response.json();
        } catch (e) {
            console.log('Method 1 failed, trying method 2...');
            
            // Method 2: Try POST to /api/delete_tree
            response = await fetch('/api/delete_tree', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tree_id: treeId, dome_id: domeId })
            });
            data = await response.json();
        }
        
        if (data.success) {
            // Remove tree from local array
            trees = trees.filter(tree => tree.id !== treeId);
            renderGrid();
            updateStats();
            showStatus('Tree deleted successfully!', 'success');
        } else {
            showStatus('Failed to delete tree: ' + (data.error || 'Unknown error'), 'error');
        }
        
    } catch (error) {
        console.error('❌ Error deleting tree:', error);
        showStatus('Network error while deleting tree', 'error');
    }
}
function getTreesInArea(area, debugMode = false) {
    if (!area || !trees || !Array.isArray(trees)) {
        if (debugMode) console.log('❌ Invalid area or trees data');
        return [];
    }
    
    if (debugMode) {
        console.log(`🔍 Checking area "${area.name}" bounds:`, {
            minRow: area.minRow,
            maxRow: area.maxRow,
            minCol: area.minCol,
            maxCol: area.maxCol,
            totalTrees: trees.length
        });
    }
    
    const treesInArea = trees.filter(tree => {
        if (!tree || tree.internal_row === undefined || tree.internal_col === undefined) {
            if (debugMode) console.log('⚠️ Tree missing position data:', tree);
            return false;
        }
        
        const inBounds = tree.internal_row >= area.minRow && 
                        tree.internal_row <= area.maxRow &&
                        tree.internal_col >= area.minCol && 
                        tree.internal_col <= area.maxCol;
        
        if (debugMode && inBounds) {
            console.log(`✅ Tree "${tree.name}" at (${tree.internal_row}, ${tree.internal_col}) is in area`);
        }
        
        return inBounds;
    });
    
    if (debugMode) {
        console.log(`🎯 Found ${treesInArea.length} trees in area "${area.name}"`);
        treesInArea.forEach(tree => {
            console.log(`  - "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
        });
    }
    
    return treesInArea;
}

        function editTree(treeId) {
            window.location.href = `/tree_info/${treeId}`;
        }

        async function clearAllTrees() {
            if (!confirm('Are you sure you want to delete ALL trees? This cannot be undone!')) return;
            
            try {
                showStatus('Clearing all trees...', 'info');
                
                const response = await fetch(`/api/dome/${domeId}/trees/clear`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    trees = [];
                    renderGrid();
                    updateStats();
                    showStatus('All trees cleared successfully!', 'success');
                } else {
                    showStatus('Failed to clear trees: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error clearing trees:', error);
                showStatus('Error clearing trees', 'error');
            }
        }

        // ✅ FIXED: Grid management functions
        async function updateGridSize() {
            const newRows = parseInt(document.getElementById('gridRows').value);
            const newCols = parseInt(document.getElementById('gridCols').value);
            
            if (newRows < 1 || newRows > 100 || newCols < 1 || newCols > 100) {
                alert('Grid size must be between 1 and 100 for both rows and columns');
                return;
            }
            
            try {
                showStatus('Updating grid size...', 'info');
                
                const response = await fetch(`/api/dome/${domeId}/grid`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        grid_type: `dome_${domeId}`,
                        rows: newRows,
                        cols: newCols
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRows = newRows;
                    currentCols = newCols;
                    renderGrid();
                    updateStats();
                    showStatus('Grid size updated successfully!', 'success');
                } else {
                    showStatus('Failed to update grid size: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Error updating grid size:', error);
                showStatus('Error updating grid size', 'error');
            }
        }
let searchHighlightedTrees = new Set();
let searchTimeout;

// ✅ Initialize search functionality
function initializeTreeSearch() {
    const searchInput = document.getElementById('treeSearchInput');
    const searchResults = document.getElementById('searchResults');
    
    if (!searchInput || !searchResults) {
        console.warn('⚠️ Tree search elements not found');
        return;
    }
    
    // ✅ Real-time search as user types
    searchInput.addEventListener('input', function(e) {
        const query = e.target.value.trim();
        
        // Clear previous timeout
        if (searchTimeout) {
            clearTimeout(searchTimeout);
        }
        
        // Debounce search to avoid too many calls
        searchTimeout = setTimeout(() => {
            performTreeSearch(query);
        }, 200);
    });
    
    // ✅ Hide results when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            hideSearchResults();
        }
    });
    
    // ✅ Handle keyboard navigation
    searchInput.addEventListener('keydown', function(e) {
        const results = searchResults.querySelectorAll('.search-result-item');
        const activeItem = searchResults.querySelector('.search-result-item.active');
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateSearchResults(results, activeItem, 'down');
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateSearchResults(results, activeItem, 'up');
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (activeItem) {
                activeItem.click();
            }
        } else if (e.key === 'Escape') {
            hideSearchResults();
            searchInput.blur();
        }
    });
    
    console.log('✅ Tree search initialized');
}

// ✅ Perform tree search
function performTreeSearch(query) {
    const searchResults = document.getElementById('searchResults');
    const searchStats = document.getElementById('searchStats');
    
    if (!query) {
        hideSearchResults();
        clearTreeHighlights();
        updateSearchStats(0, 0);
        return;
    }
    
    if (query.length < 2) {
        hideSearchResults();
        updateSearchStats(0, 0);
        return;
    }
    
    // ✅ ENHANCED: Filter trees based on search query with relationship support
    const matchingTrees = trees.filter(tree => {
    const name = (tree.name || '').toLowerCase();
    const breed = (tree.breed || '').toLowerCase();
    const info = (tree.info || '').toLowerCase();
    const plantType = (tree.plant_type || '').toLowerCase();
    const searchTerm = query.toLowerCase();
    
    // Basic search criteria
    let matches = name.includes(searchTerm) ||
    breed.includes(searchTerm) ||
    info.includes(searchTerm) ||
    tree.id.toString().includes(searchTerm) ||
    plantType.includes(searchTerm);
    
    // ✅ NEW: Search by plant type keywords
    if (searchTerm === 'mother' || searchTerm === 'mothers') {
    matches = matches || tree.plant_type === 'mother';
    }
    if (searchTerm === 'cutting' || searchTerm === 'cuttings') {
    matches = matches || tree.plant_type === 'cutting';
    }
    
    // ✅ NEW: Search for cutting trees by their mother's name
    if (tree.plant_type === 'cutting' && tree.mother_plant_id) {
    const motherTree = trees.find(t => t.id === tree.mother_plant_id);
    if (motherTree) {
    const motherName = (motherTree.name || '').toLowerCase();
    matches = matches || motherName.includes(searchTerm);
    }
    }
    
    // ✅ NEW: Search for mother trees by their cutting names
    if (tree.plant_type === 'mother') {
    const cuttingTrees = trees.filter(t => t.mother_plant_id === tree.id);
    for (const cutting of cuttingTrees) {
    const cuttingName = (cutting.name || '').toLowerCase();
    if (cuttingName.includes(searchTerm)) {
    matches = true;
    break;
    }
    }
    }
    
    return matches;
    });
    
    // ✅ Sort results by relevance
    matchingTrees.sort((a, b) => {
        const aName = (a.name || '').toLowerCase();
        const bName = (b.name || '').toLowerCase();
        const searchTerm = query.toLowerCase();
        
        // Exact matches first
        if (aName === searchTerm && bName !== searchTerm) return -1;
        if (bName === searchTerm && aName !== searchTerm) return 1;
        
        // Starts with search term
        if (aName.startsWith(searchTerm) && !bName.startsWith(searchTerm)) return -1;
        if (bName.startsWith(searchTerm) && !aName.startsWith(searchTerm)) return 1;
        
        // Alphabetical order
        return aName.localeCompare(bName);
    });
    
    // ✅ Display search results
    displaySearchResults(matchingTrees, query);
    
    // ✅ Highlight matching trees on grid
    highlightSearchResults(matchingTrees);
    
    // ✅ Update search statistics
    updateSearchStats(matchingTrees.length, trees.length);
    
    console.log(`🔍 Search "${query}" found ${matchingTrees.length} trees`);
}

// ✅ Display search results dropdown
function displaySearchResults(matchingTrees, query) {
    const searchResults = document.getElementById('searchResults');
    
    if (matchingTrees.length === 0) {
        searchResults.innerHTML = `
            <div class="search-result-item" style="padding: 12px; color: #666; font-style: italic;">
                No trees found matching "${query}"
            </div>
        `;
        searchResults.style.display = 'block';
        return;
    }
    
    // ✅ Limit results to prevent performance issues
    const displayTrees = matchingTrees.slice(0, 20);
    const hasMore = matchingTrees.length > 20;
    
    let resultsHTML = '';
    
    displayTrees.forEach((tree, index) => {
    const name = tree.name || `Tree ${tree.id}`;
    const breed = tree.breed ? ` (${tree.breed})` : '';
    const position = `(${tree.internal_row}, ${tree.internal_col})`;
    const lifeDays = tree.life_days ? ` • ${tree.life_days} days` : '';
    
    // ✅ ENHANCED: Get relationship information
    let relationshipInfo = '';
    if (tree.plant_type === 'mother') {
    const cuttingTrees = trees.filter(t => t.mother_plant_id === tree.id);
    if (cuttingTrees.length > 0) {
    relationshipInfo = ` • 🌳 Mother (${cuttingTrees.length} cutting${cuttingTrees.length > 1 ? 's' : ''})`;
    } else {
    relationshipInfo = ` • 🌳 Mother`;
    }
    } else if (tree.plant_type === 'cutting' && tree.mother_plant_id) {
    const motherTree = trees.find(t => t.id === tree.mother_plant_id);
    if (motherTree) {
    relationshipInfo = ` • ✂️ Cutting from "${motherTree.name}"`;
    } else {
    relationshipInfo = ` • ✂️ Cutting (mother not found)`;
    }
    } else if (tree.plant_type === 'cutting') {
    relationshipInfo = ` • ✂️ Cutting`;
    }
    
    // ✅ Highlight matching text
    const highlightedName = highlightSearchTerm(name, query);
    const highlightedBreed = breed ? highlightSearchTerm(breed, query) : '';
    
    resultsHTML += `
    <div class="search-result-item"
    data-tree-id="${tree.id}"
    style="
    padding: 10px 12px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: background-color 0.2s;
    "
    onmouseover="this.style.backgroundColor='#f8f9fa'; setActiveSearchResult(this);"
    onmouseout="this.style.backgroundColor='white';"
    onclick="selectSearchResult(${tree.id}); console.log('Clicked tree:', ${tree.id});"
    >
    <div style="font-weight: 500; color: #333;">
    ${highlightedName}${highlightedBreed}
    </div>
    <div style="font-size: 12px; color: #666; margin-top: 2px;">
    📍 Position: ${position}${lifeDays}
    ${tree.image_url ? ' • 🖼️ Has image' : ''}
    ${relationshipInfo}
    </div>
    </div>
    `;
    });
    
    if (hasMore) {
        resultsHTML += `
            <div class="search-result-item" style="padding: 8px 12px; color: #666; font-size: 12px; background: #f8f9fa;">
                ... and ${matchingTrees.length - 20} more trees
            </div>
        `;
    }
    
    searchResults.innerHTML = resultsHTML;
    searchResults.style.display = 'block';
    
    console.log(`✅ Displayed ${displayTrees.length} search results`);
}

console.log('✅ Enhanced tree search and scroll functionality loaded');

// ✅ Highlight search term in text
function highlightSearchTerm(text, searchTerm) {
    if (!searchTerm || !text) return text;
    
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    return text.replace(regex, '<mark style="background: #fff3cd; padding: 1px 2px;">$1</mark>');
}

// ✅ Highlight matching trees on grid
function highlightSearchResults(matchingTrees) {
    // Clear previous highlights
    clearTreeHighlights();
    
    // Add new highlights
    matchingTrees.forEach(tree => {
        const treeElement = document.querySelector(`[data-tree-id="${tree.id}"]`);
        if (treeElement) {
            treeElement.classList.add('search-highlighted');
            searchHighlightedTrees.add(tree.id);
        }
    });
    
    // ✅ Add CSS for highlighting if not already added
    if (!document.getElementById('searchHighlightStyles')) {
        const style = document.createElement('style');
        style.id = 'searchHighlightStyles';
        style.textContent = `
            .search-highlighted {
                box-shadow: 0 0 0 3px #ffc107 !important;
                border-radius: 4px !important;
                animation: searchPulse 2s ease-in-out;
            }
            
            @keyframes searchPulse {
                0%, 100% { box-shadow: 0 0 0 3px #ffc107; }
                50% { box-shadow: 0 0 0 6px rgba(255, 193, 7, 0.5); }
            }
            
            .search-result-item.active {
                background-color: #e3f2fd !important;
            }
        `;
        document.head.appendChild(style);
    }
}

// ✅ Clear tree highlights
function clearTreeHighlights() {
    searchHighlightedTrees.forEach(treeId => {
        const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
        if (treeElement) {
            treeElement.classList.remove('search-highlighted');
        }
    });
    searchHighlightedTrees.clear();
}

// ✅ Handle search result selection
function selectSearchResult(treeId) {
    console.log(`🔍 Selecting tree ID: ${treeId}`);
    
    // ✅ Convert treeId to number for proper comparison
    const numericTreeId = parseInt(treeId);
    
    const tree = trees.find(t => parseInt(t.id) === numericTreeId);
    if (!tree) {
        console.error('❌ Tree not found:', treeId);
        console.log('Available trees:', trees.map(t => ({id: t.id, name: t.name})));
        showStatus('Tree not found', 'error');
        return;
    }
    
    console.log(`✅ Found tree:`, tree);
    
    // ✅ Hide search results
    hideSearchResults();
    
    // ✅ Show loading message
    showStatus('🔄 Moving to tree...', 'info');
    
    // ✅ Small delay to ensure UI updates
    setTimeout(() => {
        scrollToTree(tree);
        showTreeInfo(tree);
    }, 200);
}


// ✅ Scroll to tree position on grid
function scrollToTree(tree) {
    console.log(`🎯 Scrolling to tree: ${tree.name} at (${tree.internal_row}, ${tree.internal_col})`);
    
    // ✅ Method 1: Try container scrolling
    let success = scrollToTreePosition(tree.internal_row, tree.internal_col);
    
    // ✅ Method 2: If container scrolling fails, try page scrolling
    if (!success) {
        console.log('⚠️ Container scrolling failed, trying alternative method...');
        success = scrollToTreePositionAlternative(tree.internal_row, tree.internal_col);
    }
    
    if (!success) {
        console.error('❌ All scrolling methods failed');
        showStatus(`Failed to scroll to tree "${tree.name}"`, 'error');
        return;
    }
    
    // ✅ Find and highlight the tree element
    setTimeout(() => {
        let treeElement = document.querySelector(`[data-tree-id="${tree.id}"]`);
        
        if (!treeElement) {
            const cell = document.querySelector(`[data-row="${tree.internal_row}"][data-col="${tree.internal_col}"]`);
            if (cell) {
                treeElement = cell.querySelector('[data-tree-id], .tree-element, .tree, img') || cell;
            }
        }
        
        if (treeElement && typeof highlightTreeElement === 'function') {
            highlightTreeElement(treeElement, tree);
        }
        
        if (typeof showTreePositionIndicator === 'function') {
            showTreePositionIndicator(tree);
        }
        
        showStatus(`📍 Moved to "${tree.name}" at position (${tree.internal_row}, ${tree.internal_col})`, 'success');
        
    }, 1000);
}

function highlightTreeElement(treeElement, tree) {
    // Clear any existing highlights
    document.querySelectorAll('.tree-selected').forEach(el => {
        el.classList.remove('tree-selected');
        el.style.transform = '';
        el.style.boxShadow = '';
        el.style.zIndex = '';
        el.style.transition = '';
    });
    
    // Highlight the selected tree
    treeElement.classList.add('tree-selected');
    
    // Add visual effects
    treeElement.style.transition = 'all 0.5s ease';
    treeElement.style.transform = 'scale(1.15)';
    treeElement.style.boxShadow = '0 0 25px 8px rgba(255, 0, 0, 0.8)';
    treeElement.style.zIndex = '1000';
    treeElement.style.borderRadius = '8px';
    treeElement.style.position = 'relative';
    
    console.log('✅ Tree highlighted:', tree.name);
    
    // Pulse effect
    let pulseCount = 0;
    const pulseInterval = setInterval(() => {
        if (pulseCount >= 3) {
            clearInterval(pulseInterval);
            // Final state
            treeElement.style.transform = 'scale(1.05)';
            treeElement.style.boxShadow = '0 0 15px 4px rgba(255, 0, 0, 0.6)';
            return;
        }
        
        if (pulseCount % 2 === 0) {
            treeElement.style.boxShadow = '0 0 30px 10px rgba(255, 0, 0, 1)';
            treeElement.style.transform = 'scale(1.2)';
        } else {
            treeElement.style.boxShadow = '0 0 20px 6px rgba(255, 0, 0, 0.7)';
            treeElement.style.transform = 'scale(1.1)';
        }
        pulseCount++;
    }, 300);
}
function showTreePositionIndicator(tree) {
    // Remove existing indicator
    const existingIndicator = document.getElementById('treePositionIndicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    // Create position indicator
    const indicator = document.createElement('div');
    indicator.id = 'treePositionIndicator';
    indicator.innerHTML = `
        <div style="
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 14px;
            font-weight: 500;
            animation: slideInRight 0.3s ease-out;
        ">
            📍 ${tree.name || `Tree ${tree.id}`}<br>
            <small style="opacity: 0.9;">Position: (${tree.internal_row}, ${tree.internal_col})</small>
            ${tree.breed ? `<br><small style="opacity: 0.9;">🧬 ${tree.breed}</small>` : ''}
        </div>
    `;
    
    // Add animation CSS if not already added
    if (!document.getElementById('positionIndicatorStyles')) {
        const style = document.createElement('style');
        style.id = 'positionIndicatorStyles';
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            .tree-selected {
                position: relative !important;
                z-index: 1000 !important;
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(indicator);
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        if (indicator && indicator.parentNode) {
            indicator.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 300);
        }
    }, 3000);
}
function addGridNavigationControls() {
    // Check if controls already exist
    if (document.getElementById('gridNavigationControls')) {
        return;
    }
    
    const navControls = document.createElement('div');
    navControls.id = 'gridNavigationControls';
    navControls.innerHTML = `
        <div style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        " id="gridNavPanel">
            <div style="font-size: 12px; font-weight: 500; margin-bottom: 8px; color: #666;">
                Grid Navigation
            </div>
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <button onclick="scrollToGridPosition(0, 0)" style="padding: 4px 8px; font-size: 11px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                    🏠 Top-Left
                </button>
                <button onclick="scrollToGridCenter()" style="padding: 4px 8px; font-size: 11px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                    🎯 Center
                </button>
            </div>
            <div style="display: flex; gap: 4px;">
                <input type="number" id="navRow" placeholder="Row" min="0" max="${currentRows-1}" style="width: 50px; padding: 2px 4px; font-size: 11px; border: 1px solid #ddd; border-radius: 2px;">
                <input type="number" id="navCol" placeholder="Col" min="0" max="${currentCols-1}" style="width: 50px; padding: 2px 4px; font-size: 11px; border: 1px solid #ddd; border-radius: 2px;">
                <button onclick="scrollToGridPosition()" style="padding: 2px 6px; font-size: 11px; border: 1px solid #007bff; background: #007bff; color: white; border-radius: 2px; cursor: pointer;">
                    Go
                </button>
            </div>
        </div>
        <button onclick="toggleGridNavPanel()" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #007bff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1001;
        " title="Grid Navigation">
            🧭
        </button>
    `;
    
    document.body.appendChild(navControls);
}
function enableGridVerticalScrolling() {
    const gridContainer = document.getElementById('gridContainer');
    if (gridContainer) {
        // ✅ Enable both horizontal and vertical scrolling
        gridContainer.style.overflowX = 'auto';
        gridContainer.style.overflowY = 'auto';  // ✅ This enables vertical scrolling
        gridContainer.style.maxHeight = '80vh';  // ✅ Set max height to enable scrolling
        gridContainer.style.maxWidth = '100vw';
        
        console.log('✅ Grid vertical scrolling enabled');
        console.log('Grid container scroll properties:', {
            overflowX: gridContainer.style.overflowX,
            overflowY: gridContainer.style.overflowY,
            maxHeight: gridContainer.style.maxHeight,
            scrollHeight: gridContainer.scrollHeight,
            clientHeight: gridContainer.clientHeight,
            scrollWidth: gridContainer.scrollWidth,
            clientWidth: gridContainer.clientWidth
        });
    } else {
        console.error('❌ Grid container not found');
    }
}

function toggleGridNavPanel() {
    const panel = document.getElementById('gridNavPanel');
    if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
}
function scrollToGridPosition(row, col) {
    // Get values from inputs if not provided
    if (row === undefined) {
        row = parseInt(document.getElementById('navRow')?.value);
    }
    if (col === undefined) {
        col = parseInt(document.getElementById('navCol')?.value);
    }
    
    console.log(`🎯 Scrolling to grid position (${row}, ${col})`);
    
    if (isNaN(row) || isNaN(col)) {
        showStatus('Please enter valid row and column numbers', 'error');
        return;
    }
    
    if (row < 0 || row >= currentRows || col < 0 || col >= currentCols) {
        showStatus(`Position (${row}, ${col}) is outside grid bounds (0-${currentRows-1}, 0-${currentCols-1})`, 'error');
        return;
    }
    
    // ✅ Use the enhanced scrollToTreePosition function
    const success = scrollToTreePosition(row, col);
    
    if (success) {
        showStatus(`Navigated to position (${row}, ${col})`, 'success');
    } else {
        showStatus(`Failed to navigate to position (${row}, ${col})`, 'error');
    }
}
function scrollToGridCenter() {
    const centerRow = Math.floor(currentRows / 2);
    const centerCol = Math.floor(currentCols / 2);
    console.log(`🎯 Scrolling to grid center: (${centerRow}, ${centerCol})`);
    scrollToGridPosition(centerRow, centerCol);
}
function addMouseWheelScrolling() {
    const container = document.getElementById('gridContainer');
    if (!container) return;
    
    // ✅ Enable mouse wheel scrolling in both directions
    container.addEventListener('wheel', function(e) {
        // Check if Shift key is pressed for horizontal scrolling
        if (e.shiftKey) {
            // Horizontal scrolling with Shift + wheel
            e.preventDefault();
            container.scrollLeft += e.deltaY;
        } else {
            // Vertical scrolling with normal wheel
            e.preventDefault();
            container.scrollTop += e.deltaY;
        }
    }, { passive: false });
    
    console.log('✅ Mouse wheel scrolling enabled (Shift+wheel for horizontal)');
}
function addKeyboardGridNavigation() {
    document.addEventListener('keydown', function(e) {
        // Only if no input is focused and grid container exists
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
            return;
        }
        
        const container = document.getElementById('gridContainer');
        if (!container) return;
        
        const scrollAmount = 100; // pixels to scroll
        
        switch(e.key) {
            case 'ArrowUp':
                e.preventDefault();
                container.scrollTop = Math.max(0, container.scrollTop - scrollAmount);
                break;
            case 'ArrowDown':
                e.preventDefault();
                container.scrollTop = Math.min(container.scrollHeight - container.clientHeight, container.scrollTop + scrollAmount);
                break;
            case 'ArrowLeft':
                e.preventDefault();
                container.scrollLeft = Math.max(0, container.scrollLeft - scrollAmount);
                break;
            case 'ArrowRight':
                e.preventDefault();
                container.scrollLeft = Math.min(container.scrollWidth - container.clientWidth, container.scrollLeft + scrollAmount);
                break;
            case 'Home':
                if (e.ctrlKey) {
                    e.preventDefault();
                    scrollToGridPosition(0, 0);
                }
                break;
            case 'End':
                if (e.ctrlKey) {
                    e.preventDefault();
                    scrollToGridPosition(currentRows - 1, currentCols - 1);
                }
                break;
        }
    });
    
    console.log('✅ Keyboard grid navigation enabled (Arrow keys, Ctrl+Home, Ctrl+End)');
}
function initializeGridScrolling() {
    console.log('🔄 Initializing grid scrolling enhancements...');
    
    // Enable vertical scrolling
    enableGridVerticalScrolling();
    
    // Add mouse wheel support
    addMouseWheelScrolling();
    
    // Add keyboard navigation
    addKeyboardGridNavigation();
    
    console.log('✅ Grid scrolling enhancements initialized');
    console.log('📝 Controls:');
    console.log('   - Mouse wheel: Vertical scrolling');
    console.log('   - Shift + Mouse wheel: Horizontal scrolling');
    console.log('   - Arrow keys: Navigate grid');
    console.log('   - Ctrl+Home: Go to top-left');
    console.log('   - Ctrl+End: Go to bottom-right');
}
// ✅ Highlight selected tree
function highlightSelectedTree(tree) {
    // Clear previous selection highlights
    document.querySelectorAll('.tree-selected').forEach(el => {
        el.classList.remove('tree-selected');
    });
    
    const treeElement = document.querySelector(`[data-tree-id="${tree.id}"]`);
    if (treeElement) {
        treeElement.classList.add('tree-selected');
        
        // Add CSS for selection if not already added
        if (!document.getElementById('treeSelectionStyles')) {
            const style = document.createElement('style');
            style.id = 'treeSelectionStyles';
            style.textContent = `
                .tree-selected {
                    box-shadow: 0 0 0 4px #007bff !important;
                    border-radius: 4px !important;
                    z-index: 10 !important;
                    position: relative !important;
                }
            `;
            document.head.appendChild(style);
        }
    }
}

// ✅ Show tree info (you can customize this)
// ✅ ADD THIS FUNCTION - Show tree info
function showTreeInfo(tree) {
    const info = [
        `🌳 Tree: ${tree.name || `Tree ${tree.id}`}`,
        `🧬 Breed: ${tree.breed || 'None'}`,
        `📍 Position: (${tree.internal_row}, ${tree.internal_col})`,
        `📅 Life Days: ${tree.life_days || 0}`,
        tree.info ? `📝 Info: ${tree.info}` : '',
        tree.image_url ? `🖼️ Has image` : ''
    ].filter(Boolean).join('\n');
    
    console.log('Tree Info:', info);
}
function hideSearchResults() {
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.style.display = 'none';
    }
}
// ✅ Navigate search results with keyboard
function navigateSearchResults(results, activeItem, direction) {
    if (results.length === 0) return;
    
    let newIndex = 0;
    
    if (activeItem) {
        const currentIndex = Array.from(results).indexOf(activeItem);
        if (direction === 'down') {
            newIndex = (currentIndex + 1) % results.length;
        } else {
            newIndex = currentIndex === 0 ? results.length - 1 : currentIndex - 1;
        }
        activeItem.classList.remove('active');
    }
    
    results[newIndex].classList.add('active');
    results[newIndex].scrollIntoView({ block: 'nearest' });
}

// ✅ Set active search result on hover
function setActiveSearchResult(element) {
    document.querySelectorAll('.search-result-item.active').forEach(item => {
        item.classList.remove('active');
    });
    element.classList.add('active');
}


// ✅ Hide search results


// ✅ Clear tree search
function clearTreeSearch() {
    const searchInput = document.getElementById('treeSearchInput');
    if (searchInput) {
        searchInput.value = '';
    }
    
    hideSearchResults();
    clearTreeHighlights();
    updateSearchStats(0, 0);
    
    // Clear selected tree highlight
    document.querySelectorAll('.tree-selected').forEach(el => {
        el.classList.remove('tree-selected');
    });
    
    showStatus('Search cleared', 'info');
}

// ✅ Update search statistics
function updateSearchStats(found, total) {
    const searchStats = document.getElementById('searchStats');
    if (searchStats) {
        if (found > 0) {
            searchStats.textContent = `Found ${found} of ${total} trees`;
            searchStats.style.color = '#28a745';
        } else if (total > 0) {
            searchStats.textContent = `0 of ${total} trees`;
            searchStats.style.color = '#dc3545';
        } else {
            searchStats.textContent = '';
        }
    }
}

// ✅ Initialize search when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for other initialization to complete
    setTimeout(() => {
        initializeTreeSearch();
    }, 1000);
});

// ✅ Re-initialize search after grid updates
function reinitializeSearchAfterGridUpdate() {
    // Clear highlights since tree elements may have been recreated
    searchHighlightedTrees.clear();
    
    // Re-perform search if there's an active query
    const searchInput = document.getElementById('treeSearchInput');
    if (searchInput && searchInput.value.trim()) {
        performTreeSearch(searchInput.value.trim());
    }
}

// ✅ Hook into existing renderGrid function to maintain search highlights
const originalRenderGrid = renderGrid;
renderGrid = function() {
    originalRenderGrid.apply(this, arguments);
    
    // Re-initialize search after grid render
    setTimeout(() => {
        reinitializeSearchAfterGridUpdate();
    }, 100);
};

console.log('✅ Tree search functionality loaded');
        function refreshGrid() {
            renderGrid();
            updateStats();
            refreshDebugInfo();
            showStatus('Grid refreshed!', 'success');
        }

        // ✅ FIXED: Update stats function
        function updateStats() {
            document.getElementById('totalTrees').textContent = trees.length;
            document.getElementById('treeCount').textContent = trees.length;
            document.getElementById('currentGridSize').textContent = `${currentRows}×${currentCols}`;
            document.getElementById('availablePositions').textContent = (currentRows * currentCols) - trees.length;
            
            const occupancyRate = (currentRows * currentCols) > 0 ? 
                (trees.length / (currentRows * currentCols) * 100) : 0;
            document.getElementById('occupancyRate').textContent = occupancyRate.toFixed(1) + '%';
        }

        // ✅ FIXED: Grid display and navigation functions
        function updateGridDisplay() {
            const totalCells = currentRows * currentCols;
            const isLargeGrid = totalCells > 400 || currentCols > 20; // 20x20 or wide grids
            
            // Show navigation for large grids
            const navigationControls = document.getElementById('navigationControls');
            const scrollHint = document.getElementById('scrollHint');
            
            if (isLargeGrid) {
                navigationControls.style.display = 'flex';
                scrollHint.classList.add('show');
            } else {
                navigationControls.style.display = 'none';
                scrollHint.classList.remove('show');
            }
            
            // Center the grid initially for large grids
            if (isLargeGrid) {
                setTimeout(centerGrid, 100);
            }
        }

        function centerGrid() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('treeGrid');
            
            if (container && grid) {
                const containerRect = container.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                
                const scrollLeft = (gridRect.width - containerRect.width) / 2;
                const scrollTop = (gridRect.height - containerRect.height) / 2;
                
                container.scrollTo({
                    left: Math.max(0, scrollLeft),
                    top: Math.max(0, scrollTop),
                    behavior: 'smooth'
                });
            }
        }

        function fitToScreen() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('treeGrid');
            
            if (container && grid) {
                const containerRect = container.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                
                // Calculate scale to fit
                const scaleX = containerRect.width / gridRect.width;
                const scaleY = containerRect.height / gridRect.height;
                const scale = Math.min(scaleX, scaleY, 1); // Don't scale up
                
                if (scale < 1) {
                    const newCellSize = Math.floor(100 * scale);
                    document.documentElement.style.setProperty('--cell-size', `${newCellSize}px`);
                    
                    setTimeout(() => {
                        centerGrid();
                    }, 100);
                }
            }
        }

        function scrollToPosition(position) {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('treeGrid');
            
            if (!container || !grid) return;
            
            const containerRect = container.getBoundingClientRect();
            const gridRect = grid.getBoundingClientRect();
            
            let scrollLeft = 0;
            
            switch (position) {
                case 'start':
                    scrollLeft = 0;
                    break;
                case 'left':
                    scrollLeft = Math.max(0, container.scrollLeft - containerRect.width * 0.8);
                    break;
                case 'right':
                    scrollLeft = Math.min(
                        gridRect.width - containerRect.width,
                        container.scrollLeft + containerRect.width * 0.8
                    );
                    break;
                case 'end':
                    scrollLeft = gridRect.width - containerRect.width;
                    break;
            }
            
            container.scrollTo({
                left: Math.max(0, scrollLeft),
                behavior: 'smooth'
            });
        }
function scrollToTreePosition(row, col) {
    console.log(`🎯 Scrolling to tree position (${row}, ${col})`);
    
    // ✅ STEP 1: Find the target cell
    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (!targetCell) {
        console.error(`❌ Cell not found at position (${row}, ${col})`);
        return false;
    }
    
    console.log('✅ Target cell found:', targetCell);
    
    // ✅ STEP 2: Get the grid container
    const container = document.getElementById('gridContainer');
    
    if (!container) {
        console.error('❌ Grid container not found, using page scroll');
        // Fallback: scroll the entire page
        targetCell.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
        
        // Highlight the cell
        setTimeout(() => {
            targetCell.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
            targetCell.style.border = '3px solid red';
            targetCell.style.transition = 'all 0.3s ease';
            
            setTimeout(() => {
                targetCell.style.backgroundColor = '';
                targetCell.style.border = '';
            }, 3000);
        }, 500);
        
        return true;
    }
    
    // ✅ STEP 3: Ensure container can scroll vertically
    const containerStyle = getComputedStyle(container);
    console.log('Container overflow before fix:', {
        overflowX: containerStyle.overflowX,
        overflowY: containerStyle.overflowY,
        height: containerStyle.height,
        maxHeight: containerStyle.maxHeight
    });
    
    // ✅ CRITICAL: Enable vertical scrolling if not already enabled
    if (containerStyle.overflowY === 'visible' || containerStyle.overflowY === 'hidden') {
        container.style.overflowY = 'auto';
        console.log('✅ Enabled vertical scrolling on container');
    }
    
    // ✅ CRITICAL: Set max height to enable scrolling
    if (!containerStyle.maxHeight || containerStyle.maxHeight === 'none') {
        container.style.maxHeight = '80vh';
        console.log('✅ Set max height to enable scrolling');
    }
    
    // ✅ STEP 4: Calculate scroll positions for BOTH horizontal AND vertical
    const containerRect = container.getBoundingClientRect();
    const cellRect = targetCell.getBoundingClientRect();
    
    // Get current scroll positions
    const currentScrollLeft = container.scrollLeft;
    const currentScrollTop = container.scrollTop;
    
    // Calculate target scroll positions to center the cell
    const targetScrollLeft = currentScrollLeft + (cellRect.left - containerRect.left) - (containerRect.width / 2) + (cellRect.width / 2);
    const targetScrollTop = currentScrollTop + (cellRect.top - containerRect.top) - (containerRect.height / 2) + (cellRect.height / 2);
    
    // ✅ Ensure scroll positions are within bounds
    const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
    const maxScrollTop = Math.max(0, container.scrollHeight - container.clientHeight);
    
    const finalScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));
    const finalScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
    
    console.log('📊 Scroll calculation:', {
        currentScroll: { left: currentScrollLeft, top: currentScrollTop },
        targetScroll: { left: targetScrollLeft, top: targetScrollTop },
        finalScroll: { left: finalScrollLeft, top: finalScrollTop },
        maxScroll: { left: maxScrollLeft, top: maxScrollTop },
        cellPosition: { left: cellRect.left, top: cellRect.top },
        containerPosition: { left: containerRect.left, top: containerRect.top },
        containerSize: { width: containerRect.width, height: containerRect.height },
        canScrollVertically: container.scrollHeight > container.clientHeight,
        canScrollHorizontally: container.scrollWidth > container.clientWidth
    });
    
    // ✅ STEP 5: Scroll to position (BOTH horizontal AND vertical)
    container.scrollTo({
        left: finalScrollLeft,
        top: finalScrollTop,  // ✅ CRITICAL: This enables vertical scrolling
        behavior: 'smooth'
    });
    
    console.log(`✅ Scrolled to position (${row}, ${col}) - Left: ${finalScrollLeft}, Top: ${finalScrollTop}`);
    
    // ✅ STEP 6: Highlight the cell after scrolling
    setTimeout(() => {
        targetCell.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        targetCell.style.border = '3px solid red';
        targetCell.style.transition = 'all 0.3s ease';
        targetCell.style.zIndex = '1000';
        targetCell.style.position = 'relative';
        targetCell.style.transform = 'scale(1.05)';
        
        // Remove highlight after 3 seconds
        setTimeout(() => {
            targetCell.style.backgroundColor = '';
            targetCell.style.border = '';
            targetCell.style.zIndex = '';
            targetCell.style.position = '';
            targetCell.style.transform = '';
        }, 3000);
    }, 800); // Wait for scroll animation to complete
    
    return true;
}
async function executePendingCopy() {
    try {
        const pendingAreaId = sessionStorage.getItem('pendingCopyAreaId');
        const pendingAction = sessionStorage.getItem('pendingCopyAction');
        const pendingTimestamp = sessionStorage.getItem('pendingCopyTimestamp');
        
        if (!pendingAreaId || !pendingAction || !pendingTimestamp) {
            return; // No pending copy action
        }
        
        // Check if the pending action is recent (within last 30 seconds)
        const actionAge = Date.now() - parseInt(pendingTimestamp);
        if (actionAge > 30000) {
            console.log('⚠️ Pending copy action is too old, ignoring');
            sessionStorage.removeItem('pendingCopyAreaId');
            sessionStorage.removeItem('pendingCopyAction');
            sessionStorage.removeItem('pendingCopyTimestamp');
            return;
        }
        
        console.log(`🔄 Executing pending copy action: ${pendingAction} for area ${pendingAreaId}`);
        
        // Clear the pending action
        sessionStorage.removeItem('pendingCopyAreaId');
        sessionStorage.removeItem('pendingCopyAction');
        sessionStorage.removeItem('pendingCopyTimestamp');
        
        // Wait a bit for page to fully load
        setTimeout(() => {
            if (pendingAction === 'copyDragArea') {
                performActualCopy(parseInt(pendingAreaId));
            }
        }, 2000);
        
    } catch (error) {
        console.error('❌ Error executing pending copy:', error);
    }
}

// ✅ NEW: Function to perform the actual copy with fresh data
async function performActualCopy(areaId) {
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        showStatus('Drag area not found after refresh', 'error');
        return;
    }
    
    try {
        showStatus('Copying drag area with fresh tree data and relationships...', 'info');
        console.log(`🔄 Copying drag area ${areaId} from dome ${domeId} with fresh data and relationships`);
        
        // ✅ ENHANCED: Debug the area and its trees
        console.log('📊 Area details:', {
            id: area.id,
            name: area.name,
            trees: area.trees,
            treeCount: area.trees ? area.trees.length : 0
        });
        
        // ✅ ENHANCED: Check if trees have breed data before processing
        if (trees && trees.length > 0) {
            const treesWithBreeds = trees.filter(t => t.breed && t.breed.trim().length > 0);
            const treesWithBreedProperty = trees.filter(t => 'breed' in t);
            
            console.log(`🔍 Tree breed status: ${treesWithBreedProperty.length}/${trees.length} have breed property, ${treesWithBreeds.length}/${trees.length} have breed values`);
            
            // ✅ Show breed status in UI
            if (treesWithBreedProperty.length === 0) {
                console.warn('⚠️ Trees missing breed data after refresh, continuing with copy without breed data');
                showStatus('⚠️ Warning: Trees missing breed data', 'warning');
            } else {
                console.log('✅ Trees have breed data after refresh');
                showStatus('✅ Fresh tree data loaded with breed information', 'success');
            }
        }
        
        // ✅ ENHANCED: Process trees with relationship data
        const areaTreesData = [];
        
        if (area.trees && area.trees.length > 0) {
            console.log(`🔍 Processing ${area.trees.length} trees in area with relationships...`);
            
            for (const treeId of area.trees) {
                const tree = trees.find(t => t.id == treeId);
                if (tree) {
                    // ✅ ENHANCED: Debug each tree's breed and relationship data
                    console.log(`🌳 Processing tree ${tree.id}:`, {
                        name: tree.name,
                        breed: tree.breed,
                        plant_type: tree.plant_type,
                        mother_plant_id: tree.mother_plant_id,
                        cutting_notes: tree.cutting_notes
                    });
                    
                    // Calculate relative position within the area
                    const relativeRow = tree.internal_row - area.minRow;
                    const relativeCol = tree.internal_col - area.minCol;
                    
                    // ✅ ENHANCED: Include ALL tree data including relationships
                    const treeData = {
                        id: tree.id,
                        name: tree.name || `Tree ${tree.internal_row}-${tree.internal_col}`,
                        breed: tree.breed || '',
                        life_days: tree.life_days || 0,
                        info: tree.info || '',
                        image_url: tree.image_url || '',
                        originalRow: tree.internal_row,
                        originalCol: tree.internal_col,
                        relativeRow: relativeRow,
                        relativeCol: relativeCol,
                        dome_id: tree.dome_id || domeId,
                        user_id: tree.user_id,
                        created_at: tree.created_at,
                        updated_at: tree.updated_at,
                        
                        // ✅ NEW: Plant relationship data
                        plant_type: tree.plant_type || 'mother',
                        mother_plant_id: tree.mother_plant_id || null,
                        cutting_notes: tree.cutting_notes || '',
                        is_mother_plant: tree.plant_type === 'mother',
                        is_cutting: tree.plant_type === 'cutting',
                        has_mother_relation: !!tree.mother_plant_id,
                        
                        // ✅ NEW: Relationship context for paste operations
                        relationship_context: {
                            original_mother_id: tree.mother_plant_id,
                            needs_mother_mapping: tree.plant_type === 'cutting' && !!tree.mother_plant_id,
                            can_be_mother: tree.plant_type === 'mother',
                            relationship_notes: tree.cutting_notes || ''
                        }
                    };
                    
                    areaTreesData.push(treeData);
                    
                    // ✅ ENHANCED: More detailed logging with relationships
                    console.log(`✅ Tree processed: "${tree.name}"`);
                    console.log(`   🧬 Breed: "${tree.breed}" (${typeof tree.breed})`);
                    console.log(`   🌱 Plant Type: ${tree.plant_type || 'mother'}`);
                    console.log(`   🔗 Mother ID: ${tree.mother_plant_id || 'None'}`);
                    console.log(`   ✂️ Cutting Notes: "${tree.cutting_notes || 'None'}"`);
                    console.log(`   📍 Position: (${tree.internal_row}, ${tree.internal_col}) -> relative (${relativeRow}, ${relativeCol})`);
                    console.log(`   🖼️ Has image: ${!!tree.image_url}`);
                } else {
                    console.warn(`⚠️ Tree ${treeId} not found in frontend trees array`);
                }
            }
        }
        
        // ✅ NEW: Analyze plant relationships in the copied area
        const motherTrees = areaTreesData.filter(t => t.is_mother_plant);
        const cuttingTrees = areaTreesData.filter(t => t.is_cutting);
        const independentTrees = areaTreesData.filter(t => !t.is_mother_plant && !t.is_cutting);
        
        // ✅ NEW: Check for complete vs broken relationships
        const motherIds = new Set(motherTrees.map(m => m.id));
        const cuttingsWithMothersInArea = cuttingTrees.filter(cutting => 
            cutting.mother_plant_id && motherIds.has(cutting.mother_plant_id)
        );
        const cuttingsWithMothersOutsideArea = cuttingTrees.filter(cutting => 
            cutting.mother_plant_id && !motherIds.has(cutting.mother_plant_id)
        );
        
        console.log('🔍 Plant relationship analysis:', {
            motherTrees: motherTrees.length,
            cuttingTrees: cuttingTrees.length,
            independentTrees: independentTrees.length,
            completeRelationships: cuttingsWithMothersInArea.length,
            brokenRelationships: cuttingsWithMothersOutsideArea.length
        });
        
        // ✅ ENHANCED: Debug breed processing before creating summary
        console.log('🔍 Analyzing breeds in copied trees:');
        const allBreeds = areaTreesData.map(t => t.breed);
        console.log('   All breed values:', allBreeds);
        console.log('   Non-empty breeds:', allBreeds.filter(b => b && b.trim().length > 0));
        
        // ✅ ENHANCED: Create comprehensive clipboard data with relationships
        dragClipboard = {
            id: area.id,
            name: area.name,
            type: 'dragArea',
            color: area.color,
            width: area.width,
            height: area.height,
            min_row: area.minRow,
            max_row: area.maxRow,
            min_col: area.minCol,
            max_col: area.maxCol,
            
            // ✅ CRITICAL: Include complete tree data with relationships
            trees: areaTreesData,
            tree_count: areaTreesData.length,
            
            // ✅ Include cell data for area boundary
            cells: area.cells || [],
            
            // ✅ Metadata
            source_dome: domeId,
            source_dome_name: `Dome ${domeId}`,
            copied_at: new Date().toISOString(),
            original_area_id: area.id,
            
            // ✅ ENHANCED: Include summary with relationship data
            summary: {
                total_trees: areaTreesData.length,
                breeds: [...new Set(areaTreesData.map(t => t.breed).filter(b => b && b.trim().length > 0))],
                has_images: areaTreesData.filter(t => t.image_url && t.image_url.trim().length > 0).length,
                area_size: `${area.width}×${area.height}`,
                
                // ✅ NEW: Plant relationship summary
                plant_relationships: {
                    mother_trees: motherTrees.length,
                    cutting_trees: cuttingTrees.length,
                    independent_trees: independentTrees.length,
                    complete_relationships: cuttingsWithMothersInArea.length,
                    broken_relationships: cuttingsWithMothersOutsideArea.length,
                    
                    // ✅ NEW: Detailed relationship mapping
                    relationship_map: {
                        mothers: motherTrees.map(m => ({
                            id: m.id,
                            name: m.name,
                            breed: m.breed,
                            position: `(${m.originalRow}, ${m.originalCol})`
                        })),
                        cuttings_with_mothers: cuttingsWithMothersInArea.map(c => ({
                            id: c.id,
                            name: c.name,
                            breed: c.breed,
                            mother_id: c.mother_plant_id,
                            cutting_notes: c.cutting_notes,
                            position: `(${c.originalRow}, ${c.originalCol})`
                        })),
                        orphaned_cuttings: cuttingsWithMothersOutsideArea.map(c => ({
                            id: c.id,
                            name: c.name,
                            breed: c.breed,
                            original_mother_id: c.mother_plant_id,
                            cutting_notes: c.cutting_notes,
                            position: `(${c.originalRow}, ${c.originalCol})`,
                            needs_new_mother: true
                        }))
                    }
                },
                
                // ✅ Enhanced debug info
                debug: {
                    all_breeds: areaTreesData.map(t => t.breed),
                    breed_count_raw: areaTreesData.map(t => t.breed).length,
                    breed_count_filtered: areaTreesData.map(t => t.breed).filter(b => b && b.trim().length > 0).length,
                    trees_with_breeds: areaTreesData.filter(t => t.breed && t.breed.trim().length > 0).length,
                    copied_after_refresh: true,
                    refresh_timestamp: new Date().toISOString(),
                    has_relationships: motherTrees.length > 0 || cuttingTrees.length > 0,
                    relationship_integrity: cuttingsWithMothersInArea.length === cuttingTrees.length
                }
            }
        };
        
        console.log('📦 Complete clipboard data created with relationships:', dragClipboard);
        console.log('🧬 Breeds copied:', dragClipboard.summary.breeds);
        console.log('🔗 Plant relationships:', dragClipboard.summary.plant_relationships);
        console.log('🖼️ Trees with images:', dragClipboard.summary.has_images);
        
        // ✅ ENHANCED: Save to GLOBAL storage (accessible across all domes)
        try {
            localStorage.setItem('globalDragClipboard', JSON.stringify(dragClipboard));
            localStorage.setItem('globalDragClipboardTimestamp', Date.now().toString());
            console.log('✅ Saved to global storage with relationships');
        } catch (storageError) {
            console.error('❌ Failed to save to localStorage:', storageError);
        }
        
        // ✅ ENHANCED: Broadcast to all open grid pages with relationship data
        try {
            const broadcastData = {
                type: 'drag_area_copied',
                area: dragClipboard,
                timestamp: Date.now(),
                source_dome: domeId,
                copied_after_refresh: true,
                has_relationships: dragClipboard.summary.plant_relationships.mother_trees > 0 || 
                                 dragClipboard.summary.plant_relationships.cutting_trees > 0
            };
            
            // Method 1: BroadcastChannel (modern browsers)
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('clipboard_updates');
                channel.postMessage(broadcastData);
                channel.close();
            }
            
            // Method 2: localStorage event (fallback)
            localStorage.setItem('clipboardBroadcast', JSON.stringify(broadcastData));
            setTimeout(() => {
                localStorage.removeItem('clipboardBroadcast');
            }, 1000);
            
            console.log('📡 Clipboard update with relationships broadcasted');
        } catch (broadcastError) {
            console.warn('❌ Failed to broadcast clipboard update:', broadcastError);
        }
        
        // ✅ Show paste controls on current page
        if (typeof showPasteControls === 'function') {
            showPasteControls();
        }
        
        if (typeof updatePasteButtonVisibility === 'function') {
            updatePasteButtonVisibility();
        }
        
        const treeCount = dragClipboard.tree_count || 0;
        const breedCount = dragClipboard.summary.breeds.length;
        const imageCount = dragClipboard.summary.has_images;
        const motherCount = dragClipboard.summary.plant_relationships.mother_trees;
        const cuttingCount = dragClipboard.summary.plant_relationships.cutting_trees;
        const completeRelationships = dragClipboard.summary.plant_relationships.complete_relationships;
        const brokenRelationships = dragClipboard.summary.plant_relationships.broken_relationships;
        
        // ✅ ENHANCED: More detailed success message with relationship info
        const breedInfo = breedCount > 0 ? `${breedCount} breeds (${dragClipboard.summary.breeds.join(', ')})` : '0 breeds';
        const relationshipInfo = motherCount > 0 || cuttingCount > 0 ? 
            ` | ${motherCount} mothers, ${cuttingCount} cuttings (${completeRelationships} complete, ${brokenRelationships} orphaned)` : '';
        
        showStatus(`✅ Drag area "${area.name}" copied with fresh data: ${treeCount} trees (${breedInfo}, ${imageCount} images${relationshipInfo}) - Available on all domes!`, 'success');
        
        console.log('✅ Drag area copy completed successfully with relationships:', {
            area: area.name,
            trees: areaTreesData.length,
            breeds: dragClipboard.summary.breeds,
            breedCount: breedCount,
            images: imageCount,
            size: `${area.width}×${area.height}`,
            bounds: `(${area.minRow}, ${area.minCol}) to (${area.maxRow}, ${area.maxCol})`,
            relationships: {
                mothers: motherCount,
                cuttings: cuttingCount,
                complete: completeRelationships,
                broken: brokenRelationships,
                independent: dragClipboard.summary.plant_relationships.independent_trees
            },
            debug: dragClipboard.summary.debug,
            copiedAfterRefresh: true
        });
        
        // ✅ NEW: Show relationship summary if there are relationships
        if (motherCount > 0 || cuttingCount > 0) {
            setTimeout(() => {
                showRelationshipCopySummary({
                    mothers: motherCount,
                    cuttings: cuttingCount,
                    complete: completeRelationships,
                    broken: brokenRelationships,
                    areaName: area.name
                });
            }, 2000);
        }
        
    } catch (error) {
        console.error('❌ Error copying drag area with relationships:', error);
        showStatus('Error copying drag area with relationships: ' + error.message, 'error');
    }
}
function showRelationshipCopySummary(relationshipData) {
    const modal = document.createElement('div');
    modal.className = 'relationship-copy-summary-modal';
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            " onclick="event.stopPropagation();">
                <h5 style="margin: 0 0 20px 0; color: #007bff;">🔗 Plant Relationships Copied</h5>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                    <div style="margin-bottom: 10px;">
                        <strong>🌳 Mother Trees:</strong> ${relationshipData.mothers}
                        <small style="color: #666; display: block;">Can produce new cuttings</small>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>✂️ Cutting Trees:</strong> ${relationshipData.cuttings}
                        <small style="color: #666; display: block;">Grown from mother trees</small>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>✅ Complete Relationships:</strong> ${relationshipData.complete}
                        <small style="color: #666; display: block;">Cutting + mother both copied</small>
                    </div>
                    <div>
                        <strong>⚠️ Orphaned Cuttings:</strong> ${relationshipData.broken}
                        <small style="color: #666; display: block;">Cuttings without their mothers</small>
                    </div>
                </div>
                
                ${relationshipData.complete > 0 ? `
                    <div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                        <strong>✅ Great!</strong> ${relationshipData.complete} complete mother-cutting relationship(s) will be preserved when pasted.
                    </div>
                ` : ''}
                
                ${relationshipData.broken > 0 ? `
                    <div style="background: #fff3cd; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #ffc107;">
                        <strong>⚠️ Note:</strong> ${relationshipData.broken} cutting tree(s) will be pasted as independent trees since their mothers weren't included in "${relationshipData.areaName}".
                    </div>
                ` : ''}
                
                <div style="text-align: right;">
                    <button onclick="this.closest('.relationship-copy-summary-modal').remove();" style="
                        padding: 8px 16px;
                        background: #007bff;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 14px;
                    ">OK</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (modal.parentNode) {
            modal.remove();
        }
    }, 10000);
}
// ✅ NEW: Initialize pending copy check when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait for page to fully load before checking for pending copy
    setTimeout(() => {
        executePendingCopy();
    }, 3000); // Wait 3 seconds for all initialization to complete
});

// ✅ NEW: Also check for pending copy after areas are loaded
function checkPendingCopyAfterAreasLoaded() {
    setTimeout(() => {
        executePendingCopy();
    }, 1000);
}

// ✅ Hook into existing area loading to trigger pending copy check
const originalLoadAreasFromBackend = loadAreasFromBackend;
loadAreasFromBackend = async function() {
    const result = await originalLoadAreasFromBackend.apply(this, arguments);
    
    // Check for pending copy after areas are loaded
    checkPendingCopyAfterAreasLoaded();
    
    return result;
};

console.log('✅ Enhanced copyDragArea with page refresh functionality loaded');

// ✅ NEW: Global functions for bulk tree creation modal
window.bulkTreeCreationCancel = function() {
    const modal = document.querySelector('.bulk-tree-creation-modal');
    if (modal) {
        modal.remove();
    }
    if (window.bulkTreeCreationResolve) {
        window.bulkTreeCreationResolve(null);
        window.bulkTreeCreationResolve = null;
    }
};

window.bulkTreeCreationSubmit = function() {
    const name = document.getElementById('bulkTreeName').value.trim() || 'Tree';
    const breed = document.getElementById('bulkTreeBreed').value;
    const plantType = document.getElementById('bulkPlantType').value;
    const motherPlantId = document.getElementById('bulkMotherPlant').value || null;
    const info = document.getElementById('bulkTreeInfo').value.trim();
    
    const modal = document.querySelector('.bulk-tree-creation-modal');
    if (modal) {
        modal.remove();
    }
    
    if (window.bulkTreeCreationResolve) {
        window.bulkTreeCreationResolve({
            name: name,
            breed: breed,
            plant_type: plantType,
            mother_plant_id: motherPlantId,
            info: info,
            cutting_notes: plantType === 'cutting' ? 'Bulk created from area fill' : ''
        });
        window.bulkTreeCreationResolve = null;
    }
};

function ensureGridScrolling() {
    const container = document.getElementById('gridContainer');
    if (!container) {
        console.warn('⚠️ Grid container not found');
        return false;
    }
    
    // ✅ Enable both horizontal and vertical scrolling
    container.style.overflowX = 'auto';
    container.style.overflowY = 'auto';
    
    // ✅ Set dimensions to enable scrolling
    if (!container.style.maxHeight) {
        container.style.maxHeight = '80vh';
    }
    if (!container.style.maxWidth) {
        container.style.maxWidth = '100vw';
    }
    
    console.log('✅ Grid scrolling configuration updated');
    return true;
}
function scrollToTreePositionAlternative(row, col) {
    console.log(`🎯 Alternative scroll to position (${row}, ${col})`);
    
    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (!targetCell) {
        console.error(`❌ Cell not found at position (${row}, ${col})`);
        return false;
    }
    
    // ✅ Method 1: Use scrollIntoView (scrolls entire page)
    targetCell.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'center'
    });
    
    // ✅ Highlight the cell
    setTimeout(() => {
        targetCell.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        targetCell.style.border = '3px solid red';
        targetCell.style.transition = 'all 0.3s ease';
        targetCell.style.transform = 'scale(1.1)';
        targetCell.style.zIndex = '1000';
        targetCell.style.position = 'relative';
        
        setTimeout(() => {
            targetCell.style.backgroundColor = '';
            targetCell.style.border = '';
            targetCell.style.transform = '';
            targetCell.style.zIndex = '';
            targetCell.style.position = '';
        }, 3000);
    }, 500);
    
    console.log(`✅ Alternative scroll completed for position (${row}, ${col})`);
    return true;
}

        // ✅ FIXED: Keyboard navigation
function addKeyboardNavigation() {
    document.addEventListener('keydown', function(e) {
        const container = document.getElementById('gridContainer');
        
        const scrollAmount = 100;
        
        switch(e.key) {
            case 'v':
case 'V':
    // Handle Ctrl+V for paste
    if (e.ctrlKey && clipboardArea) {
        e.preventDefault();
        enableClickToPaste();
    }
    break;
            case 'ArrowLeft':
                if (!container) return;
                e.preventDefault();
                container.scrollLeft -= scrollAmount;
                break;
            case 'ArrowRight':
                if (!container) return;
                e.preventDefault();
                container.scrollLeft += scrollAmount;
                break;
            case 'ArrowUp':
                if (!container) return;
                e.preventDefault();
                container.scrollTop -= scrollAmount;
                break;
            case 'ArrowDown':
                if (!container) return;
                e.preventDefault();
                container.scrollLeft += scrollAmount;
                break;
            case ' ':
                if (!container) return;
                e.preventDefault();
                centerGrid();
                break;
            case 'Home':
                if (!container) return;
                e.preventDefault();
                scrollToPosition('start');
                break;
            case 'End':
                if (!container) return;
                e.preventDefault();
                scrollToPosition('end');
                break;
            case 'Escape':
                // ✅ ADDED: Handle Escape key for modals and drag mode
                e.preventDefault();
                
                // Close drag area modal if open
                const modal = document.querySelector('.drag-area-modal');
                if (modal) {
                    modal.remove();
                    if (dragSelector && typeof dragSelector.cancelAreaCreation === 'function') {
                        dragSelector.cancelAreaCreation();
                    }
                    return;
                }
                
                // Exit selection mode if active
                if (selectionMode && typeof toggleSelectionMode === 'function') {
                    toggleSelectionMode();
                    return;
                }
                
                // Exit drag mode if active
                if (dragSelector && dragSelector.isDragMode) {
                    dragSelector.disableDragMode();
                    return;
                }
                
                // Exit line drag mode if active
                if (typeof dragLineMode !== 'undefined' && dragLineMode && typeof toggleDragLineMode === 'function') {
                    toggleDragLineMode();
                    return;
                }
                
                // Close any other modals
                const anyModal = document.querySelector('[style*="position: fixed"]');
                if (anyModal && anyModal.innerHTML.includes('modal')) {
                    anyModal.remove();
                }
                break;
            case 'Delete':
                // ✅ ADDED: Handle Delete key for selected trees
                if (dragSelector && dragSelector.selectedTrees.size > 0) {
                    e.preventDefault();
                    if (confirm(`Delete ${dragSelector.selectedTrees.size} selected trees?`)) {
                        dragSelector.bulkDeleteSelected();
                    }
                }
                break;
            case 'a':
            case 'A':
                // ✅ ADDED: Handle Ctrl+A for select all
                if (e.ctrlKey && dragSelector && dragSelector.isDragMode) {
                    e.preventDefault();
                    // Select all trees
                    document.querySelectorAll('.tree-item').forEach(tree => {
                        const treeId = tree.dataset.treeId;
                        if (treeId) {
                            dragSelector.selectTree(treeId, tree);
                        }
                    });
                    if (typeof dragSelector.showSelectionActions === 'function') {
                        dragSelector.showSelectionActions();
                    }
                }
                break;
            case 'l':
            case 'L':
                // ✅ ADDED: Handle Ctrl+L for line mode toggle
                if (e.ctrlKey && typeof toggleDragLineMode === 'function') {
                    e.preventDefault();
                    toggleDragLineMode();
                }
                break;
        }
    });
}
function autoSaveAreas() {
    try {
        if (typeof saveLineAreasToStorage === 'function') {
            saveLineAreasToStorage();
        }
        
        if (typeof updateAreasDisplay === 'function') {
            updateAreasDisplay();
        }
        
        if (typeof renderAreas === 'function') {
            renderAreas();
        }
        
        console.log('✅ Areas auto-saved');
        
    } catch (error) {
        console.error('❌ Error auto-saving areas:', error);
    }
}

function testSelection() {
    console.log('=== SELECTION TEST ===');
    console.log('Selection mode:', selectionMode);
    console.log('Is selecting:', isSelecting);
    console.log('Selection start:', selectionStart);
    console.log('Selection end:', selectionEnd);
    console.log('Selected cells:', selectedCells);
    console.log('Areas:', areas);
    
    // Test manual selection

    
    // Simulate selection
    setTimeout(() => {
        console.log('Simulating selection...');
        handleCellMouseDown({ preventDefault: () => {}, stopPropagation: () => {} }, 0, 0);
        handleCellMouseEnter({ preventDefault: () => {}, stopPropagation: () => {} }, 2, 2);
        handleCellMouseUp({ preventDefault: () => {}, stopPropagation: () => {} }, 2, 2);
    }, 1000);
    
    showStatus('Selection test started - check console', 'info');
}
        // ✅ FIXED: Test navigation function
        function testNavigation() {
            console.log('Testing navigation functions...');
            console.log('Dome ID:', domeId);
            console.log('Available navigation:');
            console.log('- goBack() -> /dome_info/' + domeId);
            console.log('- goToMainIndex() -> /farm/{{ dome.farm_id }}/domes');
            showStatus('Navigation test completed - check console', 'info');
        }
// ✅ ADD THIS: Drag Selection Box Implementation
class DragSelector {
    constructor(gridContainer) {
        this.gridContainer = gridContainer;
        this.isSelecting = false;
        this.isDragMode = false;
        this.startX = 0;
        this.startY = 0;
        this.selectionBox = null;
        this.selectedTrees = new Set();
        this.selectedCells = new Set();
        this.init();
    }
    
    init() {
        this.createSelectionBox();
        this.bindEvents();
    }
saveDragAreasToDatabase() {
    dragAreas.forEach(async (area) => {
        if (!area.saved_to_db) {
            try {
                console.log(`💾 Syncing unsaved drag area "${area.name}" to database...`);
                
                const response = await fetch(`/api/save_drag_area/${domeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: area.name,
                        color: area.color,
                        minRow: area.minRow,
                        maxRow: area.maxRow,
                        minCol: area.minCol,
                        maxCol: area.maxCol,
                        width: area.width,
                        height: area.height,
                        trees: area.trees,
                        visible: area.visible
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Update the area with database ID
                    area.id = result.drag_area_id;
                    area.saved_to_db = true;
                    console.log(`✅ Drag area "${area.name}" synced to database with ID ${area.id}`);
                    
                    // Update localStorage with new ID
                    this.saveDragAreasToStorage();
                } else {
                    console.error(`❌ Failed to sync drag area "${area.name}":`, result.error);
                }
            } catch (error) {
                console.error(`❌ Error syncing drag area "${area.name}":`, error);
            }
        }
    });
}
    createSelectionBox() {
        // Create the visual selection box
        this.selectionBox = document.createElement('div');
        this.selectionBox.className = 'drag-selection-box';
        this.selectionBox.style.cssText = `
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 1000;
            display: none;
        `;
        this.gridContainer.appendChild(this.selectionBox);
    }
    
    bindEvents() {
        // Mouse events for drag selection
        this.gridContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        
        // Prevent context menu during drag
        this.gridContainer.addEventListener('contextmenu', (e) => {
            if (this.isSelecting) {
                e.preventDefault();
            }
        });
    }
// ✅ ADD these methods INSIDE your DragSelector class (around line 3000)

pasteDragArea() {
    if (!dragClipboard || dragClipboard.type !== 'dragArea') {
        showStatus('No area in clipboard to paste', 'warning');
        return;
    }
    
    // Show paste dialog to choose position
    this.showPasteAreaDialog();
}


executePasteArea() {
    const name = document.getElementById('paste-area-name').value.trim();
    const pasteRow = parseInt(document.getElementById('paste-row').value);
    const pasteCol = parseInt(document.getElementById('paste-col').value);
    
    if (!name) {
        alert('Please enter an area name');
        return;
    }
    
    if (dragAreas.some(area => area.name === name)) {
        alert('Area name already exists. Please choose a different name.');
        return;
    }
    
    // Validate position
    if (pasteRow < 0 || pasteCol < 0 || 
        pasteRow + dragClipboard.height > currentRows ||
        pasteCol + dragClipboard.width > currentCols) {
        alert('Area would extend outside grid boundaries. Please choose a different position.');
        return;
    }
    
    // Create new area
    const newArea = {
        id: dragAreaIdCounter++,
        name: name,
        color: dragClipboard.color,
        cells: [], // Will be populated if trees are created
        trees: [], // Will be populated if trees are created
        visible: true,
        minRow: pasteRow,
        maxRow: pasteRow + dragClipboard.height - 1,
        minCol: pasteCol,
        maxCol: pasteCol + dragClipboard.width - 1,
        width: dragClipboard.width,
        height: dragClipboard.height,
        createdAt: new Date().toISOString()
    };
    
    dragAreas.push(newArea);
    this.renderDragAreas();
    this.updateDragAreasDisplay();
    this.saveDragAreasToStorage();
    
    showStatus(`Area "${name}" pasted successfully! (Trees not copied - area boundary only)`, 'success');
    console.log('✅ Area pasted:', newArea);
}
enableDragMode() {
    this.isDragMode = true;
    this.gridContainer.style.cursor = 'crosshair';
    this.gridContainer.classList.add('drag-mode');
    
    // Add visual indicator
    this.showDragModeIndicator();
    
    // ✅ FIXED: Update toggle button state
    const toggleButton = document.querySelector('[onclick*="dragSelector"]');
    if (toggleButton) {
        toggleButton.innerHTML = '❌ Exit Drag';
        toggleButton.style.background = '#dc3545';
    }
    
    showStatus('Drag selection mode enabled. Click and drag to select trees.', 'info');
    console.log('✅ Drag mode enabled');
}

    
disableDragMode() {
    this.isDragMode = false;
    this.gridContainer.style.cursor = 'default';
    this.gridContainer.classList.remove('drag-mode');
    this.clearSelection();
    this.hideDragModeIndicator();
    
    // ✅ FIXED: Update toggle button state
    const toggleButton = document.querySelector('[onclick*="dragSelector"]');
    if (toggleButton) {
        toggleButton.innerHTML = '🎯 Drag Select';
        toggleButton.style.background = '#17a2b8';
    }
    
    console.log('✅ Drag mode disabled');
}

    
    showDragModeIndicator() {
        // Create or show drag mode indicator
        let indicator = document.getElementById('drag-mode-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'drag-mode-indicator';
            indicator.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #007bff;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 5px;
                    z-index: 10000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                    font-weight: bold;
                ">
                    🎯 Drag Selection Mode
                    <button onclick="dragSelector.disableDragMode()" style="
                        background: none;
                        border: none;
                        color: white;
                        margin-left: 10px;
                        cursor: pointer;
                        font-size: 16px;
                    ">×</button>
                </div>
            `;
            document.body.appendChild(indicator);
        }
        indicator.style.display = 'block';
    }
    
    hideDragModeIndicator() {
        const indicator = document.getElementById('drag-mode-indicator');
        if (indicator) {
            indicator.style.display = 'none';
        }
    }
    
    handleMouseDown(e) {
        if (!this.isDragMode) return;
        
        // Only start selection on empty grid cells or if holding Ctrl/Cmd
        const target = e.target;
        if (target.classList.contains('tree-item') && !e.ctrlKey && !e.metaKey) {
            return; // Let tree interaction handle this
        }
        
        e.preventDefault();
        this.isSelecting = true;
        
        const rect = this.gridContainer.getBoundingClientRect();
        this.startX = e.clientX - rect.left;
        this.startY = e.clientY - rect.top;
        
        // Show selection box
        this.selectionBox.style.left = this.startX + 'px';
        this.selectionBox.style.top = this.startY + 'px';
        this.selectionBox.style.width = '0px';
        this.selectionBox.style.height = '0px';
        this.selectionBox.style.display = 'block';
        
        // Clear previous selection if not holding Ctrl/Cmd
        if (!e.ctrlKey && !e.metaKey) {
            this.clearSelection();
        }
    }
    
    handleMouseMove(e) {
        if (!this.isSelecting || !this.isDragMode) return;
        
        e.preventDefault();
        
        const rect = this.gridContainer.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        // Calculate selection box dimensions
        const left = Math.min(this.startX, currentX);
        const top = Math.min(this.startY, currentY);
        const width = Math.abs(currentX - this.startX);
        const height = Math.abs(currentY - this.startY);
        
        // Update selection box
        this.selectionBox.style.left = left + 'px';
        this.selectionBox.style.top = top + 'px';
        this.selectionBox.style.width = width + 'px';
        this.selectionBox.style.height = height + 'px';
        
        // ✅ UPDATED: Use new method name
        this.updateCellSelection(left, top, width, height);
    }
    
    handleMouseUp(e) {
        if (!this.isSelecting) return;
        
        console.log('🖱️ Mouse up - Selection complete');
        
        this.isSelecting = false;
        this.selectionBox.style.display = 'none';
        
        console.log('📊 Selection results:', {
            selectedCells: this.selectedCells.size,
            selectedTrees: this.selectedTrees.size,
            cells: Array.from(this.selectedCells),
            trees: Array.from(this.selectedTrees)
        });
        
        // ✅ ENHANCED: Show dialog if ANY cells are selected (not just trees)
        if (this.selectedCells.size > 0) {
            console.log('✅ Showing create area dialog for selected cells');
            this.showCreateAreaDialog();
        } else {
            console.log('⚠️ No cells selected');
            showStatus('No area selected. Try dragging over grid cells.', 'warning');
        }
    }
    
    // ✅ UPDATED: Enhanced create area dialog
    showCreateAreaDialog() {
        // Remove any existing modals first
        const existingModal = document.querySelector('.drag-area-modal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const emptyCellsCount = this.selectedCells.size - this.selectedTrees.size;
        const selectionInfo = this.getSelectionInfo();
        
        console.log('📋 Showing create area dialog with selection info:', selectionInfo);
        
        const modal = document.createElement('div');
        modal.className = 'drag-area-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            " onclick="this.remove(); dragSelector.cancelAreaCreation();">
                <div style="
                    background: white;
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 450px;
                    width: 90%;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h5 style="margin: 0 0 20px 0; color: #007bff;">🎯 Create Drag Area</h5>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                        <div><strong>📐 Size:</strong> ${selectionInfo.width} × ${selectionInfo.height} cells</div>
                        <div><strong>📍 Position:</strong> Row ${selectionInfo.minRow}-${selectionInfo.maxRow}, Col ${selectionInfo.minCol}-${selectionInfo.maxCol}</div>
                        <div><strong>🌳 Trees:</strong> ${this.selectedTrees.size}</div>
                        <div><strong>📦 Empty:</strong> ${emptyCellsCount}</div>
                        <div><strong>📊 Total:</strong> ${this.selectedCells.size} cells</div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Area Name:</label>
                        <input type="text" id="drag-area-name" placeholder="Enter area name" style="
                            width: 100%; 
                            padding: 8px; 
                            border: 1px solid #ddd; 
                            border-radius: 4px;
                        ">
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Color:</label>
                        <select id="drag-area-color" style="
                            width: 100%; 
                            padding: 8px; 
                            border: 1px solid #ddd; 
                            border-radius: 4px;
                        ">
                            <option value="#007bff">🔵 Blue</option>
                            <option value="#28a745">🟢 Green</option>
                            <option value="#dc3545">🔴 Red</option>
                            <option value="#ffc107">🟡 Yellow</option>
                            <option value="#6f42c1">🟣 Purple</option>
                            <option value="#fd7e14">🟠 Orange</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="this.closest('.drag-area-modal').remove(); dragSelector.cancelAreaCreation();" style="
                            padding: 8px 16px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Cancel</button>
                        <button onclick="dragSelector.createDragAreaFromModal(); this.closest('.drag-area-modal').remove();" style="
                            padding: 8px 16px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Create Area</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Focus on name input
        setTimeout(() => {
            const nameInput = modal.querySelector('#drag-area-name');
            if (nameInput) {
                nameInput.focus();
            }
        }, 100);
    }
    getSelectionInfo() {
        if (!this.selectedCells || this.selectedCells.size === 0) {
            return { width: 0, height: 0, minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
        }
        
        const cells = Array.from(this.selectedCells).map(cellKey => {
            const [row, col] = cellKey.split(',').map(Number);
            return { row, col };
        });
        
        const minRow = Math.min(...cells.map(c => c.row));
        const maxRow = Math.max(...cells.map(c => c.row));
        const minCol = Math.min(...cells.map(c => c.col));
        const maxCol = Math.max(...cells.map(c => c.col));
        
        return {
            width: maxCol - minCol + 1,
            height: maxRow - minRow + 1,
            minRow,
            maxRow,
            minCol,
            maxCol
        };
    }
createDragAreaFromModal() {
    const name = document.getElementById('drag-area-name').value.trim();
    const color = document.getElementById('drag-area-color').value;
    
    if (!name) {
        alert('Please enter an area name');
        return false;
    }
    
    if (this.selectedCells.size === 0) {
        alert('No cells selected');
        return false;
    }
    
    // Check for duplicate names
    if (typeof dragAreas !== 'undefined' && dragAreas.some(area => area.name.toLowerCase() === name.toLowerCase())) {
        alert('Area name already exists');
        return false;
    }
    
    const selectionInfo = this.getSelectionInfo();
    const { minRow, maxRow, minCol, maxCol } = selectionInfo;
    
    // ✅ ENHANCED: Create cells data for both trees and empty cells
    const cellsData = Array.from(this.selectedCells).map(cellKey => {
        const [row, col] = cellKey.split(',').map(Number);
        return { row, col };
    });
    
    console.log('💾 Creating drag area with enhanced data:', {
        name,
        color,
        bounds: { minRow, maxRow, minCol, maxCol },
        selectedCells: this.selectedCells.size,
        selectedTrees: this.selectedTrees.size,
        cellsData: cellsData
    });
    
    // ✅ FIXED: Use saveDragAreaToDatabase with enhanced data
    this.saveDragAreaToDatabase(
        name, 
        color, 
        minRow, 
        maxRow, 
        minCol, 
        maxCol, 
        Array.from(this.selectedTrees),
        cellsData // ✅ NEW: Pass cells data including empty cells
    )
    .then(savedArea => {
        if (savedArea) {
            // ✅ CRITICAL: Check if area already exists before adding
            const existingIndex = dragAreas.findIndex(area => area.id === savedArea.id);
            if (existingIndex === -1) {
                // Area doesn't exist, add it
                dragAreas.push(savedArea);
                console.log('✅ New drag area added to array:', savedArea);
            } else {
                // Area already exists, update it
                dragAreas[existingIndex] = savedArea;
                console.log('✅ Existing drag area updated:', savedArea);
            }
            
            this.clearSelection();
            this.disableDragMode();
            this.renderDragAreas();
            this.updateDragAreasDisplay();
            this.saveDragAreasToStorage(); // Also save to localStorage as backup
            
            const emptyCells = this.selectedCells.size - this.selectedTrees.size;
            showStatus(`Drag area "${name}" created and saved! (${this.selectedTrees.size} trees, ${emptyCells} empty cells)`, 'success');
            console.log('✅ Drag area created and saved:', savedArea);
            
            // ✅ ENHANCED: Close the modal
            const modal = document.querySelector('.drag-area-modal');
            if (modal) {
                modal.remove();
            }
            
            return true;
        } else {
            // ✅ ENHANCED: Fallback to localStorage with complete cell data
            const area = {
                id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                name: name,
                color: color,
                cells: cellsData, // ✅ FIXED: Use complete cells data
                trees: Array.from(this.selectedTrees),
                visible: true,
                minRow: minRow,
                maxRow: maxRow,
                minCol: minCol,
                maxCol: maxCol,
                width: maxCol - minCol + 1,
                height: maxRow - minRow + 1,
                createdAt: new Date().toISOString(),
                saved_to_db: false, // Mark as not saved to DB
                tree_count: this.selectedTrees.size,
                empty_count: this.selectedCells.size - this.selectedTrees.size,
                total_cells: this.selectedCells.size
            };
            
            // ✅ CRITICAL: Check for duplicates before adding
            const existingLocalIndex = dragAreas.findIndex(a => a.name === area.name);
            if (existingLocalIndex === -1) {
                dragAreas.push(area);
                console.log('✅ Local drag area added:', area);
            } else {
                console.log('⚠️ Local area with same name already exists, skipping');
                return false;
            }
            
            this.clearSelection();
            this.disableDragMode();
            this.renderDragAreas();
            this.updateDragAreasDisplay();
            this.saveDragAreasToStorage();
            
            const emptyCells = area.empty_count;
            showStatus(`Drag area "${name}" created locally! (${area.tree_count} trees, ${emptyCells} empty cells)`, 'warning');
            console.log('⚠️ Drag area created locally only:', area);
            
            // ✅ ENHANCED: Close the modal
            const modal = document.querySelector('.drag-area-modal');
            if (modal) {
                modal.remove();
            }
            
            return true;
        }
    })
    .catch(error => {
        console.error('❌ Error creating drag area:', error);
        showStatus('Error creating drag area: ' + error.message, 'error');
        return false;
    });
    
    return true; // Return true to close modal
}
async saveDragAreaToDatabase(name, color, minRow, maxRow, minCol, maxCol, selectedTrees, cellsData = null) {
    try {
        console.log('💾 Saving drag area to database...');
        
        const payload = {
            name: name,
            color: color,
            min_row: minRow,
            max_row: maxRow,
            min_col: minCol,
            max_col: maxCol,
            tree_ids: selectedTrees,
            cells_data: cellsData || []
        };
        
        console.log('📤 Sending to create endpoint:', payload);
        
        // ✅ FIXED: Use dedicated create endpoint
        const response = await fetch(`/api/create_drag_area/${domeId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('❌ Backend error:', errorText);
            return null;
        }
        
        const result = await response.json();
        
        if (result.success) {
            return {
                id: result.drag_area_id,
                name: name,
                color: color,
                cells: cellsData || [],
                trees: selectedTrees,
                visible: true,
                minRow: minRow,
                maxRow: maxRow,
                minCol: minCol,
                maxCol: maxCol,
                width: maxCol - minCol + 1,
                height: maxRow - minRow + 1,
                created_at: result.area.created_at,
                saved_to_db: true,
                tree_count: selectedTrees.length,
                empty_count: cellsData ? cellsData.length - selectedTrees.length : 0,
                total_cells: cellsData ? cellsData.length : 0
            };
        } else {
            console.error('❌ Backend error:', result.error);
            return null;
        }
        
    } catch (error) {
        console.error('❌ Network error:', error);
        return null;
    }
}

    updateCellSelection(selectionLeft, selectionTop, selectionWidth, selectionHeight) {
        console.log('🎯 Updating cell selection with bounds:', {
            left: selectionLeft,
            top: selectionTop,
            width: selectionWidth,
            height: selectionHeight
        });
        
        // Clear previous visual highlights
        document.querySelectorAll('.cell-selected, .tree-selected').forEach(el => {
            el.classList.remove('cell-selected', 'tree-selected');
        });
        document.querySelectorAll('.cell-selection-highlight').forEach(el => el.remove());
        
        // ✅ ENHANCED: Find ALL grid cells (not just ones with trees)
        const gridCells = this.gridContainer.querySelectorAll('.grid-cell[data-row][data-col]');
        console.log('🔍 Found grid cells:', gridCells.length);
        
        let cellsProcessed = 0;
        let cellsSelected = 0;
        let treesSelected = 0;
        let emptyCellsSelected = 0;
        
        gridCells.forEach((cell, index) => {
            cellsProcessed++;
            
            // Validate cell data
            if (!cell.dataset.row || !cell.dataset.col) {
                if (index < 3) {
                    console.warn(`⚠️ Cell ${index} missing data attributes:`, cell);
                }
                return;
            }
            
            // Get cell position relative to grid container
            const cellRect = cell.getBoundingClientRect();
            const containerRect = this.gridContainer.getBoundingClientRect();
            
            const cellLeft = cellRect.left - containerRect.left + this.gridContainer.scrollLeft;
            const cellTop = cellRect.top - containerRect.top + this.gridContainer.scrollTop;
            const cellRight = cellLeft + cellRect.width;
            const cellBottom = cellTop + cellRect.height;
            
            // Check intersection with selection box
            const intersects = !(
                cellRight < selectionLeft ||
                cellLeft > selectionLeft + selectionWidth ||
                cellBottom < selectionTop ||
                cellTop > selectionTop + selectionHeight
            );
            
            if (intersects) {
                cellsSelected++;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const cellKey = `${row},${col}`;
                
                console.log(`✅ Cell intersects: (${row}, ${col})`);
                
                // ✅ ENHANCED: Add ALL intersecting cells to selection
                this.selectedCells.add(cellKey);
                cell.classList.add('cell-selected');
                
                // Add visual highlight to the cell
                this.addCellHighlight(cell);
                
                // ✅ ENHANCED: Check if cell contains a tree
                const tree = cell.querySelector('[data-tree-id]');
                if (tree && tree.dataset.treeId) {
                    // Cell has a tree
                    const treeId = tree.dataset.treeId;
                    this.selectedTrees.add(treeId);
                    tree.classList.add('tree-selected');
                    treesSelected++;
                    console.log(`🌳 Selected tree ${treeId} at (${row}, ${col})`);
                } else {
                    // Empty cell
                    emptyCellsSelected++;
                    console.log(`📦 Selected empty cell at (${row}, ${col})`);
                }
            }
        });
        
        console.log(`🎯 Selection update complete:`, {
            cellsProcessed,
            cellsSelected,
            treesSelected,
            emptyCellsSelected,
            totalSelectedCells: this.selectedCells.size,
            totalSelectedTrees: this.selectedTrees.size
        });
    }
    addCellHighlight(cell) {
        // Remove existing highlight
        const existingHighlight = cell.querySelector('.cell-selection-highlight');
        if (existingHighlight) {
            existingHighlight.remove();
        }
        
        // Add new highlight
        const highlight = document.createElement('div');
        highlight.className = 'cell-selection-highlight';
        highlight.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 5;
            border-radius: 4px;
            box-sizing: border-box;
        `;
        
        // Ensure cell has relative positioning
        if (cell.style.position !== 'relative' && cell.style.position !== 'absolute') {
            cell.style.position = 'relative';
        }
        
        cell.appendChild(highlight);
    }
        
    selectTree(treeId, treeElement) {
        this.selectedTrees.add(treeId);
        treeElement.classList.add('selected');
        
        // Add selection highlight
        if (!treeElement.querySelector('.selection-highlight')) {
            const highlight = document.createElement('div');
            highlight.className = 'selection-highlight';
            highlight.style.cssText = `
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border: 3px solid #007bff;
                border-radius: 8px;
                pointer-events: none;
                z-index: 10;
            `;
            treeElement.style.position = 'relative';
            treeElement.appendChild(highlight);
        }
    }
    
    deselectTree(treeId, treeElement) {
        this.selectedTrees.delete(treeId);
        treeElement.classList.remove('selected');
        
        // Remove selection highlight
        const highlight = treeElement.querySelector('.selection-highlight');
        if (highlight) {
            highlight.remove();
        }
    }
    
    clearSelection() {
        console.log('🧹 Clearing selection...');
        
        // Clear visual highlights
        document.querySelectorAll('.cell-selected, .tree-selected').forEach(el => {
            el.classList.remove('cell-selected', 'tree-selected');
        });
        document.querySelectorAll('.cell-selection-highlight').forEach(el => el.remove());
        
        // Clear selection sets
        this.selectedCells.clear();
        this.selectedTrees.clear();
        
        console.log('✅ Selection cleared');
    }
    
    showSelectionActions() {
        // Create or show selection actions panel
        let actionsPanel = document.getElementById('selection-actions-panel');
        if (!actionsPanel) {
            actionsPanel = document.createElement('div');
            actionsPanel.id = 'selection-actions-panel';
            actionsPanel.innerHTML = `
                <div style="
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: white;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 15px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                    z-index: 10000;
                    display: flex;
                    gap: 10px;
                    align-items: center;
                ">
                    <span id="selection-count" style="font-weight: bold; margin-right: 10px;">
                        ${this.selectedTrees.size} trees selected
                    </span>
                    <button onclick="dragSelector.bulkDeleteSelected()" class="btn btn-danger btn-sm">
                        🗑️ Delete
                    </button>
                    <button onclick="dragSelector.showBulkEditModal()" class="btn btn-primary btn-sm">
                        ✏️ Edit
                    </button>
                    <button onclick="dragSelector.clearSelection()" class="btn btn-secondary btn-sm">
                        ❌ Clear
                    </button>
                </div>
            `;
            document.body.appendChild(actionsPanel);
        }
        
        // Update count
        const countElement = actionsPanel.querySelector('#selection-count');
        if (countElement) {
            countElement.textContent = `${this.selectedTrees.size} trees selected`;
        }
        
        actionsPanel.style.display = 'block';
    }
    
    hideSelectionActions() {
        const actionsPanel = document.getElementById('selection-actions-panel');
        if (actionsPanel) {
            actionsPanel.style.display = 'none';
        }
    }
    
    bulkDeleteSelected() {
        if (this.selectedTrees.size === 0) return;
        
        if (confirm(`Are you sure you want to delete ${this.selectedTrees.size} selected trees?`)) {
            const treeIds = Array.from(this.selectedTrees);
            
            fetch('/bulk_delete_trees', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    tree_ids: treeIds
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove trees from DOM
                    treeIds.forEach(treeId => {
                        const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
                        if (treeElement) {
                            const cell = treeElement.closest('.grid-cell');
                            if (cell) {
                                // Remove tree from trees array
                                trees = trees.filter(t => t.id != treeId);
                                // Re-render the cell as empty
                                const row = parseInt(cell.dataset.row);
                                const col = parseInt(cell.dataset.col);
                                cell.innerHTML = `
                                    <div class="coordinate-label">${row},${col}</div>
                                    <button class="add-tree-btn" onclick="addTreeAtPosition(${row}, ${col})">+</button>
                                `;
                                cell.classList.remove('occupied');
                            }
                        }
                    });
                    
                    this.clearSelection();
                    updateStats();
                    showStatus('Trees deleted successfully', 'success');
                } else {
                    showStatus('Failed to delete trees: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Error deleting trees', 'error');
            });
        }
    }
    
    showBulkEditModal() {
        // Create bulk edit modal
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            ">
                <div style="
                    background: white;
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 500px;
                    width: 90%;
                ">
                    <h5 style="margin: 0 0 20px 0;">Bulk Edit ${this.selectedTrees.size} Trees</h5>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">Life Days (leave empty to keep current)</label>
                        <input type="number" id="bulk-life-days" min="0" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px;">Info (leave empty to keep current)</label>
                        <textarea id="bulk-info" rows="3" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="
                            padding: 8px 16px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Cancel</button>
                        <button onclick="dragSelector.applyBulkEdit(); this.closest('[style*=\"position: fixed\"]').remove();" style="
                            padding: 8px 16px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Apply Changes</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
// ✅ ADD THESE MISSING FUNCTIONS TO YOUR DragSelector CLASS

createDragArea() {
    const name = document.getElementById('drag-area-name').value.trim();
    const color = document.getElementById('drag-area-color').value;
    
    if (!name) {
        alert('Please enter an area name');
        return;
    }
    
    if (this.selectedTrees.size === 0) {
        alert('Please select trees first');
        return;
    }
    
    // Check if name already exists
    if (dragAreas.some(area => area.name === name)) {
        alert('Area name already exists. Please choose a different name.');
        return;
    }
    
    // Get positions of selected trees
    const treeCells = [];
    this.selectedTrees.forEach(treeId => {
        const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
        if (treeElement) {
            const cell = treeElement.closest('.grid-cell');
            if (cell) {
                treeCells.push({
                    row: parseInt(cell.dataset.row),
                    col: parseInt(cell.dataset.col),
                    treeId: treeId
                });
            }
        }
    });
    
    if (treeCells.length === 0) {
        alert('No valid tree positions found');
        return;
    }
    
    // Calculate area bounds
    const minRow = Math.min(...treeCells.map(c => c.row));
    const maxRow = Math.max(...treeCells.map(c => c.row));
    const minCol = Math.min(...treeCells.map(c => c.col));
    const maxCol = Math.max(...treeCells.map(c => c.col));
    
    const area = {
        id: dragAreaIdCounter++,
        name: name,
        color: color,
        cells: treeCells,
        trees: Array.from(this.selectedTrees),
        visible: true,
        minRow: minRow,
        maxRow: maxRow,
        minCol: minCol,
        maxCol: maxCol,
        width: maxCol - minCol + 1,
        height: maxRow - minRow + 1,
        createdAt: new Date().toISOString()
    };
    
    dragAreas.push(area);
    this.clearSelection();
    this.renderDragAreas();
    this.updateDragAreasDisplay();
    this.saveDragAreasToStorage();
    
    showStatus(`Drag area "${name}" created successfully!`, 'success');
    console.log('✅ Drag area created:', area);
}

cancelAreaCreation() {
    this.clearSelection();
    this.disableDragMode(); // ✅ FIXED: Disable drag mode when canceling
    showStatus('Area creation cancelled', 'info');
}

renderDragAreas() {
    // Remove existing drag area overlays
    document.querySelectorAll('.drag-area-overlay').forEach(overlay => overlay.remove());
    
    dragAreas.forEach(area => {
        if (!area.visible) return;
        
        this.renderSingleDragArea(area);
    });
    
    console.log('✅ Rendered', dragAreas.filter(a => a.visible).length, 'drag areas');
}

renderSingleDragArea(area) {
    const grid = document.getElementById('treeGrid');
    if (!grid) return;
    
    const minRow = area.minRow;
    const maxRow = area.maxRow;
    const minCol = area.minCol;
    const maxCol = area.maxCol;
    
    // Find the corner cells
    const topLeftCell = document.querySelector(`[data-row="${minRow}"][data-col="${minCol}"]`);
    const bottomRightCell = document.querySelector(`[data-row="${maxRow}"][data-col="${maxCol}"]`);
    
    if (topLeftCell && bottomRightCell) {
        const gridRect = grid.getBoundingClientRect();
        const topLeftRect = topLeftCell.getBoundingClientRect();
        const bottomRightRect = bottomRightCell.getBoundingClientRect();
        
        const overlay = document.createElement('div');
        overlay.className = 'drag-area-overlay';
        overlay.dataset.areaId = area.id;
        overlay.style.cssText = `
            position: absolute;
            border: 3px solid ${area.color};
            border-radius: 8px;
            background: ${area.color}15;
            pointer-events: none;
            z-index: 5;
            left: ${topLeftRect.left - gridRect.left + grid.scrollLeft - 2}px;
            top: ${topLeftRect.top - gridRect.top + grid.scrollTop - 2}px;
            width: ${bottomRightRect.right - topLeftRect.left + 4}px;
            height: ${bottomRightRect.bottom - topLeftRect.top + 4}px;
        `;
        
        // Add area label
        const label = document.createElement('div');
        label.className = 'drag-area-label';
        label.textContent = area.name;
        label.style.cssText = `
            position: absolute;
            top: -25px;
            left: 0;
            background: ${area.color};
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            white-space: nowrap;
            z-index: 6;
        `;
        overlay.appendChild(label);
        
        // Add tree count indicator
        const treeCount = document.createElement('div');
        treeCount.textContent = `${area.trees.length} trees`;
        treeCount.style.cssText = `
            position: absolute;
            bottom: -20px;
            right: 0;
            background: ${area.color};
            color: white;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            z-index: 6;
        `;
        overlay.appendChild(treeCount);
        
        grid.style.position = 'relative';
        grid.appendChild(overlay);
    }
}

updateDragAreasDisplay() {
    console.log('📊 Updating drag areas display with accurate tree counts...');
    
    let dragAreasList = document.getElementById('dragAreasList');
    if (!dragAreasList) {
        dragAreasList = document.createElement('div');
        dragAreasList.id = 'dragAreasList';
        dragAreasList.className = 'area-list';
        dragAreasList.innerHTML = '<h3>🎯 Drag Areas</h3><div id="dragAreasContainer"></div>';
        
        const regularAreasList = document.getElementById('areasList');
        if (regularAreasList) {
            regularAreasList.parentNode.insertBefore(dragAreasList, regularAreasList.nextSibling);
        } else {
            document.querySelector('.container').appendChild(dragAreasList);
        }
    }
    
    const container = document.getElementById('dragAreasContainer');
    
    if (!dragAreas || dragAreas.length === 0) {
        container.innerHTML = '<p>No drag areas created yet</p>';
        dragAreasList.style.display = 'none';
        return;
    }
    
    dragAreasList.style.display = 'block';
    
    // ✅ CRITICAL: Debug the global trees array first
    console.log('🔍 Debug info for tree counting:');
    console.log('  - Global trees array length:', trees ? trees.length : 'undefined');
    console.log('  - Drag areas to process:', dragAreas.length);
    
    if (!trees || !Array.isArray(trees)) {
        console.error('❌ Global trees array is not available or not an array');
        container.innerHTML = '<p style="color: red;">Error: Trees data not available</p>';
        return;
    }
    
    // ✅ ENHANCED: Process each area with detailed logging
    const updatedAreas = dragAreas.map((area, index) => {
        console.log(`\n🔍 Processing area ${index + 1}: "${area.name}"`);
        console.log(`  - Area bounds: (${area.minRow},${area.minCol}) to (${area.maxRow},${area.maxCol})`);
        console.log(`  - Area size: ${area.width}×${area.height}`);
        console.log(`  - Stored tree count: ${area.tree_count || 'undefined'}`);
        console.log(`  - Stored tree IDs: ${area.trees ? area.trees.length : 'undefined'}`);
        
        // ✅ CRITICAL: Use the same tree detection logic as copyDragArea
        const treesInArea = trees.filter(tree => {
            // ✅ ENHANCED: Validate tree data first
            if (!tree || tree.internal_row === undefined || tree.internal_col === undefined) {
                console.warn('⚠️ Tree missing position data:', tree);
                return false;
            }
            
            // ✅ CRITICAL: Ensure numeric comparison
            const treeRow = parseInt(tree.internal_row);
            const treeCol = parseInt(tree.internal_col);
            const areaMinRow = parseInt(area.minRow);
            const areaMaxRow = parseInt(area.maxRow);
            const areaMinCol = parseInt(area.minCol);
            const areaMaxCol = parseInt(area.maxCol);
            
            const inBounds = treeRow >= areaMinRow && 
                           treeRow <= areaMaxRow &&
                           treeCol >= areaMinCol && 
                           treeCol <= areaMaxCol;
            
            if (inBounds) {
                console.log(`  ✅ Tree "${tree.name}" at (${treeRow}, ${treeCol}) is in area`);
            }
            
            return inBounds;
        });
        
        const actualTreeCount = treesInArea.length;
        const totalCells = area.width * area.height;
        const emptyCells = totalCells - actualTreeCount;
        
        console.log(`  📊 Results: ${actualTreeCount} trees found, ${emptyCells} empty cells`);
        
        // ✅ CRITICAL: Update the area object with correct data
        area.tree_count = actualTreeCount;
        area.trees = treesInArea.map(t => t.id);
        area.empty_count = emptyCells;
        area.total_cells = totalCells;
        
        // ✅ ENHANCED: Log any discrepancies
        const storedCount = area.tree_count || 0;
        if (storedCount !== actualTreeCount) {
            console.log(`  🔧 Fixed count: ${storedCount} → ${actualTreeCount}`);
        }
        
        return area;
    });
    
    // ✅ ENHANCED: Generate HTML with accurate data
    container.innerHTML = updatedAreas.map(area => {
        const createdDate = area.created_at ? new Date(area.created_at).toLocaleString() : 'Unknown';
        
        return `
            <div class="area-item" style="border-left: 4px solid ${area.color};">
                <div style="display: flex; align-items: center;">
                    <div class="area-color" style="background-color: ${area.color}; width: 20px; height: 20px; border-radius: 50%; margin-right: 10px; cursor: pointer; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" 
                         onclick="event.stopPropagation(); event.preventDefault(); dragSelector.editDragAreaColor(${area.id})" 
                         title="Click to change color"></div>
                    <div class="area-info">
                        <strong>${area.name}</strong><br>
                        <small>🌳 ${area.tree_count} trees, 📦 ${area.empty_count} empty (${area.width}×${area.height})</small><br>
                        <small style="color: #666;">Position: (${area.minRow},${area.minCol}) to (${area.maxRow},${area.maxCol}) • Created: ${createdDate}</small>
                    </div>
                </div>
                <div class="area-actions">
                    <button class="area-btn toggle" 
                            onclick="event.stopPropagation(); event.preventDefault(); dragSelector.toggleDragAreaVisibility(${area.id})" 
                            title="Show/Hide">
                        ${area.visible ? '👁️' : '🙈'}
                    </button>
                    <button class="area-btn copy" 
                    onclick="event.stopPropagation(); event.preventDefault(); dragSelector.copyDragArea(${area.id})" 
                    title="Copy">
                    📋
                    </button>
                    <button class="area-btn fill" 
                    onclick="event.stopPropagation(); event.preventDefault(); dragSelector.fillAreaWithTrees(${area.id})" 
                    title="Fill Empty Cells with Trees">
                    🌱
                    </button>
                    <button class="area-btn edit" 
                    onclick="event.stopPropagation(); event.preventDefault(); dragSelector.editDragArea(${area.id})" 
                    title="Edit Name">
                    ✏️
                    </button>
                    <button class="area-btn color" 
                    onclick="event.stopPropagation(); event.preventDefault(); dragSelector.editDragAreaColor(${area.id})" 
                    title="Change Color">
                    🎨
                    </button>
                    <button class="area-btn delete" 
                    onclick="event.stopPropagation(); event.preventDefault(); dragSelector.deleteDragArea(${area.id})" 
                    title="Delete">
                    🗑️
                    </button>
                </div>
            </div>
        `;
    }).join('');
    
    console.log(`✅ Updated drag areas display with corrected tree counts`);
    
    // ✅ NEW: Save the corrected data
    this.saveDragAreasToStorage();
}
toggleDragAreaVisibility(areaId) {
    event.stopPropagation();
    
    const area = dragAreas.find(a => a.id === areaId);
    if (area) {
        area.visible = !area.visible;
        this.renderDragAreas();
        this.updateDragAreasDisplay();
        this.saveDragAreasToStorage();
        showStatus(`Drag area "${area.name}" ${area.visible ? 'shown' : 'hidden'}`, 'info');
    }
}

editDragArea(areaId) {
    event.stopPropagation();
    
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) return;
    
    const newName = prompt('Enter new area name:', area.name);
    if (newName && newName.trim() && newName.trim() !== area.name) {
        // Check if new name already exists
        if (dragAreas.some(a => a.name === newName.trim() && a.id !== areaId)) {
            alert('Area name already exists. Please choose a different name.');
            return;
        }
        
        area.name = newName.trim();
        this.renderDragAreas();
        this.updateDragAreasDisplay();
        this.saveDragAreasToStorage();
        showStatus(`Drag area renamed to "${area.name}"`, 'success');
    }
}

async deleteDragArea(areaId) {
    if (typeof event !== 'undefined') {
        event.stopPropagation();
        event.preventDefault();
    }
    
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        showStatus('Drag area not found', 'error');
        return;
    }
    
    console.log(`🔍 Found drag area: "${area.name}"`);
    
    // ✅ ENHANCED: Show deletion options modal
    const treeCount = area.tree_count || area.trees?.length || 0;
    const deletionChoice = await this.showDragAreaDeletionModal(area, treeCount);
    
    if (!deletionChoice) {
        console.log('❌ Drag area deletion canceled by user');
        return;
    }
    
    // ✅ CRITICAL: Show loading status
    showStatus(`Processing deletion for drag area "${area.name}"...`, 'info');
    
    // Execute the chosen deletion option
    await this.executeDragAreaDeletion(area, deletionChoice);
}

// ✅ NEW: Show deletion options modal for drag areas
showDragAreaDeletionModal(area, treeCount) {
    return new Promise((resolve) => {
        // Remove any existing modal
        const existingModal = document.querySelector('.drag-area-deletion-modal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.className = 'drag-area-deletion-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            " onclick="this.remove(); resolve(null);">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h4 style="margin: 0 0 20px 0; color: #dc3545; display: flex; align-items: center; gap: 10px;">
                        🗑️ Delete Drag Area
                    </h4>
                    
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #2196f3;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px;">
                            <div><strong>Area Name:</strong> ${area.name}</div>
                            <div><strong>Type:</strong> Drag Area</div>
                            <div><strong>Trees:</strong> ${treeCount}</div>
                            <div><strong>Size:</strong> ${area.width || 'unknown'}×${area.height || 'unknown'}</div>
                        </div>
                    </div>
                    
                    <p style="margin-bottom: 25px; color: #666; font-size: 14px;">
                        Choose what you want to delete:
                    </p>
                    
                    <div style="display: grid; gap: 15px; margin-bottom: 25px;">
                        <button class="deletion-option" data-choice="area-only" style="
                            padding: 15px 20px;
                            background: #ffc107;
                            color: #212529;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🏷️</span>
                            <div>
                                <div style="margin-bottom: 4px;">Delete Area Only</div>
                                <small style="opacity: 0.8; font-weight: normal;">Remove drag area boundary, keep all ${treeCount} trees</small>
                            </div>
                        </button>
                        
                        ${treeCount > 0 ? `
                        <button class="deletion-option" data-choice="trees-only" style="
                            padding: 15px 20px;
                            background: #fd7e14;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🌳</span>
                            <div>
                                <div style="margin-bottom: 4px;">Delete Trees Only</div>
                                <small style="opacity: 0.8; font-weight: normal;">Remove all ${treeCount} trees, keep drag area boundary</small>
                            </div>
                        </button>
                        ` : `
                        <button disabled style="
                            padding: 15px 20px;
                            background: #e9ecef;
                            color: #6c757d;
                            border: none;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🌳</span>
                            <div>
                                <div style="margin-bottom: 4px;">Delete Trees Only</div>
                                <small style="opacity: 0.6; font-weight: normal;">No trees in this area to delete</small>
                            </div>
                        </button>
                        `}
                        
                        <button class="deletion-option" data-choice="both" style="
                            padding: 15px 20px;
                            background: #dc3545;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">💥</span>
                            <div>
                                <div style="margin-bottom: 4px;">Delete Everything</div>
                                <small style="opacity: 0.8; font-weight: normal;">Remove drag area and all ${treeCount} trees (cannot be undone)</small>
                            </div>
                        </button>
                    </div>
                    
                    <div style="padding-top: 15px; border-top: 1px solid #eee;">
                        <button onclick="this.closest('.drag-area-deletion-modal').remove(); resolve(null);" style="
                            width: 100%;
                            padding: 12px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                        ">Cancel</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Add click handlers for deletion options
        const optionButtons = modal.querySelectorAll('.deletion-option');
        optionButtons.forEach(button => {
            button.addEventListener('click', () => {
                const choice = button.dataset.choice;
                modal.remove();
                resolve(choice);
            });
            
            // Add hover effects
            button.addEventListener('mouseenter', () => {
                const originalBg = button.style.background;
                if (originalBg.includes('#ffc107')) {
                    button.style.background = '#e0a800';
                } else if (originalBg.includes('#fd7e14')) {
                    button.style.background = '#e8690b';
                } else if (originalBg.includes('#dc3545')) {
                    button.style.background = '#c82333';
                }
                button.style.transform = 'translateY(-2px)';
                button.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            });
            
            button.addEventListener('mouseleave', () => {
                const choice = button.dataset.choice;
                if (choice === 'area-only') {
                    button.style.background = '#ffc107';
                } else if (choice === 'trees-only') {
                    button.style.background = '#fd7e14';
                } else if (choice === 'both') {
                    button.style.background = '#dc3545';
                }
                button.style.transform = 'translateY(0)';
                button.style.boxShadow = 'none';
            });
        });
        
        // Keyboard navigation
        modal.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                resolve(null);
            }
        });
        
        // Make resolve available globally for the cancel button
        window.resolve = resolve;
    });
}

// ✅ NEW: Execute the chosen deletion option for drag areas
async executeDragAreaDeletion(area, choice) {
    try {
        switch (choice) {
            case 'area-only':
                await this.deleteDragAreaOnly(area);
                break;
                
            case 'trees-only':
                await this.deleteDragAreaTreesOnly(area);
                break;
                
            case 'both':
                await this.deleteDragAreaAndTrees(area);
                break;
                
            default:
                console.error('❌ Invalid deletion choice:', choice);
                showStatus('Invalid deletion option selected', 'error');
                return;
        }
        
    } catch (error) {
        console.error('❌ Error executing drag area deletion:', error);
        showStatus('Error during deletion: ' + error.message, 'error');
    }
}

// ✅ NEW: Delete drag area only (keep trees)
async deleteDragAreaOnly(area) {
    try {
        console.log(`🏷️ Deleting drag area only: "${area.name}"`);
        
        const response = await fetch(`/api/delete_drag_area/${domeId}/${area.id}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Remove from local array
            dragAreas = dragAreas.filter(a => a.id !== area.id);
            
            // Update displays
            this.renderDragAreas();
            this.updateDragAreasDisplay();
            this.saveDragAreasToStorage();
            
            // Re-render grid
            renderGrid();
            
            showStatus(`Drag area "${area.name}" deleted. Trees preserved.`, 'success');
            console.log(`✅ Drag area deleted (area only): ${area.name}`);
        } else {
            throw new Error(result.error || 'Failed to delete drag area');
        }
    } catch (error) {
        console.error('❌ Error deleting drag area only:', error);
        throw error;
    }
}

async deleteDragAreaTreesOnly(area) {
    try {
        const treeIds = area.trees || area.tree_ids || [];
        
        if (treeIds.length === 0) {
            showStatus('No trees found in this drag area to delete', 'warning');
            return;
        }
        
        console.log(`🌳 Deleting ${treeIds.length} trees from drag area "${area.name}"`);
        
        // ✅ FIXED: Delete trees individually since bulk API doesn't exist
        let deletedCount = 0;
        let failedCount = 0;
        
        showStatus(`Deleting ${treeIds.length} trees...`, 'info');
        
        for (const treeId of treeIds) {
            try {
                const deleteResponse = await fetch(`/api/delete_tree/${treeId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (deleteResponse.ok) {
                    const result = await deleteResponse.json();
                    if (result.success !== false) {
                        deletedCount++;
                        // Remove from local trees array
                        trees = trees.filter(tree => tree.id != treeId);
                        console.log(`✅ Tree ${treeId} deleted successfully`);
                    } else {
                        failedCount++;
                        console.warn(`⚠️ Failed to delete tree ${treeId}:`, result.error);
                    }
                } else {
                    failedCount++;
                    console.warn(`⚠️ HTTP error deleting tree ${treeId}:`, deleteResponse.status);
                }
            } catch (error) {
                failedCount++;
                console.error(`❌ Error deleting tree ${treeId}:`, error);
            }
        }
        
        // Update drag area to have no trees (or remove failed ones)
        const areaIndex = dragAreas.findIndex(a => a.id === area.id);
        if (areaIndex !== -1) {
            if (failedCount === 0) {
                // All trees deleted successfully
                dragAreas[areaIndex].trees = [];
                dragAreas[areaIndex].tree_count = 0;
            } else {
                // Some trees failed to delete, update the list
                const remainingTreeIds = treeIds.filter(treeId => {
                    return trees.some(tree => tree.id == treeId);
                });
                dragAreas[areaIndex].trees = remainingTreeIds;
                dragAreas[areaIndex].tree_count = remainingTreeIds.length;
            }
        }
        
        // Update displays
        this.renderDragAreas();
        this.updateDragAreasDisplay();
        this.saveDragAreasToStorage();
        renderGrid();
        
        if (typeof updateStats === 'function') {
            updateStats();
        }
        
        // Show appropriate status message
        if (failedCount === 0) {
            showStatus(`${deletedCount} trees deleted from drag area "${area.name}". Area boundary preserved.`, 'success');
            console.log(`✅ All trees deleted from drag area: ${area.name} (${deletedCount} trees)`);
        } else if (deletedCount > 0) {
            showStatus(`${deletedCount} trees deleted, ${failedCount} failed from drag area "${area.name}".`, 'warning');
            console.log(`⚠️ Partial deletion from drag area: ${area.name} (${deletedCount} deleted, ${failedCount} failed)`);
        } else {
            throw new Error(`Failed to delete any trees (${failedCount} failures)`);
        }
        
    } catch (error) {
        console.error('❌ Error deleting trees from drag area:', error);
        throw error;
    }
}

// ✅ FIXED: Delete both drag area and trees (using individual deletion)
async deleteDragAreaTreesOnly(area) {
    try {
        const treeIds = area.trees || area.tree_ids || [];
        
        if (treeIds.length === 0) {
            showStatus('No trees found in this drag area to delete', 'warning');
            return;
        }
        
        console.log(`🌳 Deleting ${treeIds.length} trees from drag area "${area.name}"`);
        
        let deletedCount = 0;
        let failedCount = 0;
        
        showStatus(`Deleting ${treeIds.length} trees...`, 'info');
        
        // ✅ FIXED: Use same tree detection pattern as copyDragArea
        for (const treeId of treeIds) {
            try {
                // Find the tree in global trees array (same as copyDragArea)
                const tree = trees.find(t => t.id == treeId);
                if (!tree) {
                    console.warn(`⚠️ Tree ${treeId} not found in global trees array`);
                    failedCount++;
                    continue;
                }
                
                console.log(`🗑️ Deleting tree "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
                
                // ✅ FIXED: Use correct API endpoint (same as working endpoints)
                const deleteResponse = await fetch(`/delete_tree/${treeId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (deleteResponse.ok) {
                    const result = await deleteResponse.json();
                    if (result.success !== false) {
                        deletedCount++;
                        
                        // ✅ Remove from global trees array
                        trees = trees.filter(t => t.id != treeId);
                        
                        // ✅ FIXED: Remove from DOM (same pattern as bulkDeleteSelected)
                        const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
                        if (treeElement) {
                            const cell = treeElement.closest('.grid-cell');
                            if (cell) {
                                const row = parseInt(cell.dataset.row);
                                const col = parseInt(cell.dataset.col);
                                cell.innerHTML = `
                                    <div class="coordinate-label">${row},${col}</div>
                                    <button class="add-tree-btn" onclick="addTreeAtPosition(${row}, ${col})">+</button>
                                `;
                                cell.classList.remove('occupied');
                            }
                        }
                        
                        console.log(`✅ Tree ${treeId} deleted successfully`);
                    } else {
                        failedCount++;
                        console.warn(`⚠️ Failed to delete tree ${treeId}:`, result.error);
                    }
                } else {
                    failedCount++;
                    console.warn(`⚠️ HTTP error deleting tree ${treeId}:`, deleteResponse.status);
                }
                
            } catch (error) {
                failedCount++;
                console.error(`❌ Error deleting tree ${treeId}:`, error);
            }
            
            // Small delay to prevent server overload
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Update drag area to remove deleted trees
        const areaIndex = dragAreas.findIndex(a => a.id === area.id);
        if (areaIndex !== -1) {
            // Only keep trees that failed to delete
            const remainingTreeIds = treeIds.filter(treeId => {
                return trees.some(tree => tree.id == treeId);
            });
            dragAreas[areaIndex].trees = remainingTreeIds;
            dragAreas[areaIndex].tree_count = remainingTreeIds.length;
        }
        
        // Update displays
        this.renderDragAreas();
        this.updateDragAreasDisplay();
        this.saveDragAreasToStorage();
        renderGrid();
        
        if (typeof updateStats === 'function') {
            updateStats();
        }
        
        // Show results
        if (failedCount === 0) {
            showStatus(`${deletedCount} trees deleted from drag area "${area.name}". Area boundary preserved.`, 'success');
            console.log(`✅ All trees deleted from drag area: ${area.name} (${deletedCount} trees)`);
        } else if (deletedCount > 0) {
            showStatus(`${deletedCount} trees deleted, ${failedCount} failed from drag area "${area.name}".`, 'warning');
            console.log(`⚠️ Partial deletion from drag area: ${area.name} (${deletedCount} deleted, ${failedCount} failed)`);
        } else {
            throw new Error(`Failed to delete any trees (${failedCount} failures)`);
        }
        
    } catch (error) {
        console.error('❌ Error deleting trees from drag area:', error);
        throw error;
    }
}

// ✅ FIXED: Delete both drag area and trees (using corrected tree deletion)
async deleteDragAreaAndTrees(area) {
    try {
        const treeIds = area.trees || area.tree_ids || [];
        
        console.log(`💥 Deleting drag area "${area.name}" and ${treeIds.length} trees`);
        
        let deletedTreeCount = 0;
        let failedTreeCount = 0;
        
        // First delete trees if any exist
        if (treeIds.length > 0) {
            showStatus(`Deleting ${treeIds.length} trees...`, 'info');
            
            // ✅ FIXED: Use same tree detection and deletion pattern
            for (const treeId of treeIds) {
                try {
                    // Find the tree in global trees array (same as copyDragArea)
                    const tree = trees.find(t => t.id == treeId);
                    if (!tree) {
                        console.warn(`⚠️ Tree ${treeId} not found in global trees array`);
                        failedTreeCount++;
                        continue;
                    }
                    
                    console.log(`🗑️ Deleting tree "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
                    
                    // ✅ FIXED: Use correct API endpoint
                    const deleteTreeResponse = await fetch(`/delete_tree/${treeId}`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (deleteTreeResponse.ok) {
                        const treeResult = await deleteTreeResponse.json();
                        if (treeResult.success !== false) {
                            deletedTreeCount++;
                            
                            // Remove from global trees array
                            trees = trees.filter(tree => tree.id != treeId);
                            
                            // ✅ FIXED: Remove from DOM
                            const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
                            if (treeElement) {
                                const cell = treeElement.closest('.grid-cell');
                                if (cell) {
                                    const row = parseInt(cell.dataset.row);
                                    const col = parseInt(cell.dataset.col);
                                    cell.innerHTML = `
                                        <div class="coordinate-label">${row},${col}</div>
                                        <button class="add-tree-btn" onclick="addTreeAtPosition(${row}, ${col})">+</button>
                                    `;
                                    cell.classList.remove('occupied');
                                }
                            }
                            
                            console.log(`✅ Tree ${treeId} deleted successfully`);
                        } else {
                            failedTreeCount++;
                            console.warn(`⚠️ Failed to delete tree ${treeId}:`, treeResult.error);
                        }
                    } else {
                        failedTreeCount++;
                        console.warn(`⚠️ HTTP error deleting tree ${treeId}:`, deleteTreeResponse.status);
                    }
                } catch (treeError) {
                    failedTreeCount++;
                    console.error(`❌ Error deleting tree ${treeId}:`, treeError);
                }
                
                // Small delay to prevent server overload
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            console.log(`🌳 Tree deletion summary: ${deletedTreeCount} deleted, ${failedTreeCount} failed`);
        }
        
        // Then delete the drag area
        showStatus(`Deleting drag area "${area.name}"...`, 'info');
        
        const deleteAreaResponse = await fetch(`/api/delete_drag_area/${domeId}/${area.id}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (deleteAreaResponse.ok) {
            const areaResult = await deleteAreaResponse.json();
            
            if (areaResult.success !== false) {
                // Remove from local array
                dragAreas = dragAreas.filter(a => a.id !== area.id);
                
                // Update displays
                this.renderDragAreas();
                this.updateDragAreasDisplay();
                this.saveDragAreasToStorage();
                
                // Re-render grid
                renderGrid();
                
                if (typeof updateStats === 'function') {
                    updateStats();
                }
                
                // Show comprehensive status message
                let statusMessage = `Drag area "${area.name}" deleted.`;
                if (deletedTreeCount > 0) {
                    statusMessage += ` ${deletedTreeCount} trees deleted.`;
                }
                if (failedTreeCount > 0) {
                    statusMessage += ` ${failedTreeCount} trees failed to delete.`;
                }
                
                const statusType = failedTreeCount > 0 ? 'warning' : 'success';
                showStatus(statusMessage, statusType);
                
                console.log(`✅ Complete deletion completed for drag area: ${area.name} (${deletedTreeCount} trees deleted, ${failedTreeCount} failed)`);
            } else {
                throw new Error(areaResult.error || 'Failed to delete drag area');
            }
        } else {
            // Area deletion failed, but some trees might have been deleted
            const errorText = await deleteAreaResponse.text();
            const errorMessage = `Failed to delete drag area (HTTP ${deleteAreaResponse.status}): ${errorText}`;
            
            if (deletedTreeCount > 0) {
                showStatus(`${deletedTreeCount} trees deleted, but area deletion failed: ${errorMessage}`, 'warning');
            } else {
                throw new Error(errorMessage);
            }
        }
        
    } catch (error) {
        console.error('❌ Error deleting drag area and trees:', error);
        throw error;
    }
}

// ✅ ALSO FIX: The bulk delete in DragSelector class
async bulkDeleteSelected() {
    if (this.selectedTrees.size === 0) {
        showStatus('No trees selected for deletion', 'warning');
        return;
    }
    
    const treeCount = this.selectedTrees.size;
    const confirmMessage = `Are you sure you want to delete ${treeCount} selected trees?\n\nThis action cannot be undone.`;
    
    if (!confirm(confirmMessage)) {
        console.log('❌ Bulk deletion cancelled by user');
        return;
    }
    
    try {
        const treeIds = Array.from(this.selectedTrees);
        console.log(`🗑️ Starting bulk deletion of ${treeIds.length} trees:`, treeIds);
        
        showStatus(`Deleting ${treeIds.length} trees...`, 'info');
        
        let deletedCount = 0;
        let failedCount = 0;
        
        // ✅ FIXED: Use same pattern as copyDragArea for tree detection
        for (const treeId of treeIds) {
            try {
                // Find the tree in global trees array (same as copyDragArea)
                const tree = trees.find(t => t.id == treeId);
                if (!tree) {
                    console.warn(`⚠️ Tree ${treeId} not found in global trees array`);
                    failedCount++;
                    continue;
                }
                
                console.log(`🗑️ Deleting tree "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
                
                // ✅ FIXED: Use correct API endpoint
                const response = await fetch(`/delete_tree/${treeId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success !== false) {
                        deletedCount++;
                        
                        // Remove from global trees array
                        trees = trees.filter(t => t.id != treeId);
                        
                        // Remove from DOM
                        const treeElement = document.querySelector(`[data-tree-id="${treeId}"]`);
                        if (treeElement) {
                            const cell = treeElement.closest('.grid-cell');
                            if (cell) {
                                const row = parseInt(cell.dataset.row);
                                const col = parseInt(cell.dataset.col);
                                cell.innerHTML = `
                                    <div class="coordinate-label">${row},${col}</div>
                                    <button class="add-tree-btn" onclick="addTreeAtPosition(${row}, ${col})">+</button>
                                `;
                                cell.classList.remove('occupied');
                            }
                        }
                        
                        // Remove from drag areas
                        dragAreas.forEach(area => {
                            if (area.trees && area.trees.includes(treeId)) {
                                area.trees = area.trees.filter(id => id != treeId);
                                area.tree_count = area.trees.length;
                                console.log(`🗑️ Removed tree ${treeId} from drag area "${area.name}"`);
                            }
                        });
                        
                        console.log(`✅ Tree ${treeId} deleted successfully`);
                    } else {
                        failedCount++;
                        console.error(`❌ Failed to delete tree ${treeId}:`, result.error);
                    }
                } else {
                    failedCount++;
                    const errorText = await response.text();
                    console.error(`❌ HTTP error deleting tree ${treeId}:`, response.status, errorText);
                }
                
            } catch (error) {
                failedCount++;
                console.error(`❌ Network error deleting tree ${treeId}:`, error);
            }
            
            // Small delay to prevent overwhelming the server
            if (treeIds.length > 10) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }
        
        // Clear selection and update UI
        this.clearSelection();
        
        if (typeof this.updateDragAreasDisplay === 'function') {
            this.updateDragAreasDisplay();
        }
        
        if (typeof this.renderDragAreas === 'function') {
            this.renderDragAreas();
        }
        
        if (typeof updateStats === 'function') {
            updateStats();
        }
        
        // Show results
        if (failedCount === 0) {
            showStatus(`✅ All ${deletedCount} trees deleted successfully!`, 'success');
            console.log(`✅ Bulk deletion completed successfully: ${deletedCount} trees deleted`);
        } else if (deletedCount > 0) {
            showStatus(`⚠️ ${deletedCount} trees deleted, ${failedCount} failed. Check console for details.`, 'warning');
            console.log(`⚠️ Partial bulk deletion: ${deletedCount} deleted, ${failedCount} failed`);
        } else {
            showStatus(`❌ Failed to delete any trees. Check console for details.`, 'error');
            console.error('❌ Bulk deletion failed completely');
        }
        
    } catch (error) {
        console.error('❌ Unexpected error during bulk deletion:', error);
        showStatus('Unexpected error during bulk deletion: ' + error.message, 'error');
    }
}
async copyDragArea(areaId) {
    // ✅ CRITICAL: Prevent event bubbling to parent elements
    if (typeof event !== 'undefined') {
        event.stopPropagation();
        event.preventDefault();
    }
    
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        showStatus('Drag area not found', 'error');
        return;
    }
    
    try {
        console.log(`📋 Copying drag area ${areaId} from dome ${domeId}`);
        showStatus('Analyzing area for copying...', 'info');
        
        // ✅ CRITICAL: Get ONLY trees that are actually IN the selected area bounds
        const treesInArea = trees.filter(tree => {
            if (!tree || tree.internal_row === undefined || tree.internal_col === undefined) {
                return false;
            }
            
            const treeRow = parseInt(tree.internal_row);
            const treeCol = parseInt(tree.internal_col);
            const areaMinRow = parseInt(area.minRow);
            const areaMaxRow = parseInt(area.maxRow);
            const areaMinCol = parseInt(area.minCol);
            const areaMaxCol = parseInt(area.maxCol);
            
            const inBounds = treeRow >= areaMinRow && 
                           treeRow <= areaMaxRow &&
                           treeCol >= areaMinCol && 
                           treeCol <= areaMaxCol;
            
            if (inBounds) {
                console.log(`✅ Tree "${tree.name}" at (${treeRow}, ${treeCol}) is in area bounds - Type: ${tree.plant_type || 'mother'}`);
            }
            
            return inBounds;
        });
        
        console.log(`🔍 Found ${treesInArea.length} trees actually in the selected area`);
        
        if (treesInArea.length === 0) {
            console.log('⚠️ No trees found in area - copying area boundary only');
            // Create clipboard with just the area boundary
            const clipboardData = this.createEmptyAreaClipboard(area);
            this.storeClipboardData(clipboardData, 'frontend_empty');
            showStatus(`Area "${area.name}" copied (no trees)`, 'success');
            return;
        }
        
        // ✅ FIXED: Call analyzeTreeRelationships without async/await since it's now synchronous
        const relationshipAnalysis = this.analyzeTreeRelationships(treesInArea);
        
        console.log('🔍 Relationship Analysis:', relationshipAnalysis);
        
        // Show copy options dialog to let user choose how to copy
        const copyOptions = await this.showCopyOptionsDialog(area, treesInArea, relationshipAnalysis);
        
        if (!copyOptions) {
            console.log('❌ Copy operation cancelled by user');
            return;
        }
        
        let clipboardData;
        let clipboardSource;
        let statusMessage;
        
        switch (copyOptions.mode) {
            case 'selected_only':
                clipboardData = this.createClipboardFromSelectedTrees(area, treesInArea);
                clipboardSource = 'frontend_selected_only';
                statusMessage = `Copied ${treesInArea.length} trees (selected only)`;
                break;
                
            case 'with_relationships':
                // Include related trees to preserve relationships
                const { enhancedTreesData, relationshipStats } = this.analyzeAndIncludeRelatedTrees(treesInArea, area);
                clipboardData = this.createClipboardWithRelationships(area, enhancedTreesData, relationshipStats);
                clipboardSource = 'frontend_with_relationships';
                statusMessage = `Copied ${enhancedTreesData.length} trees (${treesInArea.length} selected + ${relationshipStats.related_outside_area} related)`;
                break;
                
            case 'area_only':
                clipboardData = this.createEmptyAreaClipboard(area);
                clipboardSource = 'frontend_area_only';
                statusMessage = `Copied area boundary only (no trees)`;
                break;
                
            default:
                console.error('❌ Unknown copy mode:', copyOptions.mode);
                showStatus('Unknown copy mode selected', 'error');
                return;
        }
        
        if (!clipboardData) {
            throw new Error('Failed to create clipboard data');
        }
        
        // Store clipboard data
        this.storeClipboardData(clipboardData, clipboardSource);
        
        console.log('✅ Area copied to clipboard:', clipboardData);
        showStatus(statusMessage, 'success');
        
        // Show paste options dialog
        setTimeout(() => {
            if (typeof showPasteOptionsDialog === 'function') {
                showPasteOptionsDialog();
            }
        }, 500);
        
    } catch (error) {
        console.error('❌ Error copying drag area:', error);
        showStatus('Error copying area: ' + error.message, 'error');
    }
}

// ✅ NEW: Fill empty cells in area with trees
async fillAreaWithTrees(areaId) {
    // ✅ CRITICAL: Prevent event bubbling to parent elements
    if (typeof event !== 'undefined') {
        event.stopPropagation();
        event.preventDefault();
    }

    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        showStatus('Drag area not found', 'error');
        return;
    }

    try {
        console.log(`🌱 Filling empty cells in drag area "${area.name}" (ID: ${areaId})`);
        
        // Find all cells in the area
        const areaCells = [];
        for (let row = area.minRow; row <= area.maxRow; row++) {
            for (let col = area.minCol; col <= area.maxCol; col++) {
                areaCells.push({ row, col });
            }
        }

        // Find empty cells (cells without trees)
        const emptyCells = areaCells.filter(cell => {
            return !trees.some(tree => 
                parseInt(tree.internal_row) === cell.row && 
                parseInt(tree.internal_col) === cell.col
            );
        });

        console.log(`📊 Area analysis: ${areaCells.length} total cells, ${emptyCells.length} empty cells`);

        if (emptyCells.length === 0) {
            showStatus(`Area "${area.name}" is already full - no empty cells to fill`, 'info');
            return;
        }

        // Show bulk tree creation dialog
        const treeData = await this.showBulkTreeCreationDialog(area, emptyCells);
        
        if (!treeData) {
            console.log('❌ Fill area operation cancelled by user');
            return;
        }

        showStatus(`Creating ${emptyCells.length} trees in area "${area.name}"...`, 'info');

        // Create trees for each empty cell using the provided data
        let createdCount = 0;
        let failedCount = 0;

        for (const cell of emptyCells) {
            try {
                console.log(`🌱 Creating tree at position (${cell.row}, ${cell.col})`);
                
                // Create tree with the specified data
                const response = await fetch(`/api/dome/${domeId}/trees`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: `${treeData.name}-${cell.row}-${cell.col}`,
                        breed: treeData.breed || '',
                        internal_row: cell.row,
                        internal_col: cell.col,
                        plant_type: treeData.plant_type || 'mother',
                        mother_plant_id: treeData.mother_plant_id || null,
                        cutting_notes: treeData.cutting_notes || '',
                        info: treeData.info || ''
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log(`✅ Created tree at (${cell.row}, ${cell.col}) with ID: ${result.tree_id}`);
                    createdCount++;
                    
                    // Store the first created tree ID if it's a mother tree for relationship transfer
                    if (treeData.plant_type === 'mother' && !newMotherTreeId) {
                        newMotherTreeId = result.tree_id;
                        console.log(`🌳 New mother tree created with ID: ${newMotherTreeId}`);
                    }
                } else {
                    console.error(`❌ Failed to create tree at (${cell.row}, ${cell.col})`);
                    failedCount++;
                }
            } catch (error) {
                console.error(`❌ Failed to create tree at (${cell.row}, ${cell.col}):`, error);
                failedCount++;
            }
        }

        // Show results
        // Handle relationship transfer if copying a mother tree with cuttings
        if (treeData.transfer_cuttings && newMotherTreeId && treeData.cutting_trees_to_transfer) {
            console.log(`🔄 Starting relationship transfer for new mother tree ${newMotherTreeId}`);
            await this.transferCuttingRelationships(newMotherTreeId, treeData.cutting_trees_to_transfer, treeData.copied_tree_data);
        }

        if (createdCount > 0) {
            let successMessage = `✅ Successfully created ${createdCount} tree(s) in area "${area.name}"`;
            
            // Add relationship transfer info to success message
            if (treeData.transfer_cuttings && treeData.cutting_trees_to_transfer) {
                successMessage += ` and transferred ${treeData.cutting_trees_to_transfer.length} cutting relationship(s)`;
            }
            
            showStatus(successMessage, 'success');
            
            // Refresh the page to show new trees
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }

        if (failedCount > 0) {
            showStatus(`⚠️ Failed to create ${failedCount} tree(s)`, 'warning');
        }

    } catch (error) {
        console.error('❌ Error filling area with trees:', error);
        showStatus('Error filling area: ' + error.message, 'error');
    }
}

// ✅ NEW: Get copied tree section for bulk creation dialog
getCopiedTreeSection() {
    // Check for copied tree data
    const copiedTree = window.copiedTreeData || this.loadCopiedTreeFromStorage();
    
    if (!copiedTree) {
        return '';
    }
    
    const tree = copiedTree.tree;
    const relationships = copiedTree.relationships;
    
    let relationshipInfo = '';
    if (relationships.is_mother && relationships.total_cuttings > 0) {
        relationshipInfo = `<div style="color: #28a745; font-size: 12px; margin-top: 5px;">
            🌳 Mother tree with ${relationships.total_cuttings} cutting tree(s) - relationships will be transferred
        </div>`;
    } else if (relationships.is_cutting && relationships.mother_tree) {
        relationshipInfo = `<div style="color: #17a2b8; font-size: 12px; margin-top: 5px;">
            ✂️ Cutting from "${relationships.mother_tree.name}" - will be linked to new mother if available
        </div>`;
    }
    
    return `
        <div style="background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #28a745;">📋 Copied Tree Available</h4>
                <button onclick="this.clearCopiedTree()" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                    Clear
                </button>
            </div>
            <div style="background: white; padding: 10px; border-radius: 4px;">
                <div><strong>Tree:</strong> ${tree.name}</div>
                <div><strong>Breed:</strong> ${tree.breed || 'None'}</div>
                <div><strong>Type:</strong> ${tree.plant_type === 'mother' ? '🌳 Mother Plant' : tree.plant_type === 'cutting' ? '✂️ Cutting' : '🌱 Independent'}</div>
                <div><strong>Source:</strong> Dome ${copiedTree.source_dome_id}</div>
                ${relationshipInfo}
            </div>
            <button onclick="this.useCopiedTreeData()" style="width: 100%; margin-top: 10px; padding: 10px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                ���� Use Copied Tree Data
            </button>
        </div>
    `;
}

// ✅ NEW: Load copied tree from storage
loadCopiedTreeFromStorage() {
    try {
        const stored = localStorage.getItem('copiedTreeData');
        if (stored) {
            const data = JSON.parse(stored);
            console.log('📋 Loaded copied tree from storage:', data);
            return data;
        }
    } catch (e) {
        console.warn('⚠️ Could not load copied tree from storage:', e);
    }
    return null;
}

// ✅ NEW: Clear copied tree data
clearCopiedTree() {
    window.copiedTreeData = null;
    try {
        localStorage.removeItem('copiedTreeData');
    } catch (e) {
        console.warn('⚠️ Could not clear copied tree from storage:', e);
    }
    showStatus('Copied tree data cleared', 'info');
    // Refresh the dialog
    const modal = document.querySelector('.bulk-tree-creation-modal');
    if (modal) {
        modal.remove();
        // Re-open the dialog
        setTimeout(() => {
            this.showBulkTreeCreationDialog(this.currentArea, this.currentEmptyCells);
        }, 100);
    }
}

// ✅ NEW: Use copied tree data to fill form
useCopiedTreeData() {
    const copiedTree = window.copiedTreeData || this.loadCopiedTreeFromStorage();
    if (!copiedTree) {
        showStatus('No copied tree data available', 'error');
        return;
    }
    
    const tree = copiedTree.tree;
    const relationships = copiedTree.relationships;
    
    // Fill form with copied tree data
    const nameInput = document.getElementById('bulkTreeName');
    const breedSelect = document.getElementById('bulkTreeBreed');
    const plantTypeSelect = document.getElementById('bulkPlantType');
    const infoTextarea = document.getElementById('bulkTreeInfo');
    
    if (nameInput) nameInput.value = tree.name || '';
    if (breedSelect) breedSelect.value = tree.breed || '';
    if (plantTypeSelect) plantTypeSelect.value = tree.plant_type || 'mother';
    if (infoTextarea) {
        let info = tree.info || '';
        if (relationships.is_mother && relationships.total_cuttings > 0) {
            info += `\n\nCopied from mother tree with ${relationships.total_cuttings} cutting(s). Relationships will be transferred.`;
        } else if (relationships.is_cutting && relationships.mother_tree) {
            info += `\n\nCopied from cutting of "${relationships.mother_tree.name}".`;
        }
        infoTextarea.value = info.trim();
    }
    
    // Trigger change events to update UI
    if (plantTypeSelect) {
        plantTypeSelect.dispatchEvent(new Event('change'));
    }
    
    showStatus(`Form filled with data from "${tree.name}"`, 'success');
    console.log('📋 Form filled with copied tree data:', tree);
}

// ✅ NEW: Transfer cutting relationships from old mother to new mother
async transferCuttingRelationships(newMotherTreeId, cuttingTrees, copiedTreeData) {
    try {
        console.log(`🔄 Transferring ${cuttingTrees.length} cutting relationships to new mother tree ${newMotherTreeId}`);
        
        let transferredCount = 0;
        let failedCount = 0;
        
        for (const cutting of cuttingTrees) {
            try {
                // Update the cutting tree to point to the new mother
                const response = await fetch(`/api/tree/${cutting.original_id}/update_mother`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        new_mother_id: newMotherTreeId,
                        transfer_notes: `Transferred from original mother "${copiedTreeData.tree.name}" to new mother tree.`
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        transferredCount++;
                        console.log(`✅ Transferred cutting "${cutting.name}" to new mother`);
                    } else {
                        console.error(`❌ Failed to transfer cutting "${cutting.name}":`, result.error);
                        failedCount++;
                    }
                } else {
                    console.error(`❌ Failed to transfer cutting "${cutting.name}": HTTP ${response.status}`);
                    failedCount++;
                }
            } catch (error) {
                console.error(`❌ Error transferring cutting "${cutting.name}":`, error);
                failedCount++;
            }
        }
        
        // Show transfer results
        if (transferredCount > 0) {
            showStatus(`🔄 Transferred ${transferredCount} cutting tree(s) to new mother. ${failedCount > 0 ? `${failedCount} failed.` : ''}`, 
                      failedCount > 0 ? 'warning' : 'success');
        }
        
        // Clear copied tree data after successful transfer
        if (transferredCount > 0) {
            window.copiedTreeData = null;
            try {
                localStorage.removeItem('copiedTreeData');
            } catch (e) {
                console.warn('⚠️ Could not clear copied tree data:', e);
            }
        }
        
        console.log(`🔄 Relationship transfer complete: ${transferredCount} transferred, ${failedCount} failed`);
        
    } catch (error) {
        console.error('❌ Error in relationship transfer:', error);
        showStatus('Error transferring cutting relationships', 'error');
    }
}

// ✅ NEW: Show bulk tree creation dialog
showBulkTreeCreationDialog(area, emptyCells) {
    // Store current area and empty cells for refresh
    this.currentArea = area;
    this.currentEmptyCells = emptyCells;
    
    return new Promise((resolve) => {
        // Store the resolve function globally
        window.bulkTreeCreationResolve = resolve;
        
        // Remove any existing modal
        const existingModal = document.querySelector('.bulk-tree-creation-modal');
        if (existingModal) {
            existingModal.remove();
        }

        const modal = document.createElement('div');
        modal.className = 'bulk-tree-creation-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            " onclick="window.bulkTreeCreationCancel();">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    max-height: 80vh;
                    overflow-y: auto;
                " onclick="event.stopPropagation();">
                    <h3 style="margin: 0 0 20px 0; color: #28a745;">🌱 Fill Area with Trees</h3>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div><strong>Area:</strong> ${area.name}</div>
                    <div><strong>Empty Cells:</strong> ${emptyCells.length}</div>
                    <div><strong>Size:</strong> ${area.width}×${area.height}</div>
                    </div>
                    
                    ${this.getCopiedTreeSection()}

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Tree Name Pattern:</label>
                        <input type="text" id="bulkTreeName" placeholder="Tree (will add position suffix)" 
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">Each tree will be named: "TreeName-Row-Col" (e.g., "Apple-3-7")</small>
                    </div>

                    <div id="bulkBreedSection" style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Breed:</label>
                        <div style="position: relative;">
                            <input type="text" id="bulkBreedSearch" placeholder="🔍 Search breeds..." 
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; margin-bottom: 5px;"
                                   autocomplete="off">
                            <select id="bulkTreeBreed" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">Select a breed...</option>
                            </select>
                        </div>
                        <div id="breedInheritanceNote" style="display: none; margin-top: 5px; padding: 8px; background: #e8f5e8; border-radius: 4px; font-size: 12px; color: #2e7d32;">
                            🧬 Breed will be inherited from selected mother plant
                        </div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Plant Type:</label>
                        <select id="bulkPlantType" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="mother">Mother Plant</option>
                            <option value="cutting">Cutting</option>
                        </select>
                    </div>

                    <div id="bulkMotherSection" style="margin-bottom: 15px; display: none;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Mother Plant:</label>
                        <div style="position: relative;">
                            <input type="text" id="bulkMotherPlantSearch" placeholder="🔍 Search mother plants..." 
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;"
                                   autocomplete="off">
                            <select id="bulkMotherPlant" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-top: 5px;">
                                <option value="">Select mother plant...</option>
                            </select>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Additional Info:</label>
                        <textarea id="bulkTreeInfo" placeholder="Optional information about these trees..." 
                                  style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; height: 60px; resize: vertical;"></textarea>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="window.bulkTreeCreationCancel();" 
                                style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="window.bulkTreeCreationSubmit();" 
                                style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Create ${emptyCells.length} Trees
                        </button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Populate breeds dropdown
        this.populateBulkBreedsDropdown();

        // Populate mother plants dropdown
        this.populateBulkMotherPlantsDropdown();

        // Handle plant type change
        document.getElementById('bulkPlantType').addEventListener('change', function() {
            const motherSection = document.getElementById('bulkMotherSection');
            const breedSection = document.getElementById('bulkBreedSection');
            const breedSelect = document.getElementById('bulkTreeBreed');
            const breedNote = document.getElementById('breedInheritanceNote');
            
            if (this.value === 'cutting') {
                motherSection.style.display = 'block';
                // Show breed section but with inheritance note
                if (breedSection) {
                    breedSection.style.display = 'block';
                }
                // Disable breed selection and show inheritance note
                if (breedSelect) {
                    breedSelect.disabled = true;
                    breedSelect.style.opacity = '0.6';
                }
                if (breedNote) {
                    breedNote.style.display = 'block';
                }
            } else {
                motherSection.style.display = 'none';
                // Show breed selection for mother plants
                if (breedSection) {
                    breedSection.style.display = 'block';
                }
                // Enable breed selection and hide inheritance note
                if (breedSelect) {
                    breedSelect.disabled = false;
                    breedSelect.style.opacity = '1';
                }
                if (breedNote) {
                    breedNote.style.display = 'none';
                }
            }
        });

        // Handle mother plant selection change for cutting trees
        document.getElementById('bulkMotherPlant').addEventListener('change', function() {
            const selectedMotherId = this.value;
            const breedSelect = document.getElementById('bulkTreeBreed');
            const plantType = document.getElementById('bulkPlantType').value;
            
            if (plantType === 'cutting' && selectedMotherId && breedSelect) {
                // Find the selected mother plant and get its breed
                const motherOption = this.options[this.selectedIndex];
                if (motherOption && motherOption.dataset.breed) {
                    // Set the breed from mother plant
                    breedSelect.value = motherOption.dataset.breed;
                    console.log(`🧬 Inherited breed "${motherOption.dataset.breed}" from mother plant`);
                }
            }
        });

        // Handle mother plant search functionality
        document.getElementById('bulkMotherPlantSearch').addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            const motherSelect = document.getElementById('bulkMotherPlant');
            const options = motherSelect.querySelectorAll('option');
            
            options.forEach(option => {
                if (option.value === '') {
                    // Always show the default "Select mother plant..." option
                    option.style.display = 'block';
                    return;
                }
                
                const optionText = option.textContent.toLowerCase();
                if (optionText.includes(searchTerm)) {
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
            
            // Auto-select if only one option matches
            const visibleOptions = Array.from(options).filter(opt => 
                opt.value !== '' && opt.style.display !== 'none'
            );
            
            if (visibleOptions.length === 1) {
                motherSelect.value = visibleOptions[0].value;
                // Trigger the change event to inherit breed
                motherSelect.dispatchEvent(new Event('change'));
            }
        });

        // Handle mother plant search focus - show all options when focused
        document.getElementById('bulkMotherPlantSearch').addEventListener('focus', function() {
            const motherSelect = document.getElementById('bulkMotherPlant');
            const options = motherSelect.querySelectorAll('option');
            
            options.forEach(option => {
                option.style.display = 'block';
            });
        });

        // Handle breed search functionality
        document.getElementById('bulkBreedSearch').addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            const breedSelect = document.getElementById('bulkTreeBreed');
            const options = breedSelect.querySelectorAll('option');
            
            options.forEach(option => {
                if (option.value === '') {
                    // Always show the default "Select a breed..." option
                    option.style.display = 'block';
                    return;
                }
                
                const optionText = option.textContent.toLowerCase();
                if (optionText.includes(searchTerm)) {
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
            
            // Auto-select if only one option matches
            const visibleOptions = Array.from(options).filter(opt => 
                opt.value !== '' && opt.style.display !== 'none'
            );
            
            if (visibleOptions.length === 1) {
                breedSelect.value = visibleOptions[0].value;
                console.log(`🧬 Auto-selected breed: "${visibleOptions[0].value}"`);
            }
        });

        // Handle breed search focus - show all options when focused
        document.getElementById('bulkBreedSearch').addEventListener('focus', function() {
            const breedSelect = document.getElementById('bulkTreeBreed');
            const options = breedSelect.querySelectorAll('option');
            
            options.forEach(option => {
                option.style.display = 'block';
            });
        });
    });
}

// ✅ NEW: Populate breeds dropdown for bulk creation
populateBulkBreedsDropdown() {
    const breedSelect = document.getElementById('bulkTreeBreed');
    if (!breedSelect) return;

    // Use existing breeds from the global breeds array or fetch them
    if (typeof window.breeds !== 'undefined' && window.breeds.length > 0) {
        window.breeds.forEach(breed => {
            const option = document.createElement('option');
            option.value = breed.name || breed;
            option.textContent = breed.name || breed;
            breedSelect.appendChild(option);
        });
    } else {
        // Fallback: add some common breeds
        const commonBreeds = ['Apple', 'Orange', 'Mango', 'Banana', 'Cherry'];
        commonBreeds.forEach(breed => {
            const option = document.createElement('option');
            option.value = breed;
            option.textContent = breed;
            breedSelect.appendChild(option);
        });
    }
}

// ✅ NEW: Populate mother plants dropdown for bulk creation
populateBulkMotherPlantsDropdown() {
    const motherSelect = document.getElementById('bulkMotherPlant');
    if (!motherSelect) return;

    // Get all mother plants from the current dome
    const motherPlants = trees.filter(tree => tree.plant_type === 'mother');
    
    motherPlants.forEach(mother => {
        const option = document.createElement('option');
        option.value = mother.id;
        option.setAttribute('data-breed', mother.breed || '');
        option.textContent = `${mother.name} (${mother.breed || 'No breed'}) - (${mother.internal_row},${mother.internal_col})`;
        motherSelect.appendChild(option);
    });

    if (motherPlants.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No mother plants available';
        option.disabled = true;
        motherSelect.appendChild(option);
    }
}

showCopyOptionsDialog(area, treesInArea, relationshipAnalysis) {
    return new Promise((resolve) => {
        // Remove any existing modal
        const existingModal = document.querySelector('.copy-options-modal');
        if (existingModal) {
            existingModal.remove();
        }
        
        const hasRelationships = relationshipAnalysis.hasRelatedTrees;
        const cuttingCount = relationshipAnalysis.cuttingTrees.length;
        const motherCount = relationshipAnalysis.motherTrees.length;
        const missingMothers = relationshipAnalysis.missingMothers.length;
        const missingCuttings = relationshipAnalysis.missingCuttings.length;
        
        const modal = document.createElement('div');
        modal.className = 'copy-options-modal';
        modal.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
            " onclick="this.remove(); resolve(null);">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 25px;
                    max-width: 550px;
                    width: 90%;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                " onclick="event.stopPropagation();">
                    <h4 style="margin: 0 0 20px 0; color: #007bff; display: flex; align-items: center; gap: 10px;">
                        📋 Copy Options
                    </h4>
                    
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #2196f3;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px;">
                            <div><strong>Area:</strong> ${area.name}</div>
                            <div><strong>Size:</strong> ${area.width}×${area.height}</div>
                            <div><strong>Trees in Area:</strong> ${treesInArea.length}</div>
                            <div><strong>Relationships:</strong> ${motherCount} mothers, ${cuttingCount} cuttings</div>
                        </div>
                        ${hasRelationships ? `
                        <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border-left: 3px solid #ffc107;">
                            <small style="color: #856404;">
                                ⚠️ <strong>Relationship Warning:</strong><br>
                                ${missingMothers > 0 ? `• ${missingMothers} mother tree(s) are outside this area<br>` : ''}
                                ${missingCuttings > 0 ? `• ${missingCuttings} cutting tree(s) are outside this area<br>` : ''}
                                Some relationships will be broken if you copy selected trees only.
                            </small>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div style="display: grid; gap: 15px; margin-bottom: 25px;">
                        <button class="copy-option" data-mode="selected_only" style="
                            padding: 15px 20px;
                            background: #28a745;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🎯</span>
                            <div>
                                <div style="margin-bottom: 4px;">Copy Selected Trees Only</div>
                                <small style="opacity: 0.8; font-weight: normal;">Copy only the ${treesInArea.length} tree(s) in this area${hasRelationships ? ' (some relationships may be broken)' : ''}</small>
                            </div>
                        </button>
                        
                        ${hasRelationships ? `
                        <button class="copy-option" data-mode="with_relationships" style="
                            padding: 15px 20px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🔗</span>
                            <div>
                                <div style="margin-bottom: 4px;">Copy With Relationships</div>
                                <small style="opacity: 0.8; font-weight: normal;">Copy ${treesInArea.length} selected + ${missingMothers + missingCuttings} related trees to preserve relationships</small>
                            </div>
                        </button>
                        ` : ''}
                        
                        <button class="copy-option" data-mode="area_only" style="
                            padding: 15px 20px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            transition: all 0.2s ease;
                            text-align: left;
                        ">
                            <span style="font-size: 20px;">🔲</span>
                            <div>
                                <div style="margin-bottom: 4px;">Copy Area Boundary Only</div>
                                <small style="opacity: 0.8; font-weight: normal;">Copy just the area outline, no trees</small>
                            </div>
                        </button>
                    </div>
                    
                    <div style="padding-top: 15px; border-top: 1px solid #eee;">
                        <button onclick="this.closest('.copy-options-modal').remove(); resolve(null);" style="
                            width: 100%;
                            padding: 12px;
                            background: #dc3545;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                        ">Cancel</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Add click handlers for copy options
        const optionButtons = modal.querySelectorAll('.copy-option');
        optionButtons.forEach(button => {
            button.addEventListener('click', () => {
                const mode = button.dataset.mode;
                modal.remove();
                resolve({ mode: mode });
            });
            
            // Add hover effects
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'translateY(-2px)';
                button.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'translateY(0)';
                button.style.boxShadow = 'none';
            });
        });
        
        // Keyboard navigation
        modal.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                resolve(null);
            }
        });
        
        // Make resolve available globally for the cancel button
        window.resolve = resolve;
    });
}
analyzeTreeRelationships(treesInArea) {
    console.log('🔍 Analyzing tree relationships (without auto-inclusion)...');
    
    const motherTrees = treesInArea.filter(t => t.plant_type === 'mother');
    const cuttingTrees = treesInArea.filter(t => t.plant_type === 'cutting');
    const otherTrees = treesInArea.filter(t => !t.plant_type || (t.plant_type !== 'mother' && t.plant_type !== 'cutting'));
    
    const selectedMotherIds = new Set(motherTrees.map(m => m.id));
    const missingMotherIds = new Set();
    const missingCuttingIds = new Set();
    
    // Find cutting trees whose mothers are not selected
    cuttingTrees.forEach(cutting => {
        if (cutting.mother_plant_id && !selectedMotherIds.has(cutting.mother_plant_id)) {
            missingMotherIds.add(cutting.mother_plant_id);
        }
    });
    
    // Find mother trees whose cuttings are not selected
    motherTrees.forEach(mother => {
        const allCuttings = trees.filter(t => t.plant_type === 'cutting' && t.mother_plant_id === mother.id);
        const selectedCuttings = allCuttings.filter(c => treesInArea.some(selected => selected.id === c.id));
        const missedCuttings = allCuttings.filter(c => !treesInArea.some(selected => selected.id === c.id));
        
        missedCuttings.forEach(cutting => {
            missingCuttingIds.add(cutting.id);
        });
    });
    
    // Find the actual missing trees
    const missingMothers = trees.filter(t => missingMotherIds.has(t.id));
    const missingCuttings = trees.filter(t => missingCuttingIds.has(t.id));
    
    const analysis = {
        hasRelatedTrees: missingMothers.length > 0 || missingCuttings.length > 0,
        selectedTrees: treesInArea.length,
        motherTrees: motherTrees,
        cuttingTrees: cuttingTrees,
        otherTrees: otherTrees,
        missingMothers: missingMothers,
        missingCuttings: missingCuttings,
        missingMotherIds: Array.from(missingMotherIds),
        missingCuttingIds: Array.from(missingCuttingIds),
        completeRelationships: cuttingTrees.filter(c => c.mother_plant_id && selectedMotherIds.has(c.mother_plant_id)).length,
        brokenRelationships: cuttingTrees.filter(c => c.mother_plant_id && !selectedMotherIds.has(c.mother_plant_id)).length
    };
    
    console.log('🔍 Relationship analysis complete:', {
        selectedTrees: analysis.selectedTrees,
        mothers: analysis.motherTrees.length,
        cuttings: analysis.cuttingTrees.length,
        missingMothers: analysis.missingMothers.length,
        missingCuttings: analysis.missingCuttings.length,
        hasRelatedTrees: analysis.hasRelatedTrees
    });
    
    return analysis;
}

createClipboardFromSelectedTrees(area, selectedTrees) {
    console.log('📋 Creating clipboard from selected trees only...');
    
    // Analyze relationships in selected trees only
    const motherTrees = selectedTrees.filter(t => t.plant_type === 'mother');
    const cuttingTrees = selectedTrees.filter(t => t.plant_type === 'cutting');
    const otherTrees = selectedTrees.filter(t => !t.plant_type || (t.plant_type !== 'mother' && t.plant_type !== 'cutting'));
    
    console.log(`🔍 Selected trees analysis: ${motherTrees.length} mothers, ${cuttingTrees.length} cuttings, ${otherTrees.length} others`);
    
    // Check for broken relationships (cuttings without their mothers)
    const brokenRelationships = cuttingTrees.filter(cutting => {
        if (!cutting.mother_plant_id) return false;
        return !motherTrees.some(mother => mother.id === cutting.mother_plant_id);
    });
    
    const completeRelationships = cuttingTrees.filter(cutting => {
        if (!cutting.mother_plant_id) return false;
        return motherTrees.some(mother => mother.id === cutting.mother_plant_id);
    });
    
    console.log(`🔗 Relationship status: ${completeRelationships.length} complete, ${brokenRelationships.length} broken`);
    
    if (brokenRelationships.length > 0) {
        console.log('⚠️ Warning: Some cutting trees will lose their mother relationship:');
        brokenRelationships.forEach(cutting => {
            console.log(`  - "${cutting.name}" (mother ID: ${cutting.mother_plant_id} not selected)`);
        });
    }
    
    // Create enhanced tree data
    const enhancedTreesData = selectedTrees.map(tree => {
        const relativeRow = tree.internal_row - area.minRow;
        const relativeCol = tree.internal_col - area.minCol;
        
        return {
            // Basic info
            id: tree.id,
            name: tree.name,
            breed: tree.breed || '',
            life_days: tree.life_days || 0,
            info: tree.info || '',
            image_url: tree.image_url || '',
            
            // Position data
            internal_row: tree.internal_row,
            internal_col: tree.internal_col,
            relativeRow: relativeRow,
            relativeCol: relativeCol,
            relative_row: relativeRow,
            relative_col: relativeCol,
            row: tree.internal_row,
            col: tree.internal_col,
            
            // ✅ CRITICAL: Plant relationship data
            plant_type: tree.plant_type || 'mother',
            mother_plant_id: tree.mother_plant_id || null,
            mother_tree_id: tree.mother_plant_id || null,
            cutting_notes: tree.cutting_notes || '',
            
            // ✅ ENHANCED: Relationship metadata
            relationship_metadata: {
                original_tree_id: tree.id,
                original_mother_id: tree.mother_plant_id,
                is_in_original_area: true,
                relationship_will_be_preserved: tree.plant_type === 'cutting' && tree.mother_plant_id ? 
                    motherTrees.some(m => m.id === tree.mother_plant_id) : true,
                relationship_will_be_broken: tree.plant_type === 'cutting' && tree.mother_plant_id ? 
                    !motherTrees.some(m => m.id === tree.mother_plant_id) : false
            },
            
            // Metadata
            user_id: tree.user_id,
            dome_id: tree.dome_id
        };
    });
    
    // Calculate comprehensive statistics
    const breeds = [...new Set(selectedTrees.map(t => t.breed).filter(b => b && b.trim()))];
    const treesWithImages = selectedTrees.filter(t => t.image_url && t.image_url.trim());
    
    // Create clipboard data
    const clipboardData = {
        // Basic area info
        id: area.id,
        name: area.name,
        color: area.color || '#007bff',
        type: 'dragArea',
        
        // Dimensions
        width: area.width || (area.maxCol - area.minCol + 1),
        height: area.height || (area.maxRow - area.minRow + 1),
        
        // Position info
        minRow: area.minRow,
        maxRow: area.maxRow,
        minCol: area.minCol,
        maxCol: area.maxCol,
        min_row: area.minRow,
        max_row: area.maxRow,
        min_col: area.minCol,
        max_col: area.maxCol,
        
        // ✅ CRITICAL: Trees data (only selected trees)
        trees: enhancedTreesData,
        trees_data: enhancedTreesData,
        selectedTrees: enhancedTreesData,
        tree_count: enhancedTreesData.length,
        tree_ids: enhancedTreesData.map(t => t.id),
        
        // ✅ ENHANCED: Summary with relationship warnings
        summary: {
            total_trees: enhancedTreesData.length,
            trees_in_original_area: enhancedTreesData.length,
            related_trees_outside_area: 0, // None, since we're not including them
            breeds: breeds,
            breed_count: breeds.length,
            has_images: treesWithImages.length,
            trees_with_images: treesWithImages.length,
            
            plant_relationships: {
                mother_trees: motherTrees.length,
                cutting_trees: cuttingTrees.length,
                complete_relationships: completeRelationships.length,
                broken_relationships: brokenRelationships.length,
                mothers_outside_area: 0,
                relationship_preservation_rate: cuttingTrees.length > 0 ? 
                    Math.round((completeRelationships.length / cuttingTrees.length) * 100) : 100,
                
                // ✅ WARNING: Information about broken relationships
                will_lose_relationships: brokenRelationships.length > 0,
                broken_relationship_details: brokenRelationships.map(cutting => ({
                    cutting_name: cutting.name,
                    cutting_id: cutting.id,
                    missing_mother_id: cutting.mother_plant_id
                }))
            }
        },
        
        // ✅ ENHANCED: Relationship mapping (only for selected trees)
        relationship_mapping: this.createRelationshipMappingForSelectedTrees(enhancedTreesData),
        
        // Metadata
        clipboard_version: '2.3',
        includes_relationships: completeRelationships.length > 0,
        clipboard_source: 'frontend_selected_only',
        copied_at: new Date().toISOString(),
        source_dome_id: domeId,
        selection_mode: 'selected_trees_only'
    };
    
    console.log('✅ Clipboard created with selected trees only:', {
    totalTrees: clipboardData.tree_count,
    mothers: clipboardData.summary.plant_relationships.mother_trees,
    cuttings: clipboardData.summary.plant_relationships.cutting_trees,
    completeRelationships: clipboardData.summary.plant_relationships.complete_relationships,
    brokenRelationships: clipboardData.summary.plant_relationships.broken_relationships
    });
    
    return clipboardData;
}

// ✅ NEW: Create empty area clipboard (just boundary)
createEmptyAreaClipboard(area) {
    return {
        // Basic area info
        id: area.id,
        name: area.name,
        color: area.color || '#007bff',
        type: 'dragArea',
        
        // Dimensions
        width: area.width || (area.maxCol - area.minCol + 1),
        height: area.height || (area.maxRow - area.minRow + 1),
        
        // Position info
        minRow: area.minRow,
        maxRow: area.maxRow,
        minCol: area.minCol,
        maxCol: area.maxCol,
        min_row: area.minRow,
        max_row: area.maxRow,
        min_col: area.minCol,
        max_col: area.maxCol,
        
        // ✅ CRITICAL: No trees
        trees: [],
        trees_data: [],
        selectedTrees: [],
        tree_count: 0,
        tree_ids: [],
        
        // Summary
        summary: {
            total_trees: 0,
            trees_in_original_area: 0,
            related_trees_outside_area: 0,
            breeds: [],
            breed_count: 0,
            has_images: 0,
            trees_with_images: 0,
            
            plant_relationships: {
                mother_trees: 0,
                cutting_trees: 0,
                complete_relationships: 0,
                broken_relationships: 0,
                mothers_outside_area: 0,
                relationship_preservation_rate: 100
            }
        },
        
        // Metadata
        clipboard_version: '2.3',
        includes_relationships: false,
        clipboard_source: 'frontend_area_only',
        copied_at: new Date().toISOString(),
        source_dome_id: domeId,
        selection_mode: 'area_boundary_only'
    };
}

// ✅ NEW: Store clipboard data consistently
storeClipboardData(clipboardData, source) {
    // Store in multiple locations for compatibility
    window.dragClipboard = clipboardData;
    window.clipboardArea = clipboardData;
    
    // Store in localStorage for persistence
    try {
        localStorage.setItem('dragClipboard', JSON.stringify({
            data: clipboardData,
            timestamp: Date.now(),
            domeId: domeId,
            source: source
        }));
    } catch (storageError) {
        console.warn('⚠️ Could not store in localStorage:', storageError);
    }
    
    // Broadcast to other tabs
    try {
        if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('dragClipboard');
            channel.postMessage({
                type: 'clipboard_updated',
                data: clipboardData,
                source: source,
                timestamp: Date.now()
            });
            channel.close();
        }
    } catch (broadcastError) {
        console.warn('⚠️ Could not broadcast clipboard update:', broadcastError);
    }
    
    console.log('✅ Clipboard data stored:', {
        source: source,
        tree_count: clipboardData.tree_count,
        includes_relationships: clipboardData.includes_relationships
    });
}
    analyzeAndIncludeRelatedTrees(treesInArea, area) {
        console.log('🔗 Analyzing plant relationships...');
        
        const relatedTreeIds = new Set();
        const motherTreesInArea = new Set();
        const cuttingTreesInArea = new Set();
        const orphanedCuttings = [];
        const mothersOutsideArea = new Set();
        
        // Step 1: Identify tree types in area
        treesInArea.forEach(tree => {
        relatedTreeIds.add(tree.id);
        
        console.log(`🔍 Processing tree "${tree.name}" (ID: ${tree.id}):`, {
        plant_type: tree.plant_type,
        mother_plant_id: tree.mother_plant_id,
        cutting_notes: tree.cutting_notes
        });
        
        if (tree.plant_type === 'mother') {
        motherTreesInArea.add(tree.id);
        console.log(`🌳 Mother tree in area: "${tree.name}" (ID: ${tree.id})`);
        } else if (tree.plant_type === 'cutting') {
        cuttingTreesInArea.add(tree.id);
        console.log(`✂️ Cutting tree in area: "${tree.name}" (ID: ${tree.id}) - Mother: ${tree.mother_plant_id || 'none'}`);
        
        // Check if mother is outside area
        if (tree.mother_plant_id && !motherTreesInArea.has(tree.mother_plant_id)) {
        mothersOutsideArea.add(tree.mother_plant_id);
        orphanedCuttings.push(tree);
        }
        }
        });
        
        // ✅ FIXED: DO NOT automatically include related trees
        // Only preserve relationship data, don't copy the actual trees
        console.log(`🔗 Found ${mothersOutsideArea.size} mothers outside area - preserving relationship data only`);
        console.log(`🔗 Found ${orphanedCuttings.length} orphaned cuttings - will preserve mother references`);
        
        // Step 2: DO NOT include mothers of cuttings (preserve data only)
        // Step 3: DO NOT include all cuttings of mothers (preserve data only)
        // The relationship data will be preserved in the tree metadata
        
        // Step 4: ONLY use trees that are actually in the selected area
        const allRelatedTrees = treesInArea; // Only use trees in the area, not related trees outside
        
        // Step 5: Create enhanced tree data with relationship metadata
        const enhancedTreesData = allRelatedTrees.map(tree => {
            const relativeRow = tree.internal_row - area.minRow;
            const relativeCol = tree.internal_col - area.minCol;
            const isInOriginalArea = treesInArea.some(t => t.id === tree.id);
            
            return {
                // Basic info
                id: tree.id,
                name: tree.name,
                breed: tree.breed || '',
                life_days: tree.life_days || 0,
                info: tree.info || '',
                image_url: tree.image_url || '',
                
                // Position data
                internal_row: tree.internal_row,
                internal_col: tree.internal_col,
                relativeRow: relativeRow,
                relativeCol: relativeCol,
                relative_row: relativeRow,
                relative_col: relativeCol,
                row: tree.internal_row,
                col: tree.internal_col,
                
                // ✅ CRITICAL: Plant relationship data
                plant_type: tree.plant_type || 'mother',
                mother_plant_id: tree.mother_plant_id || null,
                mother_tree_id: tree.mother_plant_id || null,
                cutting_notes: tree.cutting_notes || '',
                
                // ✅ ENHANCED: Relationship metadata for paste operation
                relationship_metadata: {
                    original_mother_id: tree.mother_plant_id,
                    is_in_original_area: isInOriginalArea,
                    relationship_preserved: tree.mother_plant_id ? relatedTreeIds.has(tree.mother_plant_id) : true,
                    will_need_new_mother_id: tree.plant_type === 'cutting' && tree.mother_plant_id ? true : false
                },
                
                // Metadata
                isInOriginalArea: isInOriginalArea,
                user_id: tree.user_id,
                dome_id: tree.dome_id
            };
        });
        
        // Step 6: Calculate relationship statistics
        const relationshipStats = {
        total_trees: enhancedTreesData.length,
        trees_in_area: treesInArea.length,
        related_outside_area: 0, // No longer including related trees outside area
        mother_trees: enhancedTreesData.filter(t => t.plant_type === 'mother').length,
        cutting_trees: enhancedTreesData.filter(t => t.plant_type === 'cutting').length,
        complete_relationships: enhancedTreesData.filter(t =>
        t.plant_type === 'cutting' && t.relationship_metadata.relationship_preserved
        ).length,
        broken_relationships: enhancedTreesData.filter(t =>
        t.plant_type === 'cutting' && !t.relationship_metadata.relationship_preserved
        ).length,
        mothers_outside_area: mothersOutsideArea.size,
        orphaned_cuttings: orphanedCuttings.length
        };
        
        console.log('🔗 Relationship analysis complete:', relationshipStats);
        
        return { enhancedTreesData, relationshipStats };
    }
    createFrontendClipboardWithRelationships(area, enhancedTreesData, relationshipStats) {
        try {
            console.log(`🔄 Creating enhanced clipboard with relationships for area "${area.name}"`);
            
            // ✅ ENHANCED: Calculate comprehensive statistics
            const breeds = [...new Set(enhancedTreesData.map(t => t.breed).filter(b => b && b.trim()))];
            const motherTrees = enhancedTreesData.filter(t => t.plant_type === 'mother');
            const cuttingTrees = enhancedTreesData.filter(t => t.plant_type === 'cutting');
            const treesWithImages = enhancedTreesData.filter(t => t.image_url && t.image_url.trim());
            
            // ✅ CRITICAL: Calculate relationship completeness
            const motherIds = new Set(motherTrees.map(t => t.id));
            const completeRelationships = cuttingTrees.filter(c => 
                c.mother_plant_id && motherIds.has(c.mother_plant_id)
            ).length;
            const brokenRelationships = cuttingTrees.filter(c => 
                c.mother_plant_id && !motherIds.has(c.mother_plant_id)
            ).length;
            
            // ✅ COMPREHENSIVE: Create clipboard data with relationships
            const clipboardData = {
                // Basic area info
                id: area.id,
                name: area.name,
                color: area.color || '#007bff',
                type: 'dragArea',
                
                // Dimensions
                width: area.width || (area.maxCol - area.minCol + 1),
                height: area.height || (area.maxRow - area.minRow + 1),
                
                // Position info
                minRow: area.minRow,
                maxRow: area.maxRow,
                minCol: area.minCol,
                maxCol: area.maxCol,
                min_row: area.minRow,
                max_row: area.maxRow,
                min_col: area.minCol,
                max_col: area.maxCol,
                
                // ✅ CRITICAL: Trees data with relationships
                trees: enhancedTreesData,
                trees_data: enhancedTreesData,
                selectedTrees: enhancedTreesData,
                tree_count: enhancedTreesData.length,
                tree_ids: enhancedTreesData.map(t => t.id),
                
                // ✅ ENHANCED: Comprehensive summary with relationships
                summary: {
                    total_trees: enhancedTreesData.length,
                    trees_in_original_area: relationshipStats.trees_in_area,
                    related_trees_outside_area: relationshipStats.related_outside_area,
                    breeds: breeds,
                    breed_count: breeds.length,
                    has_images: treesWithImages.length,
                    trees_with_images: treesWithImages.length,
                    
                    plant_relationships: {
                        mother_trees: motherTrees.length,
                        cutting_trees: cuttingTrees.length,
                        complete_relationships: completeRelationships,
                        broken_relationships: brokenRelationships,
                        mothers_outside_area: relationshipStats.mothers_outside_area,
                        relationship_preservation_rate: cuttingTrees.length > 0 ? 
                            Math.round((completeRelationships / cuttingTrees.length) * 100) : 100
                    }
                },
                
                // ✅ ENHANCED: Relationship mapping for paste operation
                relationship_mapping: this.createRelationshipMapping(enhancedTreesData),
                
                // Metadata
                clipboard_version: '2.2',
                includes_relationships: true,
                clipboard_source: 'frontend_enhanced',
                copied_at: new Date().toISOString(),
                source_dome_id: domeId
            };
            
            console.log('✅ Enhanced clipboard created with relationships:', {
            totalTrees: clipboardData.tree_count,
            mothers: clipboardData.summary.plant_relationships.mother_trees,
            cuttings: clipboardData.summary.plant_relationships.cutting_trees,
            completeRelationships: clipboardData.summary.plant_relationships.complete_relationships,
            preservationRate: clipboardData.summary.plant_relationships.relationship_preservation_rate + '%'
            });
            
            return clipboardData;
            
        } catch (error) {
            console.error('❌ Error creating enhanced clipboard:', error);
            return null;
        }
    }
    createRelationshipMapping(enhancedTreesData) {
        const motherTrees = enhancedTreesData.filter(t => t.plant_type === 'mother');
        const cuttingTrees = enhancedTreesData.filter(t => t.plant_type === 'cutting');
        
        return {
            mother_tree_ids: motherTrees.map(t => t.id),
            cutting_tree_ids: cuttingTrees.map(t => t.id),
            mother_cutting_pairs: cuttingTrees.map(cutting => ({
                cutting_id: cutting.id,
                cutting_name: cutting.name,
                original_mother_id: cutting.mother_plant_id,
                mother_name: motherTrees.find(m => m.id === cutting.mother_plant_id)?.name || 'Unknown',
                relationship_preserved: cutting.relationship_metadata?.relationship_preserved || false
            })).filter(pair => pair.original_mother_id),
            
            // ✅ ENHANCED: ID mapping instructions for paste
            paste_instructions: {
                preserve_relationships: true,
                create_id_mapping: true,
                update_mother_ids_after_creation: true
            }
        };
    }
// ✅ ADD: Missing method for creating relationship mapping for selected trees
createRelationshipMappingForSelectedTrees(selectedTreesData) {
    console.log('🔗 Creating relationship mapping for selected trees...');
    
    const motherTrees = selectedTreesData.filter(t => t.plant_type === 'mother');
    const cuttingTrees = selectedTreesData.filter(t => t.plant_type === 'cutting');
    
    console.log(`🔍 Mapping relationships: ${motherTrees.length} mothers, ${cuttingTrees.length} cuttings`);
    
    return {
        mother_tree_ids: motherTrees.map(t => t.id),
        cutting_tree_ids: cuttingTrees.map(t => t.id),
        mother_cutting_pairs: cuttingTrees.map(cutting => {
            const motherInSelection = motherTrees.find(m => m.id === cutting.mother_plant_id);
            return {
                cutting_id: cutting.id,
                cutting_name: cutting.name,
                cutting_original_id: cutting.id, // ✅ CRITICAL: Add original ID for paste mapping
                original_mother_id: cutting.mother_plant_id,
                mother_original_id: cutting.mother_plant_id, // ✅ CRITICAL: Add original mother ID
                mother_name: motherInSelection ? motherInSelection.name : 'Not Selected',
                relationship_preserved: !!motherInSelection,
                cutting_notes: cutting.cutting_notes || '',
                cutting_position: {
                    row: cutting.internal_row,
                    col: cutting.internal_col
                },
                mother_position: motherInSelection ? {
                    row: motherInSelection.internal_row,
                    col: motherInSelection.internal_col
                } : null
            };
        }).filter(pair => pair.original_mother_id),
        
        // ✅ ENHANCED: Instructions for paste operation
        paste_instructions: {
            preserve_relationships: true,
            create_id_mapping: true,
            update_mother_ids_after_creation: true,
            warn_about_broken_relationships: true,
            selection_mode: 'selected_trees_only'
        },
        
        // ✅ ENHANCED: Statistics for the mapping
        mapping_stats: {
            total_trees: selectedTreesData.length,
            mother_trees: motherTrees.length,
            cutting_trees: cuttingTrees.length,
            complete_relationships: cuttingTrees.filter(c => 
                c.mother_plant_id && motherTrees.some(m => m.id === c.mother_plant_id)
            ).length,
            broken_relationships: cuttingTrees.filter(c => 
                c.mother_plant_id && !motherTrees.some(m => m.id === c.mother_plant_id)
            ).length
        }
    };
}

// ✅ ADD: Missing method for creating clipboard with relationships (called in 'with_relationships' mode)
createClipboardWithRelationships(area, enhancedTreesData, relationshipStats) {
    console.log('🔗 Creating clipboard with relationships...');
    
    try {
        // ✅ ENHANCED: Calculate comprehensive statistics
        const breeds = [...new Set(enhancedTreesData.map(t => t.breed).filter(b => b && b.trim()))];
        const motherTrees = enhancedTreesData.filter(t => t.plant_type === 'mother');
        const cuttingTrees = enhancedTreesData.filter(t => t.plant_type === 'cutting');
        const treesWithImages = enhancedTreesData.filter(t => t.image_url && t.image_url.trim());
        
        // ✅ CRITICAL: Calculate relationship completeness
        const motherIds = new Set(motherTrees.map(t => t.id));
        const completeRelationships = cuttingTrees.filter(c => 
            c.mother_plant_id && motherIds.has(c.mother_plant_id)
        ).length;
        const brokenRelationships = cuttingTrees.filter(c => 
            c.mother_plant_id && !motherIds.has(c.mother_plant_id)
        ).length;
        
        // ✅ COMPREHENSIVE: Create clipboard data with relationships
        const clipboardData = {
            // Basic area info
            id: area.id,
            name: area.name,
            color: area.color || '#007bff',
            type: 'dragArea',
            
            // Dimensions
            width: area.width || (area.maxCol - area.minCol + 1),
            height: area.height || (area.maxRow - area.minRow + 1),
            
            // Position info
            minRow: area.minRow,
            maxRow: area.maxRow,
            minCol: area.minCol,
            maxCol: area.maxCol,
            min_row: area.minRow,
            max_row: area.maxRow,
            min_col: area.minCol,
            max_col: area.maxCol,
            
            // ✅ CRITICAL: Trees data with relationships
            trees: enhancedTreesData,
            trees_data: enhancedTreesData,
            selectedTrees: enhancedTreesData,
            tree_count: enhancedTreesData.length,
            tree_ids: enhancedTreesData.map(t => t.id),
            
            // ✅ ENHANCED: Comprehensive summary with relationships
            summary: {
                total_trees: enhancedTreesData.length,
                trees_in_original_area: relationshipStats.trees_in_area,
                related_trees_outside_area: relationshipStats.related_outside_area,
                breeds: breeds,
                breed_count: breeds.length,
                has_images: treesWithImages.length,
                trees_with_images: treesWithImages.length,
                
                plant_relationships: {
                    mother_trees: motherTrees.length,
                    cutting_trees: cuttingTrees.length,
                    complete_relationships: completeRelationships,
                    broken_relationships: brokenRelationships,
                    mothers_outside_area: relationshipStats.mothers_outside_area || 0,
                    relationship_preservation_rate: cuttingTrees.length > 0 ? 
                        Math.round((completeRelationships / cuttingTrees.length) * 100) : 100
                }
            },
            
            // ✅ ENHANCED: Relationship mapping for paste operation
            relationship_mapping: this.createRelationshipMapping(enhancedTreesData),
            
            // Metadata
            clipboard_version: '2.3',
            includes_relationships: true,
            clipboard_source: 'frontend_with_relationships',
            copied_at: new Date().toISOString(),
            source_dome_id: domeId,
            selection_mode: 'with_relationships'
        };
        
        console.log('✅ Clipboard created with relationships:', {
        totalTrees: clipboardData.tree_count,
        mothers: clipboardData.summary.plant_relationships.mother_trees,
        cuttings: clipboardData.summary.plant_relationships.cutting_trees,
        completeRelationships: clipboardData.summary.plant_relationships.complete_relationships,
        preservationRate: clipboardData.summary.plant_relationships.relationship_preservation_rate + '%'
        });
        
        return clipboardData;
        
    } catch (error) {
        console.error('❌ Error creating clipboard with relationships:', error);
        return null;
    }
}
async createTreeDataFromArea(area, treesInArea) {
    console.log('🔧 Creating tree data from area trees...');
    
    return treesInArea.map(tree => {
        const relativeRow = tree.internal_row - area.minRow;
        const relativeCol = tree.internal_col - area.minCol;
        
        const treeData = {
            // Basic info
            id: tree.id,
            name: tree.name,
            breed: tree.breed || '',
            life_days: tree.life_days || 0,
            info: tree.info || '',
            image_url: tree.image_url || '',
            
            // Position data (multiple formats for compatibility)
            internal_row: tree.internal_row,
            internal_col: tree.internal_col,
            relativeRow: relativeRow,
            relativeCol: relativeCol,
            relative_row: relativeRow,
            relative_col: relativeCol,
            row: tree.internal_row,
            col: tree.internal_col,
            
            // ✅ ENHANCED: Plant relationships
            plant_type: tree.plant_type || 'mother',
            mother_plant_id: tree.mother_plant_id || null,
            mother_tree_id: tree.mother_plant_id || null,
            cutting_notes: tree.cutting_notes || '',
            
            // Metadata
            isInOriginalArea: true,
            user_id: tree.user_id,
            dome_id: tree.dome_id
        };
        
        console.log(`🌳 Created tree data for "${tree.name}":`, {
            position: `(${tree.internal_row}, ${tree.internal_col})`,
            relative: `(${relativeRow}, ${relativeCol})`,
            type: tree.plant_type || 'mother',
            breed: tree.breed || 'none'
        });
        
        return treeData;
    });
};
// ✅ NEW: Frontend fallback clipboard creation
async createFrontendClipboard(area, areaId) {
    try {
        console.log('🔄 Creating frontend clipboard for area:', area);
        
        // ✅ ENHANCED: Use relationship analysis if available
        if (Array.isArray(treesInArea) && treesInArea.length > 0) {
            // Check if this is enhanced tree data or basic tree data
            const hasRelationshipData = treesInArea.some(t => t.relationship_metadata);
            
            if (hasRelationshipData) {
                // This is already enhanced tree data, use it directly
                console.log('✅ Using pre-enhanced tree data with relationships');
                return this.createFrontendClipboardWithRelationships(area, treesInArea, {
                    trees_in_area: treesInArea.filter(t => t.isInOriginalArea).length,
                    related_outside_area: treesInArea.filter(t => !t.isInOriginalArea).length,
                    total_trees: treesInArea.length
                });
            } else {
                // This is basic tree data, enhance it
                console.log('✅ Enhancing basic tree data with relationships');
                const { enhancedTreesData, relationshipStats } = this.analyzeAndIncludeRelatedTrees(treesInArea, area);
                return this.createFrontendClipboardWithRelationships(area, enhancedTreesData, relationshipStats);
            }
        }
        
        // ✅ FALLBACK: Original logic for backward compatibility
        const areaTreesData = this.createTreeDataFromArea(area, treesInArea || []);
        
        // Create basic clipboard data
        const clipboardData = {
            // Basic area info
            id: area.id,
            name: area.name,
            color: area.color || '#007bff',
            type: 'dragArea',
            
            // Dimensions
            width: area.width || (area.maxCol - area.minCol + 1),
            height: area.height || (area.maxRow - area.minRow + 1),
            
            // Position info
            minRow: area.minRow,
            maxRow: area.maxRow,
            minCol: area.minCol,
            maxCol: area.maxCol,
            min_row: area.minRow,
            max_row: area.maxRow,
            min_col: area.minCol,
            max_col: area.maxCol,
            
            // Trees data in multiple formats
            trees: areaTreesData,
            trees_data: areaTreesData,
            selectedTrees: areaTreesData,
            tree_count: areaTreesData.length,
            tree_ids: areaTreesData.map(t => t.id),
            
            // Basic summary
            summary: {
                total_trees: areaTreesData.length,
                trees_in_original_area: areaTreesData.length,
                related_trees_outside_area: 0,
                breeds: [...new Set(areaTreesData.map(t => t.breed).filter(b => b && b.trim()))],
                breed_count: [...new Set(areaTreesData.map(t => t.breed).filter(b => b && b.trim()))].length,
                has_images: areaTreesData.filter(t => t.image_url).length
            },
            
            // Metadata
            clipboard_version: '2.0',
            includes_relationships: false,
            clipboard_source: 'frontend_basic'
        };
        
        console.log('✅ Basic frontend clipboard created:', clipboardData);
        return clipboardData;
        
    } catch (error) {
        console.error('❌ Error creating frontend clipboard:', error);
        return null;
    }
};
saveGlobalDragClipboard() {
    try {
        if (dragClipboard) {
            // Save to global storage (not dome-specific)
            localStorage.setItem('globalDragClipboard', JSON.stringify(dragClipboard));
            localStorage.setItem('globalClipboardTimestamp', Date.now().toString());
            console.log('✅ Global drag clipboard saved');
        }
    } catch (error) {
        console.error('❌ Failed to save global drag clipboard:', error);
    }
}

loadGlobalDragClipboard() {
    try {
        const stored = localStorage.getItem('globalDragClipboard');
        const timestamp = localStorage.getItem('globalClipboardTimestamp');
        
        if (stored) {
            dragClipboard = JSON.parse(stored);
            console.log('✅ Global drag clipboard loaded:', dragClipboard);
            return true;
        }
    } catch (error) {
        console.error('❌ Failed to load global drag clipboard:', error);
    }
    return false;
}

// ✅ NEW: Broadcast clipboard updates to other open pages
broadcastClipboardUpdate(type, data) {
    try {
        const message = {
            type: 'clipboard_update',
            clipboard_type: type,
            data: data,
            timestamp: Date.now(),
            source_dome: domeId
        };
        
        // Use localStorage event to communicate between tabs
        localStorage.setItem('clipboardBroadcast', JSON.stringify(message));
        
        // Remove the broadcast message after a short delay
        setTimeout(() => {
            localStorage.removeItem('clipboardBroadcast');
        }, 1000);
        
        console.log('📡 Clipboard update broadcasted:', message);
    } catch (error) {
        console.error('❌ Failed to broadcast clipboard update:', error);
    }
}
// ✅ PERSISTENCE FUNCTIONS
saveDragAreasToStorage() {
    try {
        localStorage.setItem(`dragAreas_dome_${domeId}`, JSON.stringify(dragAreas));
        localStorage.setItem(`dragAreaIdCounter_dome_${domeId}`, dragAreaIdCounter.toString());
        console.log('✅ Drag areas saved to storage');
    } catch (error) {
        console.error('❌ Failed to save drag areas:', error);
    }
}

loadDragAreasFromStorage() {
    try {
        const stored = localStorage.getItem(`dragAreas_dome_${domeId}`);
        const storedCounter = localStorage.getItem(`dragAreaIdCounter_dome_${domeId}`);
        
        if (stored) {
            const storedAreas = JSON.parse(stored);
            let addedCount = 0;
            
            storedAreas.forEach(area => {
                if (addAreaSafely(area, 'localStorage')) {
                    addedCount++;
                }
            });
            
            console.log(`✅ Loaded ${addedCount}/${storedAreas.length} drag areas from storage (${storedAreas.length - addedCount} duplicates skipped)`);
        }
        
        if (storedCounter) {
            dragAreaIdCounter = parseInt(storedCounter);
        }
        
        // Clean up any remaining duplicates
        removeDuplicateAreas();
        
        return dragAreas.length > 0;
    } catch (error) {
        console.error('❌ Failed to load drag areas:', error);
        return false;
    }
}

saveDragClipboardToStorage() {
    try {
        if (dragClipboard) {
            localStorage.setItem(`dragClipboard_dome_${domeId}`, JSON.stringify(dragClipboard));
        }
    } catch (error) {
        console.error('❌ Failed to save drag clipboard:', error);
    }
}

loadDragClipboardFromStorage() {
    try {
        const stored = localStorage.getItem(`dragClipboard_dome_${domeId}`);
        if (stored) {
            dragClipboard = JSON.parse(stored);
            return true;
        }
    } catch (error) {
        console.error('❌ Failed to load drag clipboard:', error);
    }
    return false;
}
editDragAreaColor(areaId) {
    if (typeof event !== 'undefined') {
        event.stopPropagation();
        event.preventDefault();
    }
    
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        showStatus('Drag area not found', 'error');
        return;
    }
    
    console.log(`🎨 Editing color for drag area: "${area.name}"`);
    
    // Show color picker modal
    this.showDragAreaColorModal(area);
}

// ✅ STEP 2: Add the color picker modal method
// Add this method to your DragSelector class

showDragAreaColorModal(area) {
    // Remove any existing modal
    const existingModal = document.querySelector('.drag-area-color-modal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Predefined color options
    const colorOptions = [
        { name: 'Blue', value: '#007bff' },
        { name: 'Green', value: '#28a745' },
        { name: 'Red', value: '#dc3545' },
        { name: 'Orange', value: '#fd7e14' },
        { name: 'Yellow', value: '#ffc107' },
        { name: 'Purple', value: '#6f42c1' },
        { name: 'Pink', value: '#e83e8c' },
        { name: 'Teal', value: '#20c997' },
        { name: 'Cyan', value: '#17a2b8' },
        { name: 'Indigo', value: '#6610f2' },
        { name: 'Dark', value: '#343a40' },
        { name: 'Light Gray', value: '#6c757d' }
    ];
    
    const modal = document.createElement('div');
    modal.className = 'drag-area-color-modal';
    modal.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        " onclick="this.remove();">
            <div style="
                background: white;
                border-radius: 12px;
                padding: 25px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            " onclick="event.stopPropagation();">
                <h4 style="margin: 0 0 20px 0; color: #333; display: flex; align-items: center; gap: 10px;">
                    🎨 Change Area Color
                </h4>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid ${area.color};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; background: ${area.color}; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        <div>
                            <strong>${area.name}</strong><br>
                            <small style="color: #666;">Current color: ${area.color}</small>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #333;">
                        Choose a color:
                    </label>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
                        ${colorOptions.map(color => `
                            <button class="color-option" data-color="${color.value}" style="
                                padding: 12px;
                                background: ${color.value};
                                color: ${color.value === '#f8f9fa' || color.value === '#ffc107' ? '#333' : 'white'};
                                border: ${area.color === color.value ? '3px solid #333' : '2px solid #ddd'};
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 12px;
                                font-weight: bold;
                                transition: all 0.2s ease;
                                text-shadow: ${color.value === '#f8f9fa' || color.value === '#ffc107' ? 'none' : '1px 1px 2px rgba(0,0,0,0.5)'};
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)';" 
                               onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                ${color.name}
                            </button>
                        `).join('')}
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; color: #333;">
                        Or enter custom color:
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="color" id="customColorPicker" value="${area.color}" style="
                            width: 50px;
                            height: 40px;
                            border: 2px solid #ddd;
                            border-radius: 6px;
                            cursor: pointer;
                            background: none;
                        ">
                        <input type="text" id="customColorInput" value="${area.color}" placeholder="#007bff" style="
                            flex: 1;
                            padding: 10px;
                            border: 2px solid #ddd;
                            border-radius: 6px;
                            font-family: monospace;
                            font-size: 14px;
                        ">
                        <button onclick="applyCustomColor()" style="
                            padding: 10px 15px;
                            background: #007bff;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                        ">Apply</button>
                    </div>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Enter hex color (e.g., #ff5733) or use the color picker
                    </small>
                </div>
                
                <div style="display: flex; gap: 10px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button onclick="this.closest('.drag-area-color-modal').remove();" style="
                        flex: 1;
                        padding: 12px;
                        background: #6c757d;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: bold;
                    ">Cancel</button>
                    <button id="saveColorBtn" onclick="saveAreaColor()" style="
                        flex: 1;
                        padding: 12px;
                        background: #28a745;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: bold;
                    ">Save Color</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    setTimeout(() => {
    const motherPlantSelect = document.getElementById('motherPlantSelect');
    if (motherPlantSelect) {
        motherPlantSelect.addEventListener('change', updateMotherPlantInfo);
    }
}, 100);
    let selectedColor = area.color;
    
    // Add click handlers for color options
    const colorButtons = modal.querySelectorAll('.color-option');
    colorButtons.forEach(button => {
        button.addEventListener('click', () => {
            selectedColor = button.dataset.color;
            
            // Update visual selection
            colorButtons.forEach(btn => {
                btn.style.border = btn.dataset.color === selectedColor ? '3px solid #333' : '2px solid #ddd';
            });
            
            // Update custom inputs
            modal.querySelector('#customColorPicker').value = selectedColor;
            modal.querySelector('#customColorInput').value = selectedColor;
        });
    });
    
    // Handle custom color picker
    const colorPicker = modal.querySelector('#customColorPicker');
    const colorInput = modal.querySelector('#customColorInput');
    
    colorPicker.addEventListener('change', (e) => {
        selectedColor = e.target.value;
        colorInput.value = selectedColor;
        updateColorSelection();
    });
    
    colorInput.addEventListener('input', (e) => {
        const value = e.target.value;
        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            selectedColor = value;
            colorPicker.value = selectedColor;
            updateColorSelection();
        }
    });
    
    function updateColorSelection() {
        colorButtons.forEach(btn => {
            btn.style.border = btn.dataset.color === selectedColor ? '3px solid #333' : '2px solid #ddd';
        });
    }
    
    // Apply custom color function
    window.applyCustomColor = function() {
        const customColor = colorInput.value;
        if (/^#[0-9A-Fa-f]{6}$/.test(customColor)) {
            selectedColor = customColor;
            colorPicker.value = selectedColor;
            updateColorSelection();
        } else {
            alert('Please enter a valid hex color (e.g., #ff5733)');
        }
    };
    
    // Save color function
    window.saveAreaColor = function() {
        if (selectedColor && selectedColor !== area.color) {
            dragSelector.updateDragAreaColor(area.id, selectedColor);
        }
        modal.remove();
    };
    
    // Keyboard navigation
    modal.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            modal.remove();
        } else if (e.key === 'Enter') {
            window.saveAreaColor();
        }
    });
}

// ✅ STEP 3: Add the updateDragAreaColor method
// Add this method to your DragSelector class

async updateDragAreaColor(areaId, newColor) {
    try {
        const area = dragAreas.find(a => a.id === areaId);
        if (!area) {
            showStatus('Drag area not found', 'error');
            return false;
        }
        
        const oldColor = area.color;
        console.log(`🎨 Updating drag area "${area.name}" color from ${oldColor} to ${newColor}`);
        
        showStatus('Updating area color...', 'info');
        
        // ✅ CRITICAL: Update database FIRST and ONLY continue if successful
        let databaseUpdateSuccess = false;
        
        try {
            console.log(`🔄 Sending request to: /api/update_drag_area_color/${domeId}/${areaId}`);
            
            const response = await fetch(`/api/update_drag_area_color/${domeId}/${areaId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    color: newColor
                })
            });
            
            console.log(`📡 Response status: ${response.status}, ok: ${response.ok}`);
            
            if (response.ok) {
                const result = await response.json();
                console.log('📡 Response data:', result);
                
                if (result.success) {
                    console.log('✅ Area color updated in database successfully');
                    databaseUpdateSuccess = true;
                } else {
                    console.error('❌ Database returned failure:', result.message || 'Unknown error');
                    showStatus('Failed to update color in database: ' + (result.message || 'Unknown error'), 'error');
                    return false;
                }
            } else {
                const errorText = await response.text();
                console.error('❌ HTTP Error:', response.status, errorText);
                showStatus(`Database update failed (${response.status}): ${errorText}`, 'error');
                return false;
            }
        } catch (dbError) {
            console.error('❌ Database update failed with exception:', dbError);
            showStatus('Error connecting to database: ' + dbError.message, 'error');
            return false;
        }
        
        // ✅ ONLY update locally if database update was successful
        if (databaseUpdateSuccess) {
            console.log('✅ Database update successful, proceeding with local updates...');
            
            // Update local area
            area.color = newColor;
            area.updated_at = new Date().toISOString();
            area.saved_to_db = true; // Mark as saved to database
            
            // Update displays
            try {
                this.renderDragAreas();
                this.updateDragAreasDisplay();
                this.saveDragAreasToStorage();
                
                // Re-render grid to show new color
                renderGrid();
                
                console.log('✅ All displays updated successfully');
            } catch (renderError) {
                console.error('❌ Error updating displays:', renderError);
                // Don't return false here - the database was updated successfully
            }
            
            showStatus(`Drag area "${area.name}" color updated to ${newColor}`, 'success');
            console.log(`✅ Drag area color updated successfully: ${area.name} -> ${newColor}`);
            
            // ✅ Verify the change was saved (optional but helpful for debugging)
            setTimeout(async () => {
                await this.verifyColorUpdate(areaId, newColor);
            }, 1000);
            
            return true;
        } else {
            console.error('❌ Database update failed, local changes NOT applied');
            return false;
        }
        
    } catch (error) {
        console.error('❌ Error updating drag area color:', error);
        showStatus('Error updating area color: ' + error.message, 'error');
        return false;
    }
}

// ✅ Add this verification method to help debug issues
async verifyColorUpdate(areaId, expectedColor) {
    console.log('🔍 Verifying color update was saved to database...');
    
    try {
        const response = await fetch(`/api/get_drag_areas/${domeId}`);
        if (response.ok) {
            const result = await response.json();
            if (result.success && result.drag_areas) {
                const savedArea = result.drag_areas.find(a => a.id === areaId);
                if (savedArea) {
                    console.log('🔍 Database verification:', {
                        areaId: savedArea.id,
                        areaName: savedArea.name,
                        savedColor: savedArea.color,
                        expectedColor: expectedColor,
                        matches: savedArea.color === expectedColor
                    });
                    
                    if (savedArea.color === expectedColor) {
                        console.log('✅ VERIFICATION SUCCESS: Color correctly saved to database');
                    } else {
                        console.error('❌ VERIFICATION FAILED: Database has different color!');
                        console.error(`Expected: ${expectedColor}, Got: ${savedArea.color}`);
                        showStatus('Warning: Color verification failed - please check database', 'warning');
                    }
                } else {
                    console.error('❌ VERIFICATION FAILED: Area not found in database');
                }
            }
        } else {
            console.error('❌ VERIFICATION FAILED: Could not fetch areas from database');
        }
    } catch (error) {
        console.error('❌ VERIFICATION ERROR:', error);
    }
}

// ✅ Add this debugging helper to test your API endpoint
async debugApiEndpoint(areaId, testColor = '#ff0000') {
    console.log('🔧 DEBUG: Testing API endpoint...');
    console.log('🔧 DEBUG: Dome ID:', domeId);
    console.log('🔧 DEBUG: Area ID:', areaId);
    console.log('🔧 DEBUG: Test Color:', testColor);
    
    const apiUrl = `/api/update_drag_area_color/${domeId}/${areaId}`;
    console.log('🔧 DEBUG: Full URL:', window.location.origin + apiUrl);
    
    try {
        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                color: testColor
            })
        });
        
        console.log('🔧 DEBUG: Response status:', response.status);
        console.log('🔧 DEBUG: Response headers:', [...response.headers.entries()]);
        
        const responseText = await response.text();
        console.log('🔧 DEBUG: Raw response:', responseText);
        
        try {
            const jsonResponse = JSON.parse(responseText);
            console.log('🔧 DEBUG: Parsed JSON:', jsonResponse);
        } catch (e) {
            console.log('🔧 DEBUG: Response is not JSON');
        }
        
    } catch (error) {
        console.error('🔧 DEBUG: Request failed:', error);
    }
}

// ✅ OVERRIDE THE ORIGINAL renderGrid FUNCTION TO PRESERVE AREAS
// Add this to your main JavaScript, REPLACE the existing renderGrid function:   
    applyBulkEdit() {
        const lifeDays = document.getElementById('bulk-life-days').value;
        const info = document.getElementById('bulk-info').value;
        
        const updates = {};
        if (lifeDays !== '') updates.life_days = parseInt(lifeDays);
        if (info !== '') updates.info = info;
        
        if (Object.keys(updates).length === 0) {
            showStatus('No changes specified', 'warning');
            return;
        }
        
        const treeIds = Array.from(this.selectedTrees);
        
        fetch('/bulk_update_trees', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                tree_ids: treeIds,
                updates: updates
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showStatus('Trees updated successfully', 'success');
                // Update local trees data
                treeIds.forEach(treeId => {
                    const tree = trees.find(t => t.id == treeId);
                    if (tree) {
                        if (updates.life_days !== undefined) tree.life_days = updates.life_days;
                        if (updates.info !== undefined) tree.info = updates.info;
                    }
                });
                this.clearSelection();
            } else {
                showStatus('Failed to update trees: ' + data.error, 'error');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showStatus('Error updating trees', 'error');
        });
    }
}

// Initialize drag selector when DOM is loaded
function createDragAreaFromDialog() {
    if (dragSelector && typeof dragSelector.createDragAreaFromModal === 'function') {
        const success = dragSelector.createDragAreaFromModal();
        if (success) {
            // Close the modal
            const modal = document.querySelector('.drag-area-modal');
            if (modal) {
                modal.remove();
            }
        }
    } else {
        console.error('❌ dragSelector not initialized or createDragAreaFromModal method missing');
        alert('Drag selector not ready. Please try again.');
    }
}


function cancelDragAreaCreation() {
    if (dragSelector && typeof dragSelector.cancelAreaCreation === 'function') {
        dragSelector.cancelAreaCreation();
        // Close the modal
        const modal = document.querySelector('.drag-area-modal');
        if (modal) {
            modal.remove();
        }
    } else {
        console.error('❌ dragSelector not initialized or cancelAreaCreation method missing');
    }
}

function closeDragAreaDialog() {
    const modal = document.querySelector('[style*="position: fixed"]');
    if (modal) {
        modal.remove();
    }
}
function showLoadingState(show) {
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) {
        loadingIndicator.style.display = show ? 'block' : 'none';
    }
    
    if (show) {
        showStatus('Loading...', 'info');
    }
}
function showErrorMessage(message) {
    showStatus(message, 'error');
}

    function showSuccessMessage(message) {
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #d4edda;
            color: #155724;
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid #c3e6cb;
            z-index: 10004;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        successMsg.textContent = message;
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
            if (successMsg.parentNode) {
                successMsg.remove();
            }
        }, 3000);
    }
    function setupButtonEventListeners() {
        console.log('🔧 Setting up button event listeners...');
        
        // Wait for DOM to be ready
        const setupButtons = () => {
            const breedManagerBtn = document.getElementById('breedManagerBtn');
            const addBreedBtn = document.getElementById('addBreedBtn');
            const cancelBreedBtn = document.getElementById('cancelBreedBtn');
            
            if (breedManagerBtn) {
                // Remove any existing onclick
                breedManagerBtn.removeAttribute('onclick');
                breedManagerBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    safeCall('showBreedManager');
                });
                console.log('✅ Breed manager button event listener added');
            }
            
            if (addBreedBtn) {
                // Remove any existing onclick
                addBreedBtn.removeAttribute('onclick');
                addBreedBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    safeCall('addBreedFromInput');
                });
                console.log('✅ Add breed button event listener added');
            }
            
            if (cancelBreedBtn) {
                // Remove any existing onclick
                cancelBreedBtn.removeAttribute('onclick');
                cancelBreedBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    safeCall('cancelNewBreed');
                });
                console.log('✅ Cancel breed button event listener added');
            }
            
            // Add Enter key support for new breed input
            const newBreedInput = document.getElementById('newBreedInput');
            if (newBreedInput) {
                newBreedInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        safeCall('addBreedFromInput');
                    }
                });
                console.log('✅ New breed input Enter key support added');
            }
        };
        
        // Try to setup immediately
        setupButtons();
        
        // Also setup when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupButtons);
        }
        
        // Also setup with a delay to catch dynamically created elements
        setTimeout(setupButtons, 1000);
    }
    
    // ✅ DIAGNOSTIC FUNCTION

   
function debugPasteButton() {
    console.log('=== PASTE BUTTON DEBUG ===');
    console.log('dragClipboard:', dragClipboard);
    console.log('clipboardArea:', clipboardArea);
    console.log('globalDragClipboard in localStorage:', localStorage.getItem('globalDragClipboard'));
    console.log('globalRegularClipboard in localStorage:', localStorage.getItem('globalRegularClipboard'));
    
    const pasteBtn = document.getElementById('pasteAreaBtn');
    console.log('pasteAreaBtn element:', pasteBtn);
    console.log('pasteAreaBtn onclick:', pasteBtn ? pasteBtn.onclick : 'not found');
    console.log('pasteAreaBtn style.display:', pasteBtn ? pasteBtn.style.display : 'not found');
    
    const clickToPasteBtn = document.getElementById('clickToPasteBtn');
    console.log('clickToPasteBtn element:', clickToPasteBtn);
    console.log('clickToPasteBtn onclick:', clickToPasteBtn ? clickToPasteBtn.onclick : 'not found');
    
    console.log('========================');
}
function addDragModeToggle() {
    // Remove existing toggle button if it exists
    const existingButton = document.querySelector('#drag-mode-toggle');
    if (existingButton) {
        existingButton.remove();
    }
    
    // Add drag mode toggle button to the page
    const toggleButton = document.createElement('button');
    toggleButton.id = 'drag-mode-toggle';
    toggleButton.innerHTML = '🎯 Drag Select';
    toggleButton.className = 'btn-info';
    toggleButton.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1000;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        background: #17a2b8;
        color: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
    `;
    
    toggleButton.onmouseover = function() {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
    };
    
    toggleButton.onmouseout = function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    };
    
    toggleButton.onclick = function() {
        if (!dragSelector) {
            alert('Drag selector not initialized. Please refresh the page.');
            return;
        }
        
        if (dragSelector.isDragMode) {
            dragSelector.disableDragMode();
        } else {
            dragSelector.enableDragMode();
        }
    };
    
    document.body.appendChild(toggleButton);
    console.log('✅ Drag mode toggle button added');
}

        // ✅ FIXED: DOMContentLoaded event (properly structured)
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== GRID PAGE INITIALIZATION STARTED ===');
    console.log('Dome ID:', domeId);
    console.log('Grid Size:', currentRows, 'x', currentCols);
    console.log('Initial trees from backend:', trees);
    console.log('Trees count:', trees ? trees.length : 'undefined');
    console.log('========================');
    console.log('🚀 Page loaded, initializing areas...');
    
    // Initialize arrays if not already defined
    if (typeof dragAreas === 'undefined') {
        window.dragAreas = [];
    }
    if (typeof areas === 'undefined') {
        window.areas = [];
    }
    
    // Load areas from backend
    loadAreasFromBackend().then(success => {
        if (success) {
            console.log('✅ Areas initialized successfully');
        } else {
            console.warn('⚠️ Areas initialization had issues');
        }
    });
    try {
        // ✅ STEP 1: Validate critical variables
        if (typeof domeId === 'undefined') {
            console.error('❌ CRITICAL: domeId is undefined');
            showStatus('Error: Dome ID not found', 'error');
            return;
        }
        
        if (typeof currentRows === 'undefined' || typeof currentCols === 'undefined') {
            console.error('❌ CRITICAL: Grid dimensions not defined');
            showStatus('Error: Grid dimensions not found', 'error');
            return;
        }
        
        if (typeof trees === 'undefined') {
            console.error('❌ CRITICAL: Trees data not defined');
            trees = [];
            showStatus('Warning: Trees data not found, using empty array', 'warning');
        }
        
        // ✅ ENHANCED: Validate trees data
        if (!Array.isArray(trees)) {
            console.error('Trees is not an array:', trees);
            trees = [];
            showStatus('Warning: Trees data is invalid, using empty array', 'error');
        }
        
        console.log('✅ Variables validated');
        
        // ✅ STEP 2: Initialize global events FIRST
        if (typeof addGlobalSelectionEvents === 'function') {
            addGlobalSelectionEvents();
            console.log('✅ Global selection events added');
        }
        
        // ✅ STEP 3: Initialize grid components BEFORE other systems
        console.log('🔄 Initializing grid components...');
        
        if (typeof updateGridDisplay === 'function') {
            updateGridDisplay();
        }
        
        if (typeof addKeyboardNavigation === 'function') {
            addKeyboardNavigation();
        }
        
        // ✅ STEP 4: RENDER THE GRID FIRST (MOST CRITICAL)
        if (typeof renderGrid === 'function') {
            console.log('🔄 Calling renderGrid()...');
            renderGrid();
            console.log('✅ renderGrid() completed');
        } else {
            console.error('❌ renderGrid function not found');
            showStatus('Critical error: renderGrid function not found', 'error');
            throw new Error('renderGrid function not found');
        }
        
        // ✅ STEP 5: Update stats after grid is rendered
        if (typeof updateStats === 'function') {
            updateStats();
        }
        
        if (typeof refreshDebugInfo === 'function') {
            refreshDebugInfo();
        }
        
        console.log('✅ Grid initialization completed');
        
        // ✅ STEP 6: Initialize drag selector AFTER grid is ready
        const gridContainer = document.getElementById('gridContainer');
        if (gridContainer && typeof DragSelector === 'function') {
            try {
                // Make sure dragSelector is global
                window.dragSelector = new DragSelector(gridContainer);
                dragSelector = window.dragSelector; // Also assign to local variable
                
                console.log('✅ Drag selector initialized');
                console.log('✅ dragSelector methods available:', Object.getOwnPropertyNames(Object.getPrototypeOf(dragSelector)));
                
                // Load saved drag areas
                setTimeout(() => {
                    if (dragSelector.loadDragAreasFromStorage()) {
                        dragSelector.renderDragAreas();
                        dragSelector.updateDragAreasDisplay();
                    }
                    
                    // Load saved clipboard
                    if (typeof dragSelector.loadDragClipboardFromStorage === 'function') {
                        dragSelector.loadDragClipboardFromStorage();
                    }
                }, 500);
                
                // Add drag mode toggle button
                if (typeof addDragModeToggle === 'function') {
                    addDragModeToggle();
                }
            } catch (dragError) {
                console.error('❌ Error initializing drag selector:', dragError);
            }
        } else {
            console.error('❌ gridContainer not found or DragSelector class not available');
        }
        
        // ✅ STEP 7: Initialize line area system AFTER grid is ready
        setTimeout(() => {
            try {
                const dragLineControls = document.getElementById('dragLineControls');
                if (dragLineControls) {
                    dragLineControls.style.display = 'block';
                    console.log('✅ Drag line controls shown');
                }
                
                // ✅ ENHANCED: Load saved line areas with better error handling
                console.log('🔄 Loading line areas from storage...');
                
                if (typeof loadLineAreasFromStorage === 'function') {
                    const loaded = loadLineAreasFromStorage();
                    
                    if (loaded && areas.length > 0) {
                        console.log(`✅ Loaded ${areas.length} line areas from storage`);
                        
                        // Show areas list
                        const areasList = document.getElementById('lineAreasList');
                        if (areasList) {
                            areasList.style.display = 'block';
                        }
                        
                        // Render areas after a short delay to ensure grid is ready
                        setTimeout(() => {
                            if (typeof renderLineAreas === 'function') {
                                renderLineAreas();
                                console.log('✅ Line areas rendered');
                            }
                            
                            if (typeof updateLineAreasDisplay === 'function') {
                                updateLineAreasDisplay();
                                console.log('✅ Line areas display updated');
                            }
                        }, 200);
                        
                    } else {
                        console.log('No line areas found in storage');
                    }
                } else {
                    console.error('❌ loadLineAreasFromStorage function not found');
                }
                
                console.log('✅ Line area system initialized');
                
            } catch (lineError) {
                console.error('❌ Error initializing line areas:', lineError);
            }
        }, 1000);
        
        // ✅ STEP 8: Check dome image on load
        const domeImage = document.querySelector('.dome-image-img');
        if (domeImage) {
            domeImage.onerror = function() {
                console.error('❌ Failed to load dome image');
                // Replace with placeholder
                const placeholder = document.createElement('div');
                placeholder.className = 'dome-placeholder';
                placeholder.textContent = '🏠';
                placeholder.onclick = openDomeInfo;
                placeholder.title = 'Click to edit dome - {{ dome.name }}';
                
                const container = this.closest('.dome-image-container');
                if (container && container.parentNode) {
                    container.parentNode.replaceChild(placeholder, container);
                }
            };
            
            domeImage.onload = function() {
                console.log('✅ Dome image loaded successfully');
            };
        }
        
        // ✅ STEP 9: Validate tree data structure
        trees.forEach((tree, index) => {
            if (!tree.hasOwnProperty('internal_row') || !tree.hasOwnProperty('internal_col')) {
                console.error(`Tree ${index} missing position data:`, tree);
                showStatus(`Tree data structure error detected`, 'error');
            }
            if (tree.internal_row < 0 || tree.internal_row >= currentRows || 
                tree.internal_col < 0 || tree.internal_col >= currentCols) {
                console.error(`Tree ${index} has invalid position:`, tree);
                showStatus(`Tree position out of bounds detected`, 'error');
            }
        });
        
        // ✅ STEP 10: Data sync validation
        const backendTreeCount = parseInt('{{ trees_data|length|default(0) }}') || 0;
        const frontendTreeCount = trees.length;
        
        if (frontendTreeCount !== backendTreeCount) {
            console.warn(`Data mismatch! Backend: ${backendTreeCount}, Frontend: ${frontendTreeCount}`);
            showStatus(`Data sync issue detected. Backend: ${backendTreeCount}, Frontend: ${frontendTreeCount}`, 'warning');
            
            // Force refresh trees data
            if (typeof forceRefreshTrees === 'function') {
                setTimeout(forceRefreshTrees, 1000);
            }
        }
        
        // ✅ STEP 11: Load clipboard from storage
        if (typeof loadClipboardFromStorage === 'function' && loadClipboardFromStorage()) {
            console.log('Clipboard area loaded from storage:', clipboardArea);
        }
        
        // ✅ STEP 12: Initialize paste buttons
        setTimeout(() => {
            console.log('🔄 Initializing paste buttons...');
            
            // Load global clipboards
            const globalDrag = localStorage.getItem('globalDragClipboard');
            const globalRegular = localStorage.getItem('globalRegularClipboard');
            
            if (globalDrag) {
                try {
                    dragClipboard = JSON.parse(globalDrag);
                    console.log('✅ Loaded global drag clipboard:', dragClipboard.name);
                } catch (e) {
                    console.error('❌ Error loading global drag clipboard:', e);
                }
            }
            
            if (globalRegular) {
                try {
                    clipboardArea = JSON.parse(globalRegular);
                    console.log('✅ Loaded global regular clipboard:', clipboardArea.name);
                } catch (e) {
                    console.error('❌ Error loading global regular clipboard:', e);
                }
            }
            
            // Update button visibility
            if (typeof updatePasteButtonVisibility === 'function') {
                updatePasteButtonVisibility();
            }
            
            console.log('✅ Paste buttons initialized');
        }, 1000);
        
        console.log('✅ All initialization steps completed successfully');
        
    } catch (error) {
        // ✅ CRITICAL: Added missing catch block
        console.error('❌ CRITICAL ERROR during initialization:', error);
        showStatus('Critical error during initialization: ' + error.message, 'error');
        
        // Show error in grid area if possible
        const grid = document.getElementById('treeGrid');
        if (grid) {
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: red; background: #ffe6e6; border-radius: 8px; margin: 20px;">
                    <h3>❌ Grid Loading Error</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Please check the browser console for more details.</p>
                    <button onclick="location.reload()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                        🔄 Reload Page
                    </button>
                </div>
            `;
        }
    }
setTimeout(async () => {
    console.log('🔄 Loading areas from database...');
    
    try {
        // Initialize arrays if not already defined
        if (typeof dragAreas === 'undefined') {
            window.dragAreas = [];
        }
        if (typeof areas === 'undefined') {
            window.areas = [];
        }
        
        // Load areas from database using the function you want to keep
        const loaded = await loadAreasFromBackend();
        
        if (loaded) {
            console.log('✅ Areas loaded successfully from database');
            
            // ✅ CRITICAL: Update displays after loading
            setTimeout(() => {
                console.log('🔄 Updating displays after area loading...');
                
                // Update drag areas display
                if (dragSelector && typeof dragSelector.updateDragAreasDisplay === 'function') {
                    dragSelector.updateDragAreasDisplay();
                }
                
                // Update regular areas display
                if (typeof updateAreasDisplay === 'function') {
                    updateAreasDisplay();
                }
                
                // Show area lists if they have data
                if (dragAreas.length > 0) {
                    const dragAreasList = document.getElementById('dragAreasList');
                    if (dragAreasList) {
                        dragAreasList.style.display = 'block';
                    }
                }
                
                if (areas.length > 0) {
                    const areasList = document.getElementById('areasList');
                    if (areasList) {
                        areasList.style.display = 'block';
                    }
                }
                
                // Final grid render to show all areas
                renderGrid();
                
                console.log('✅ All displays updated after area loading');
            }, 500);
            
        } else {
            console.log('No areas found in database');
        }
        
    } catch (error) {
        console.error('❌ Error during area loading:', error);
    }
    
}, 2000);
setTimeout(() => {
    if (dragSelector && dragSelector.loadDragAreasFromStorage()) {
        // ✅ CRITICAL: Recalculate tree counts after loading
        recalculateDragAreaTreeCounts();
        
        dragSelector.renderDragAreas();
        dragSelector.updateDragAreasDisplay();
    }
}, 500);
setTimeout(() => {
    // Auto-sync any unsaved drag areas to database
    if (dragSelector && typeof dragSelector.saveDragAreasToDatabase === 'function') {
        const unsavedAreas = dragAreas.filter(area => !area.saved_to_db);
        if (unsavedAreas.length > 0) {
            console.log(`🔄 Found ${unsavedAreas.length} unsaved drag areas, syncing to database...`);
            dragSelector.saveDragAreasToDatabase();
        }
    }
}, 3000); // Run after initial load is complete // Reduced from 3000 to 2000ms initialization to complete
});



// ✅ ENHANCED: Global clipboard loading functions



// ✅ ENHANCED: Show paste controls
function showPasteControls() {
    // Show paste button if clipboard has data
    const pasteButton = document.getElementById('pasteAreaButton');
    if (pasteButton) {
        pasteButton.style.display = (clipboardArea || dragClipboard) ? 'inline-block' : 'none';
    }
    
    // Update paste button text
    if (clipboardArea) {
        if (pasteButton) {
            pasteButton.textContent = `📋 Paste "${clipboardArea.name}"`;
        }
    } else if (dragClipboard) {
        if (pasteButton) {
            pasteButton.textContent = `📋 Paste "${dragClipboard.name}"`;
        }
    }
}


     

// ✅ Test function (outside of DOMContentLoaded)
function testDragSelector() {
    console.log('Testing drag selector...');
    console.log('dragSelector exists:', !!dragSelector);
    console.log('dragSelector type:', typeof dragSelector);
    
    if (dragSelector) {
        console.log('createDragArea method exists:', typeof dragSelector.createDragArea);
        console.log('cancelAreaCreation method exists:', typeof dragSelector.cancelAreaCreation);
        console.log('Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(dragSelector)));
    }
    
    // Test global wrapper functions
    console.log('createDragAreaFromDialog exists:', typeof createDragAreaFromDialog);
    console.log('cancelDragAreaCreation exists:', typeof cancelDragAreaCreation);
}

// Make it available globally for testing
window.testDragSelector = testDragSelector;

console.log('✅ DOMContentLoaded event listener registered');
console.log('🔧 Use testDragSelector() in console to debug');
        // ✅ FIXED: Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        });

        // ✅ FIXED: Make functions globally accessible for debugging
        window.debugTreeData = function() {
            console.log('=== TREE DEBUG ===');
            console.log('Frontend trees:', trees);
            console.log('Frontend count:', trees.length);
            
            const backendCount = document.getElementById('frontendTreesDisplay')?.textContent || 'Unknown';
            console.log('Backend count from DOM:', backendCount);
            
            // Force refresh from API
            fetch(`/api/dome/${domeId}/trees`)
            .then(response => response.json())
            .then(data => {
                console.log('API response:', data);
                if (data.success) {
                    console.log('API trees count:', data.trees.length);
                    console.log('API trees data:', data.trees);
                } else {
                    console.error('API error:', data.error);
                }
            })
            .catch(error => {
                console.error('Network error:', error);
            });
        };
        window.debugDragAreaTreeCounts = function() {
    console.log('🔍 DRAG AREA TREE COUNT DEBUG');
    console.log('==============================');
    
    console.log('📊 Global Data Status:');
    console.log('  - trees array:', trees ? `${trees.length} items` : 'undefined');
    console.log('  - dragAreas array:', dragAreas ? `${dragAreas.length} items` : 'undefined');
    console.log('  - domeId:', domeId || 'undefined');
    
    if (!trees || !Array.isArray(trees)) {
        console.error('❌ Global trees array is missing or invalid');
        return;
    }
    
    if (!dragAreas || !Array.isArray(dragAreas)) {
        console.error('❌ dragAreas array is missing or invalid');
        return;
    }
    
    console.log('\n🌳 Sample trees data:');
    trees.slice(0, 3).forEach((tree, i) => {
        console.log(`  ${i + 1}. "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
    });
    
    console.log('\n🎯 Drag Areas Analysis:');
    dragAreas.forEach((area, index) => {
        console.log(`\n📦 Area ${index + 1}: "${area.name}"`);
        console.log(`  - Bounds: (${area.minRow},${area.minCol}) to (${area.maxRow},${area.maxCol})`);
        console.log(`  - Size: ${area.width}×${area.height} = ${area.width * area.height} cells`);
        console.log(`  - Stored tree count: ${area.tree_count || 'undefined'}`);
        console.log(`  - Stored tree IDs: ${area.trees ? area.trees.length : 'undefined'}`);
        
        // Manual tree counting with detailed logging
        const treesInBounds = [];
        trees.forEach(tree => {
            if (tree && tree.internal_row !== undefined && tree.internal_col !== undefined) {
                const treeRow = parseInt(tree.internal_row);
                const treeCol = parseInt(tree.internal_col);
                const areaMinRow = parseInt(area.minRow);
                const areaMaxRow = parseInt(area.maxRow);
                const areaMinCol = parseInt(area.minCol);
                const areaMaxCol = parseInt(area.maxCol);
                
                if (treeRow >= areaMinRow && treeRow <= areaMaxRow &&
                    treeCol >= areaMinCol && treeCol <= areaMaxCol) {
                    treesInBounds.push(tree);
                }
            }
        });
        
        console.log(`  - Actual trees found: ${treesInBounds.length}`);
        if (treesInBounds.length > 0) {
            console.log(`  - Trees in area:`);
            treesInBounds.forEach(tree => {
                console.log(`    * "${tree.name}" at (${tree.internal_row}, ${tree.internal_col})`);
            });
        }
        
        // Check for discrepancies
        const storedCount = area.tree_count || 0;
        if (storedCount !== treesInBounds.length) {
            console.log(`  ❌ COUNT MISMATCH: Stored=${storedCount}, Actual=${treesInBounds.length}`);
        } else {
            console.log(`  ✅ Count matches: ${treesInBounds.length}`);
        }
    });
    
    console.log('\n🔧 To fix all counts, run: fixAllDragAreaTreeCounts()');
};

// ✅ ADD: Function to fix all tree counts
window.fixAllDragAreaTreeCounts = function() {
    console.log('🔧 Fixing all drag area tree counts...');
    
    if (!trees || !Array.isArray(trees)) {
        console.error('❌ Global trees array not available');
        return;
    }
    
    if (!dragAreas || !Array.isArray(dragAreas)) {
        console.error('❌ dragAreas array not available');
        return;
    }
    
    let fixedCount = 0;
    
    dragAreas.forEach(area => {
        // Use the same logic as updateDragAreasDisplay
        const treesInArea = trees.filter(tree => {
            if (!tree || tree.internal_row === undefined || tree.internal_col === undefined) {
                return false;
            }
            
            const treeRow = parseInt(tree.internal_row);
            const treeCol = parseInt(tree.internal_col);
            const areaMinRow = parseInt(area.minRow);
            const areaMaxRow = parseInt(area.maxRow);
            const areaMinCol = parseInt(area.minCol);
            const areaMaxCol = parseInt(area.maxCol);
            
            return treeRow >= areaMinRow && 
                   treeRow <= areaMaxRow &&
                   treeCol >= areaMinCol && 
                   treeCol <= areaMaxCol;
        });
        
        const oldCount = area.tree_count || 0;
        const newCount = treesInArea.length;
        
        if (oldCount !== newCount) {
            console.log(`🔧 Fixing "${area.name}": ${oldCount} → ${newCount}`);
            area.tree_count = newCount;
            area.trees = treesInArea.map(t => t.id);
            area.empty_count = (area.width * area.height) - newCount;
            area.total_cells = area.width * area.height;
            fixedCount++;
        }
    });
    
    if (fixedCount > 0) {
        console.log(`✅ Fixed ${fixedCount} areas`);
        
        // Update displays
        if (dragSelector && typeof dragSelector.updateDragAreasDisplay === 'function') {
            dragSelector.updateDragAreasDisplay();
        }
        if (dragSelector && typeof dragSelector.renderDragAreas === 'function') {
            dragSelector.renderDragAreas();
        }
        if (typeof dragSelector.saveDragAreasToStorage === 'function') {
            dragSelector.saveDragAreasToStorage();
        }
        
        showStatus(`Fixed tree counts for ${fixedCount} drag areas`, 'success');
    } else {
        console.log('✅ All area counts are already correct');
        showStatus('All drag area counts are correct', 'success');
    }
};

// ✅ ADD: Auto-fix function that runs periodically
window.autoFixDragAreaCounts = function() {
    console.log('🔄 Auto-fixing drag area counts...');
    
    // Wait for data to be loaded
    setTimeout(() => {
        if (typeof window.fixAllDragAreaTreeCounts === 'function') {
            window.fixAllDragAreaTreeCounts();
        }
    }, 2000);
};

// ✅ ENHANCED: Better createDragAreaFromModal with accurate initial counts
DragSelector.prototype.createDragAreaFromModal = function() {
    const name = document.getElementById('drag-area-name').value.trim();
    const color = document.getElementById('drag-area-color').value;
    
    if (!name) {
        alert('Please enter an area name');
        return false;
    }
    
    if (this.selectedCells.size === 0) {
        alert('No cells selected');
        return false;
    }
    
    // Check for duplicate names
    if (typeof dragAreas !== 'undefined' && dragAreas.some(area => area.name.toLowerCase() === name.toLowerCase())) {
        alert('Area name already exists');
        return false;
    }
    
    const selectionInfo = this.getSelectionInfo();
    const { minRow, maxRow, minCol, maxCol } = selectionInfo;
    
    // ✅ CRITICAL: Get accurate tree count using same logic as display function
    const treesInSelection = trees.filter(tree => {
        if (!tree || tree.internal_row === undefined || tree.internal_col === undefined) {
            return false;
        }
        
        const treeRow = parseInt(tree.internal_row);
        const treeCol = parseInt(tree.internal_col);
        
        return treeRow >= minRow && 
               treeRow <= maxRow &&
               treeCol >= minCol && 
               treeCol <= maxCol;
    });
    
    const actualTreeCount = treesInSelection.length;
    
    console.log('💾 Creating drag area with accurate data:', {
        name,
        color,
        bounds: { minRow, maxRow, minCol, maxCol },
        selectedCells: this.selectedCells.size,
        selectedTrees: this.selectedTrees.size,
        actualTreesInBounds: actualTreeCount,
        treesFound: treesInSelection.map(t => `"${t.name}" at (${t.internal_row}, ${t.internal_col})`)
    });
    
    // ✅ ENHANCED: Create cells data for both trees and empty cells
    const cellsData = Array.from(this.selectedCells).map(cellKey => {
        const [row, col] = cellKey.split(',').map(Number);
        return { row, col };
    });
    
    // ✅ FIXED: Use accurate tree count and IDs
    return this.saveDragAreaToDatabase(
        name, 
        color, 
        minRow, 
        maxRow, 
        minCol, 
        maxCol, 
        treesInSelection.map(t => t.id), // Use actual tree IDs from bounds check
        cellsData
    )
    .then(savedArea => {
        if (savedArea) {
            // ✅ CRITICAL: Ensure saved area has correct counts
            savedArea.tree_count = actualTreeCount;
            savedArea.trees = treesInSelection.map(t => t.id);
            savedArea.empty_count = cellsData.length - actualTreeCount;
            savedArea.total_cells = cellsData.length;
            
            const existingIndex = dragAreas.findIndex(area => area.id === savedArea.id);
            if (existingIndex === -1) {
                dragAreas.push(savedArea);
                console.log('✅ New drag area added with correct counts:', savedArea);
            } else {
                dragAreas[existingIndex] = savedArea;
                console.log('✅ Existing drag area updated with correct counts:', savedArea);
            }
            
            this.clearSelection();
            this.disableDragMode();
            this.renderDragAreas();
            this.updateDragAreasDisplay();
            this.saveDragAreasToStorage();
            
            showStatus(`Drag area "${name}" created! (${actualTreeCount} trees, ${savedArea.empty_count} empty cells)`, 'success');
            
            const modal = document.querySelector('.drag-area-modal');
            if (modal) {
                modal.remove();
            }
            
            return true;
        }
        return false;
    })
    .catch(error => {
        console.error('❌ Error creating drag area:', error);
        showStatus('Error creating drag area: ' + error.message, 'error');
        return false;
    });
};

// ✅ ADD: Initialize auto-fix on page load
document.addEventListener('DOMContentLoaded', function() {
    // Auto-fix counts after everything loads
    setTimeout(() => {
        if (typeof window.autoFixDragAreaCounts === 'function') {
            window.autoFixDragAreaCounts();
        }
    }, 3000); // Wait 3 seconds for all data to load
});

// ✅ ADD: Also run when drag areas are rendered
const originalRenderDragAreas = DragSelector.prototype.renderDragAreas;
DragSelector.prototype.renderDragAreas = function() {
    // Call original function
    if (originalRenderDragAreas) {
        originalRenderDragAreas.call(this);
    }
    
    // Auto-fix counts after rendering
    setTimeout(() => {
        if (typeof window.fixAllDragAreaTreeCounts === 'function') {
            window.fixAllDragAreaTreeCounts();
        }
    }, 500);
};
        window.deleteArea = deleteArea;
        window.loadAreasFromBackend = loadAreasFromBackend;
        window.debugGrid = refreshDebugInfo;
        window.forceRefreshTrees = forceRefreshTrees;
        window.getEmptyPositions = getEmptyPositions;
        window.trees = trees;
        window.domeId = domeId;
        window.testNavigation = testNavigation;
        window.deleteArea = deleteArea;
        window.loadAreasFromDatabase = loadAreasFromDatabase;
        window.executePasteAtPosition = executePasteAtPosition;
        window.loadBreedsFromBackend = loadBreedsFromBackend;
window.saveBreedsToBackend = saveBreedsToBackend;
window.addNewBreed = addNewBreed;
window.removeBreed = removeBreed;
window.toggleBreedDropdown = toggleBreedDropdown;
window.filterBreedOptions = filterBreedOptions;
window.selectBreed = selectBreed;
window.updateBreedInfoDisplay = updateBreedInfoDisplay;
window.updateBreedDropdown = updateBreedDropdown;
window.toggleNewBreedInput = toggleNewBreedInput;
window.addBreedFromInput = addBreedFromInput;
window.cancelNewBreed = cancelNewBreed;
window.showBreedManager = showBreedManager;
window.createTreeCreationModal = createTreeCreationModal;
window.closeTreeCreationModal = closeTreeCreationModal;
window.submitTreeCreation = submitTreeCreation;
window.initializeBreedSystem = initializeBreedSystem;
document.addEventListener('DOMContentLoaded', function() {
    console.log('📄 DOM loaded, initializing breed system...');
    
    setTimeout(async () => {
        // Try to load from backend first
        const backendLoaded = await loadBreedsFromBackend();
        
        if (!backendLoaded) {
            console.log('ℹ️ Using local breeds only');
        }
        
        // Update dropdown if it exists
        if (document.getElementById('breedDropdown')) {
            updateBreedDropdown();
        }
        
        console.log('✅ Breed system initialized with', treeBreeds.length, 'breeds');
    }, 1000);
});
        window.getClipboardArea = function() {
    return clipboardArea;
};
// ✅ DEBUG: Check what's in the frontend trees array
w
// ✅ DEBUG: Force reload trees with breed data
window.forceReloadTrees = async function() {
    try {
        console.log('🔄 Force reloading trees with breed data...');
        
        const response = await fetch(`/api/trees/${domeId}`);
        if (response.ok) {
            const result = await response.json();
            console.log('📡 API Response:', result);
            
            if (result.success && result.trees) {
                trees = result.trees;
                console.log('✅ Trees reloaded:', trees.length);
                
                // Check if breed data is now present
                const treesWithBreeds = trees.filter(t => t.breed && t.breed.trim().length > 0);
                const treesWithBreedProperty = trees.filter(t => 'breed' in t);
                
                console.log('🧬 Trees with breed property after reload:', treesWithBreedProperty.length);
                console.log('🧬 Trees with actual breed values after reload:', treesWithBreeds.length);
                
                if (treesWithBreeds.length > 0) {
                    console.log('🧬 Breeds found:', treesWithBreeds.map(t => `${t.name}: ${t.breed}`));
                } else {
                    console.log('⚠️ Trees reloaded but still no breed values found');
                    
                    // Debug first tree structure
                    if (trees.length > 0) {
                        console.log('🔍 First tree structure after reload:', {
                            id: trees[0].id,
                            name: trees[0].name,
                            breed: trees[0].breed,
                            hasBreed: 'breed' in trees[0],
                            keys: Object.keys(trees[0])
                        });
                    }
                }
                
                return true;
            } else {
                console.error('❌ API response error:', result);
            }
        } else {
            console.error('❌ HTTP error:', response.status, response.statusText);
            
            // Try to read error response
            try {
                const errorText = await response.text();
                console.error('❌ Error response body:', errorText);
            } catch (e) {
                console.error('❌ Could not read error response');
            }
        }
        
        console.error('❌ Failed to reload trees');
        return false;
    } catch (error) {
        console.error('❌ Error reloading trees:', error);
        return false;
    }
};

// ✅ DEBUG: Check clipboard contents
window.debugClipboard = function() {
    console.log('=== CLIPBOARD DEBUG ===');
    
    if (dragClipboard) {
        console.log('📦 Current dragClipboard:', {
            name: dragClipboard.name,
            trees: dragClipboard.trees ? dragClipboard.trees.length : 0,
            breeds: dragClipboard.summary ? dragClipboard.summary.breeds : [],
            breedCount: dragClipboard.summary ? dragClipboard.summary.breeds.length : 0
        });
        
        if (dragClipboard.trees) {
            console.log('🧬 Trees in clipboard with breeds:');
            dragClipboard.trees.forEach((tree, index) => {
                console.log(`   Tree ${index + 1}: "${tree.name}" - Breed: "${tree.breed || 'None'}"`);
            });
        }
    } else {
        console.log('📭 No dragClipboard data');
    }
    
    // Check localStorage
    try {
        const localData = localStorage.getItem('globalDragClipboard');
        if (localData) {
            const parsed = JSON.parse(localData);
            console.log('💾 LocalStorage clipboard:', {
                name: parsed.name,
                trees: parsed.trees ? parsed.trees.length : 0,
                breeds: parsed.summary ? parsed.summary.breeds : []
            });
        } else {
            console.log('💾 No clipboard in localStorage');
        }
    } catch (e) {
        console.error('❌ Error reading localStorage clipboard:', e);
    }
    
    console.log('========================');
};

// ✅ DEBUG: Test copy function with specific area
window.testCopyArea = function(areaId) {
    console.log(`🧪 Testing copy for area ${areaId}...`);
    
    const area = dragAreas.find(a => a.id === areaId);
    if (!area) {
        console.error(`❌ Area ${areaId} not found`);
        return;
    }
    
    console.log('📊 Area to copy:', {
        id: area.id,
        name: area.name,
        trees: area.trees,
        treeCount: area.trees ? area.trees.length : 0
    });
    
    if (area.trees && area.trees.length > 0) {
        console.log('🌳 Trees in area:');
        area.trees.forEach(treeId => {
            const tree = trees.find(t => t.id == treeId);
            if (tree) {
                console.log(`   Tree ${treeId}: "${tree.name}" - Breed: "${tree.breed || 'None'}"`);
            } else {
                console.log(`   Tree ${treeId}: NOT FOUND in frontend trees array`);
            }
        });
    }
    
    // Now try the actual copy
    if (dragSelector && typeof dragSelector.copyDragArea === 'function') {
        dragSelector.copyDragArea(areaId);
    } else {
        console.error('❌ dragSelector not available or copyDragArea method not found');
        showStatus('Copy functionality not available', 'error');
    }
};
window.fixTreesNow = async function() {
    console.log('🔧 Manual tree fix initiated...');
    
    console.log('📊 Before fix:');
    debugTrees();
    
    console.log('🔄 Reloading trees...');
    const success = await forceReloadTrees();
    
    if (success) {
        console.log('📊 After fix:');
        debugTrees();
        
        console.log('🧪 Testing copy function...');
        if (dragAreas && dragAreas.length > 0) {
            const firstArea = dragAreas[0];
            console.log(`🧪 Testing copy with area: ${firstArea.name} (ID: ${firstArea.id})`);
            testCopyArea(firstArea.id);
        } else {
            console.log('⚠️ No drag areas found to test');
        }
    } else {
        console.error('❌ Tree fix failed');
    }
};
// ✅ DEBUG: Check what's in the clipboard
window.debugClipboard = function() {
    console.log('=== CLIPBOARD DEBUG ===');
    
    // Check sessionStorage
    try {
        const sessionData = sessionStorage.getItem('dragClipboard');
        if (sessionData) {
            const parsed = JSON.parse(sessionData);
            console.log('📋 SessionStorage clipboard:', {
                name: parsed.name,
                trees: parsed.trees ? parsed.trees.length : 0,
                breeds: parsed.summary ? parsed.summary.breeds : []
            });
        } else {
            console.log('📋 No clipboard in sessionStorage');
        }
    } catch (e) {
        console.error('❌ Error reading sessionStorage clipboard:', e);
    }
    
    // Check localStorage
    try {
        const localData = localStorage.getItem('globalDragClipboard');
        if (localData) {
            const parsed = JSON.parse(localData);
            console.log('📋 LocalStorage clipboard:', {
                name: parsed.name,
                trees: parsed.trees ? parsed.trees.length : 0,
                breeds: parsed.summary ? parsed.summary.breeds : []
            });
        } else {
            console.log('📋 No clipboard in localStorage');
        }
    } catch (e) {
        console.error('❌ Error reading localStorage clipboard:', e);
    }
    
    console.log('========================');
};
window.setClipboardArea = function(area) {
    clipboardArea = area;
    if (area) {
        const indicator = document.getElementById('clipboardIndicator');
        indicator.textContent = `📋 "${area.name}" available for paste`;
        indicator.style.display = 'block';
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 3000);
    }
};

window.hasClipboardArea = function() {
    return clipboardArea !== null;
};

// Save clipboard to localStorage for persistence across pages
window.saveClipboardToStorage = function() {
    if (clipboardArea) {
        localStorage.setItem(`areaClipboard_dome_${domeId}`, JSON.stringify(clipboardArea));
    }
};

window.loadClipboardFromStorage = function() {
    const stored = localStorage.getItem(`areaClipboard_dome_${domeId}`);
    if (stored) {
        clipboardArea = JSON.parse(stored);
        return true;
    }
    return false;
};
window.debugTreeElements = function() {
    console.log('=== TREE ELEMENTS DEBUG ===');
    
    // Check trees array
    console.log('Trees in array:', trees.length);
    if (trees.length > 0) {
        console.log('First tree:', trees[0]);
    }
    
    // Check all possible tree selectors
    const selectors = [
        '[data-tree-id]',
        '.tree-element',
        '.tree',
        '.tree-item',
        '.grid-cell .tree',
        '.grid-cell [data-tree-id]',
        'img[data-tree-id]',
        'div[data-tree-id]'
    ];
    
    selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        console.log(`Selector "${selector}":`, elements.length, 'elements');
        if (elements.length > 0) {
            console.log('  First element:', elements[0]);
            console.log('  Attributes:', Array.from(elements[0].attributes).map(attr => `${attr.name}="${attr.value}"`));
        }
    });
    
    // Check grid cells
    const cells = document.querySelectorAll('[data-row][data-col]');
    console.log('Grid cells found:', cells.length);
    if (cells.length > 0) {
        console.log('First cell:', cells[0]);
        console.log('Cell children:', cells[0].children);
    }
    
    // Check if trees are in specific positions
    if (trees.length > 0) {
        const firstTree = trees[0];
        const cellAtPosition = document.querySelector(`[data-row="${firstTree.internal_row}"][data-col="${firstTree.internal_col}"]`);
        console.log(`Cell at tree position (${firstTree.internal_row}, ${firstTree.internal_col}):`, cellAtPosition);
        if (cellAtPosition) {
            console.log('Cell content:', cellAtPosition.innerHTML);
        }
    }
    
    console.log('========================');
};
window.testTreeScroll = function(treeId) {
    console.log('🧪 Testing tree scroll for ID:', treeId);
    
    // First run debug
    debugTreeElements();
    
    // Then try to scroll
    setTimeout(() => {
        selectSearchResult(treeId);
    }, 1000);
};
window.testFirstTree = function() {
    if (trees.length > 0) {
        console.log('🧪 Testing scroll to first tree');
        testTreeScroll(trees[0].id);
    } else {
        console.log('❌ No trees available');
    }
};

console.log('✅ Enhanced tree scrolling with debugging loaded');
console.log('🧪 Run debugTreeElements() to see DOM structure');
console.log('🧪 Run testFirstTree() to test scrolling');
// Load clipboard on page load
window.debugPasteButton = debugPasteButton;
window.handlePasteButtonClick = handlePasteButtonClick;
window.debugAreaData = function() {
    console.log('=== AREA DEBUG ===');
    console.log('Drag areas:', dragAreas);
    console.log('Regular areas:', areas);
    console.log('Total areas:', (dragAreas?.length || 0) + (areas?.length || 0));
    
    // Test API endpoints
    console.log('Testing API endpoints...');
    
    fetch(`/api/get_drag_areas/${domeId}`)
        .then(response => response.json())
        .then(data => console.log('Drag areas API:', data))
        .catch(error => console.error('Drag areas API error:', error));
    
    fetch(`/api/regular_areas/${domeId}`)
        .then(response => response.json())
        .then(data => console.log('Regular areas API:', data))
        .catch(error => console.error('Regular areas API error:', error));
    
    console.log('==================');
};
// Save clipboard when copying
const originalCopyArea = copyArea;
copyArea = function(areaId) {
    originalCopyArea(areaId);
    saveClipboardToStorage();
};
// ✅ ADD THIS DEBUG FUNCTION
window.debugTreeElements = function() {
    console.log('=== TREE ELEMENTS DEBUG ===');
    
    // Check trees array
    console.log('Trees in array:', trees ? trees.length : 'undefined');
    if (trees && trees.length > 0) {
        console.log('First tree:', trees[0]);
        console.log('Sample tree structure:', {
            id: trees[0].id,
            name: trees[0].name,
            internal_row: trees[0].internal_row,
            internal_col: trees[0].internal_col,
            breed: trees[0].breed
        });
    }
    
    // Check all possible tree selectors
    const selectors = [
        '[data-tree-id]',
        '.tree-element',
        '.tree',
        '.tree-item',
        '.grid-cell .tree',
        '.grid-cell [data-tree-id]',
        'img[data-tree-id]',
        'div[data-tree-id]',
        '.tree-image',
        '.tree-container'
    ];
    
    selectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        console.log(`Selector "${selector}":`, elements.length, 'elements');
        if (elements.length > 0) {
            console.log('  First element:', elements[0]);
            console.log('  Attributes:', Array.from(elements[0].attributes).map(attr => `${attr.name}="${attr.value}"`));
            console.log('  HTML:', elements[0].outerHTML.substring(0, 200) + '...');
        }
    });
    
    // Check grid cells
    const cells = document.querySelectorAll('[data-row][data-col]');
    console.log('Grid cells found:', cells.length);
    if (cells.length > 0) {
        console.log('First cell:', cells[0]);
        console.log('Cell children:', cells[0].children.length);
        if (cells[0].children.length > 0) {
            console.log('First child:', cells[0].children[0]);
        }
        console.log('Cell HTML sample:', cells[0].outerHTML.substring(0, 300) + '...');
    }
    
    // Check if trees are in specific positions
    if (trees && trees.length > 0) {
        const firstTree = trees[0];
        const cellAtPosition = document.querySelector(`[data-row="${firstTree.internal_row}"][data-col="${firstTree.internal_col}"]`);
        console.log(`Cell at tree position (${firstTree.internal_row}, ${firstTree.internal_col}):`, cellAtPosition);
        if (cellAtPosition) {
            console.log('Cell content:', cellAtPosition.innerHTML);
            console.log('Cell children:', cellAtPosition.children);
        }
    }
    
    // Check the grid container
    const gridContainer = document.getElementById('treeGrid');
    console.log('Grid container:', gridContainer);
    if (gridContainer) {
        console.log('Grid container children:', gridContainer.children.length);
    }
    
    console.log('========================');
};

// ✅ ADD THIS TEST FUNCTION
window.testFirstTree = function() {
    console.log('🧪 Testing first tree...');
    
    if (!trees || trees.length === 0) {
        console.log('❌ No trees available');
        return;
    }
    
    const firstTree = trees[0];
    console.log('First tree:', firstTree);
    
    // Try to find the tree element
    const treeElement = document.querySelector(`[data-tree-id="${firstTree.id}"]`);
    console.log('Tree element found:', treeElement);
    
    if (treeElement) {
        console.log('✅ Tree element exists, testing scroll...');
        selectSearchResult(firstTree.id);
    } else {
        console.log('❌ Tree element not found, running full debug...');
        debugTreeElements();
    }
};

// ✅ ADD THIS SIMPLE SCROLL TEST
window.testScrollToPosition = function(row, col) {
    console.log(`🧪 Testing scroll to position (${row}, ${col})`);
    
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    console.log('Cell found:', cell);
    
    if (cell) {
        cell.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
        
        // Highlight the cell
        cell.style.backgroundColor = 'red';
        cell.style.transition = 'background-color 0.5s ease';
        
        setTimeout(() => {
            cell.style.backgroundColor = '';
        }, 2000);
        
        console.log('✅ Scrolled to position');
    } else {
        console.log('❌ Cell not found');
    }
};

console.log('✅ Debug functions loaded');
 // ✅ COMPLETE DOME ISOLATION AND PASTE BUTTON FIX

// ✅ 1. ADD updatePasteButtonDisplay() FUNCTION
function updatePasteButtonDisplay() {
    const pasteBtn = document.getElementById('pasteAreaBtn');
    if (!pasteBtn) return;

    // Check what's in clipboard (priority order)
    const dragClipboard = window.dragClipboard;
    const clipboardArea = window.clipboardArea;
    const copiedTreeData = window.copiedTreeData;

    console.log('🔄 Updating paste button display...');
    console.log('dragClipboard:', dragClipboard?.name);
    console.log('clipboardArea:', clipboardArea?.name);
    console.log('copiedTreeData:', copiedTreeData?.tree?.name);

    if (dragClipboard) {
        pasteBtn.style.display = 'block';
        
        if (dragClipboard.type === 'single_tree') {
            const treeName = dragClipboard.copied_tree_data?.tree?.name || dragClipboard.name || 'Tree';
            const relationshipCount = dragClipboard.copied_tree_data?.relationships?.total_cuttings || 0;
            pasteBtn.textContent = `📋 Paste "${treeName}"${relationshipCount > 0 ? ` (+${relationshipCount})` : ''}`;
        } else {
            const treeCount = dragClipboard.tree_count || dragClipboard.trees?.length || 0;
            pasteBtn.textContent = `📋 Paste ${dragClipboard.name || 'Area'} (${treeCount} trees)`;
        }
        
        // Add cross-dome indicator if from different dome
        if (dragClipboard.source_dome_id && dragClipboard.source_dome_id !== domeId) {
            pasteBtn.textContent += ' [Cross-Dome]';
            pasteBtn.classList.add('paste-btn-cross-dome');
        } else {
            pasteBtn.classList.remove('paste-btn-cross-dome');
        }
        
    } else if (clipboardArea) {
        pasteBtn.style.display = 'block';
        
        if (clipboardArea.type === 'single_tree') {
            const treeName = clipboardArea.copied_tree_data?.tree?.name || clipboardArea.name || 'Tree';
            const relationshipCount = clipboardArea.copied_tree_data?.relationships?.total_cuttings || 0;
            pasteBtn.textContent = `📋 Paste "${treeName}"${relationshipCount > 0 ? ` (+${relationshipCount})` : ''}`;
        } else {
            const treeCount = clipboardArea.tree_count || clipboardArea.trees?.length || 0;
            pasteBtn.textContent = `📋 Paste ${clipboardArea.name || 'Area'} (${treeCount} trees)`;
        }
        
        // Add cross-dome indicator if from different dome
        if (clipboardArea.source_dome_id && clipboardArea.source_dome_id !== domeId) {
            pasteBtn.textContent += ' [Cross-Dome]';
            pasteBtn.classList.add('paste-btn-cross-dome');
        } else {
            pasteBtn.classList.remove('paste-btn-cross-dome');
        }
        
    } else if (copiedTreeData) {
        pasteBtn.style.display = 'block';
        const treeName = copiedTreeData.tree?.name || 'Tree';
        const relationshipCount = copiedTreeData.relationships?.total_cuttings || 0;
        pasteBtn.textContent = `📋 Paste "${treeName}"${relationshipCount > 0 ? ` (+${relationshipCount})` : ''}`;
        
        if (copiedTreeData.source_dome_id && copiedTreeData.source_dome_id !== domeId) {
            pasteBtn.textContent += ' [Cross-Dome]';
            pasteBtn.classList.add('paste-btn-cross-dome');
        } else {
            pasteBtn.classList.remove('paste-btn-cross-dome');
        }
    } else {
        pasteBtn.style.display = 'none';
        pasteBtn.textContent = '📋 Paste Area';
    }
    
    console.log('✅ Paste button updated:', pasteBtn.textContent);
}

// ✅ 2. ADD clearClipboardStorage() FUNCTION
function clearClipboardStorage() {
    try {
        console.log('🗑️ Clearing clipboard for dome', domeId);
        
        // Clear dome-specific clipboard first
        localStorage.removeItem(`domeClipboard_${domeId}`);
        
        // Clear global clipboard only if it's from this dome
        const globalDrag = localStorage.getItem('globalDragClipboard');
        const globalTree = localStorage.getItem('globalTreeClipboard');
        
        if (globalDrag) {
            try {
                const data = JSON.parse(globalDrag);
                if (!data.source_dome_id || data.source_dome_id === domeId) {
                    localStorage.removeItem('globalDragClipboard');
                    localStorage.removeItem('globalDragClipboardTimestamp');
                    console.log('🗑️ Cleared global drag clipboard');
                }
            } catch (e) {
                localStorage.removeItem('globalDragClipboard');
                console.log('🗑️ Cleared corrupted global drag clipboard');
            }
        }
        
        if (globalTree) {
            try {
                const data = JSON.parse(globalTree);
                if (!data.source_dome_id || data.source_dome_id === domeId) {
                    localStorage.removeItem('globalTreeClipboard');
                    console.log('🗑️ Cleared global tree clipboard');
                }
            } catch (e) {
                localStorage.removeItem('globalTreeClipboard');
                console.log('🗑️ Cleared corrupted global tree clipboard');
            }
        }
        
        // Clear in-memory clipboard
        window.dragClipboard = null;
        window.clipboardArea = null;
        window.copiedTreeData = null;
        
        // Update paste button
        updatePasteButtonDisplay();
        
        console.log('✅ Clipboard cleared successfully');
        showStatus('Clipboard cleared', 'info');
    } catch (e) {
        console.warn('⚠️ Error clearing clipboard:', e);
    }
}

// ✅ 3. ADD CLIPBOARD PROPERTY WATCHERS
(function() {
    let _dragClipboard = window.dragClipboard || null;
    let _clipboardArea = window.clipboardArea || null;
    let _copiedTreeData = window.copiedTreeData || null;
    
    Object.defineProperty(window, 'dragClipboard', {
        get: function() { return _dragClipboard; },
        set: function(value) {
            _dragClipboard = value;
            console.log('📋 dragClipboard updated:', value?.name);
            setTimeout(updatePasteButtonDisplay, 100);
        }
    });
    
    Object.defineProperty(window, 'clipboardArea', {
        get: function() { return _clipboardArea; },
        set: function(value) {
            _clipboardArea = value;
            console.log('📋 clipboardArea updated:', value?.name);
            setTimeout(updatePasteButtonDisplay, 100);
        }
    });
    
    Object.defineProperty(window, 'copiedTreeData', {
        get: function() { return _copiedTreeData; },
        set: function(value) {
            _copiedTreeData = value;
            console.log('📋 copiedTreeData updated:', value?.tree?.name);
            setTimeout(updatePasteButtonDisplay, 100);
        }
    });
    
    console.log('✅ Clipboard property watchers installed');
})();

// ✅ 4. CALL UPDATE ON PAGE LOAD
setTimeout(function() {
    updatePasteButtonDisplay();
    console.log('✅ Initial paste button update completed');
}, 500);

console.log('✅ Complete dome isolation and paste button management loaded');
</script>
</html>















